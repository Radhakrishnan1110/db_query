
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserAccount
 * 
 */
export type UserAccount = $Result.DefaultSelection<Prisma.$UserAccountPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model DepositWithdrawLimits
 * 
 */
export type DepositWithdrawLimits = $Result.DefaultSelection<Prisma.$DepositWithdrawLimitsPayload>
/**
 * Model TwoFA
 * 
 */
export type TwoFA = $Result.DefaultSelection<Prisma.$TwoFAPayload>
/**
 * Model UserKyc
 * 
 */
export type UserKyc = $Result.DefaultSelection<Prisma.$UserKycPayload>
/**
 * Model EncryptedUserData
 * 
 */
export type EncryptedUserData = $Result.DefaultSelection<Prisma.$EncryptedUserDataPayload>
/**
 * Model UserBankDetails
 * 
 */
export type UserBankDetails = $Result.DefaultSelection<Prisma.$UserBankDetailsPayload>
/**
 * Model FiatPayments
 * 
 */
export type FiatPayments = $Result.DefaultSelection<Prisma.$FiatPaymentsPayload>
/**
 * Model CryptoDeposit
 * 
 */
export type CryptoDeposit = $Result.DefaultSelection<Prisma.$CryptoDepositPayload>
/**
 * Model InrConversionHistory
 * 
 */
export type InrConversionHistory = $Result.DefaultSelection<Prisma.$InrConversionHistoryPayload>
/**
 * Model BankFeed
 * 
 */
export type BankFeed = $Result.DefaultSelection<Prisma.$BankFeedPayload>
/**
 * Model InrLedger
 * 
 */
export type InrLedger = $Result.DefaultSelection<Prisma.$InrLedgerPayload>
/**
 * Model CryptoLedger
 * 
 */
export type CryptoLedger = $Result.DefaultSelection<Prisma.$CryptoLedgerPayload>
/**
 * Model TradeLedger
 * 
 */
export type TradeLedger = $Result.DefaultSelection<Prisma.$TradeLedgerPayload>
/**
 * Model SystemConfigForDashboard
 * 
 */
export type SystemConfigForDashboard = $Result.DefaultSelection<Prisma.$SystemConfigForDashboardPayload>
/**
 * Model SystemConfigChangeLog
 * 
 */
export type SystemConfigChangeLog = $Result.DefaultSelection<Prisma.$SystemConfigChangeLogPayload>
/**
 * Model InrWallet
 * 
 */
export type InrWallet = $Result.DefaultSelection<Prisma.$InrWalletPayload>
/**
 * Model ParentWallet
 * 
 */
export type ParentWallet = $Result.DefaultSelection<Prisma.$ParentWalletPayload>
/**
 * Model StableCoin
 * 
 */
export type StableCoin = $Result.DefaultSelection<Prisma.$StableCoinPayload>
/**
 * Model CryptoWallet
 * 
 */
export type CryptoWallet = $Result.DefaultSelection<Prisma.$CryptoWalletPayload>
/**
 * Model PerpetualContracts
 * 
 */
export type PerpetualContracts = $Result.DefaultSelection<Prisma.$PerpetualContractsPayload>
/**
 * Model KlineHistoricalData
 * 
 */
export type KlineHistoricalData = $Result.DefaultSelection<Prisma.$KlineHistoricalDataPayload>
/**
 * Model UserOrderHistory
 * 
 */
export type UserOrderHistory = $Result.DefaultSelection<Prisma.$UserOrderHistoryPayload>
/**
 * Model UserTradeHistory
 * 
 */
export type UserTradeHistory = $Result.DefaultSelection<Prisma.$UserTradeHistoryPayload>
/**
 * Model UserPositionHistory
 * 
 */
export type UserPositionHistory = $Result.DefaultSelection<Prisma.$UserPositionHistoryPayload>
/**
 * Model BinanceOrderHistory
 * 
 */
export type BinanceOrderHistory = $Result.DefaultSelection<Prisma.$BinanceOrderHistoryPayload>
/**
 * Model BinanceTradeHistory
 * 
 */
export type BinanceTradeHistory = $Result.DefaultSelection<Prisma.$BinanceTradeHistoryPayload>
/**
 * Model CoinwiseTradeRecoincilliation
 * 
 */
export type CoinwiseTradeRecoincilliation = $Result.DefaultSelection<Prisma.$CoinwiseTradeRecoincilliationPayload>
/**
 * Model CoinwisePositionRecoincilliation
 * 
 */
export type CoinwisePositionRecoincilliation = $Result.DefaultSelection<Prisma.$CoinwisePositionRecoincilliationPayload>
/**
 * Model Invoices
 * 
 */
export type Invoices = $Result.DefaultSelection<Prisma.$InvoicesPayload>
/**
 * Model Reports
 * 
 */
export type Reports = $Result.DefaultSelection<Prisma.$ReportsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserAccountType: {
  MAIN: 'MAIN',
  SUBACCOUNT: 'SUBACCOUNT'
};

export type UserAccountType = (typeof UserAccountType)[keyof typeof UserAccountType]


export const UserType: {
  REGULAR: 'REGULAR',
  SYSTEM: 'SYSTEM',
  ADMIN: 'ADMIN'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const SignUpType: {
  FACEBOOK: 'FACEBOOK',
  GITHUB: 'GITHUB',
  GOOGLE: 'GOOGLE',
  LINKEDIN: 'LINKEDIN',
  TWITTER: 'TWITTER',
  EMAIL: 'EMAIL'
};

export type SignUpType = (typeof SignUpType)[keyof typeof SignUpType]


export const Role: {
  REGULAR: 'REGULAR',
  ADMIN: 'ADMIN',
  SYSTEM: 'SYSTEM'
};

export type Role = (typeof Role)[keyof typeof Role]


export const UserKycStatus: {
  PENDING: 'PENDING',
  INITIATED: 'INITIATED',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  MANUALLY_APPROVED: 'MANUALLY_APPROVED',
  MANUALLY_DECLINED: 'MANUALLY_DECLINED',
  NEEDS_REVIEW: 'NEEDS_REVIEW'
};

export type UserKycStatus = (typeof UserKycStatus)[keyof typeof UserKycStatus]


export const BankVerificationStatus: {
  PENDING: 'PENDING',
  INITIATED: 'INITIATED',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type BankVerificationStatus = (typeof BankVerificationStatus)[keyof typeof BankVerificationStatus]


export const TwoFAStatus: {
  INITIATED: 'INITIATED',
  EMAILVERIFIED: 'EMAILVERIFIED',
  PHONEVERIFIED: 'PHONEVERIFIED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type TwoFAStatus = (typeof TwoFAStatus)[keyof typeof TwoFAStatus]


export const Reason: {
  SIGNUP: 'SIGNUP',
  LOGIN: 'LOGIN',
  WITHDRAW: 'WITHDRAW',
  FORGOTPASSWORD: 'FORGOTPASSWORD'
};

export type Reason = (typeof Reason)[keyof typeof Reason]


export const Gender: {
  M: 'M',
  F: 'F',
  O: 'O'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const KycType: {
  REGULAR: 'REGULAR',
  ADVANCED: 'ADVANCED'
};

export type KycType = (typeof KycType)[keyof typeof KycType]


export const HypervergeStatus: {
  STARTED: 'STARTED',
  ERROR: 'ERROR',
  USER_CANCELLED: 'USER_CANCELLED',
  AUTO_APPROVED: 'AUTO_APPROVED',
  NEEDS_REVIEW: 'NEEDS_REVIEW',
  AUTO_DECLINED: 'AUTO_DECLINED',
  MANUALLY_APPROVED: 'MANUALLY_APPROVED',
  MANUALLY_DECLINED: 'MANUALLY_DECLINED'
};

export type HypervergeStatus = (typeof HypervergeStatus)[keyof typeof HypervergeStatus]


export const BankDetailsType: {
  REGULAR: 'REGULAR',
  SYSTEM: 'SYSTEM'
};

export type BankDetailsType = (typeof BankDetailsType)[keyof typeof BankDetailsType]


export const PaymentType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAWAL: 'WITHDRAWAL'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const PaymentStatus: {
  INITIATED: 'INITIATED',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  REFUND: 'REFUND',
  PENDING: 'PENDING'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const InrCreditStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED'
};

export type InrCreditStatus = (typeof InrCreditStatus)[keyof typeof InrCreditStatus]


export const ProcessStatus: {
  INITIATED: 'INITIATED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ProcessStatus = (typeof ProcessStatus)[keyof typeof ProcessStatus]


export const InrOperation: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAW: 'WITHDRAW',
  REFUND: 'REFUND',
  FEE: 'FEE',
  REBATE: 'REBATE',
  GST: 'GST',
  TDS: 'TDS'
};

export type InrOperation = (typeof InrOperation)[keyof typeof InrOperation]


export const CryptoOperation: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAW: 'WITHDRAW',
  CONVERSION: 'CONVERSION'
};

export type CryptoOperation = (typeof CryptoOperation)[keyof typeof CryptoOperation]


export const PositionType: {
  LONG: 'LONG',
  SHORT: 'SHORT'
};

export type PositionType = (typeof PositionType)[keyof typeof PositionType]


export const TradeOperation: {
  BUY: 'BUY',
  SELL: 'SELL',
  FEE: 'FEE',
  FUNDINGFEE: 'FUNDINGFEE',
  COMISSION: 'COMISSION'
};

export type TradeOperation = (typeof TradeOperation)[keyof typeof TradeOperation]


export const ParameterGroup: {
  DEFAULT: 'DEFAULT',
  MARKET: 'MARKET',
  DEPOSIT: 'DEPOSIT',
  WITHDRAW: 'WITHDRAW',
  USER_CONFIG: 'USER_CONFIG',
  TRADE_CONFIG: 'TRADE_CONFIG',
  CONTRACT_CONFIG: 'CONTRACT_CONFIG',
  FEE_CONFIG: 'FEE_CONFIG',
  RISK_MANAGEMENT: 'RISK_MANAGEMENT',
  CONVERSION_RATE: 'CONVERSION_RATE'
};

export type ParameterGroup = (typeof ParameterGroup)[keyof typeof ParameterGroup]


export const ParamType: {
  GLOBAL: 'GLOBAL',
  SYMBOL: 'SYMBOL'
};

export type ParamType = (typeof ParamType)[keyof typeof ParamType]


export const ParentWalletType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAWAL: 'WITHDRAWAL'
};

export type ParentWalletType = (typeof ParentWalletType)[keyof typeof ParentWalletType]


export const Interval: {
  I_1m: 'I_1m',
  I_3m: 'I_3m',
  I_5m: 'I_5m',
  I_15m: 'I_15m',
  I_30m: 'I_30m',
  I_1h: 'I_1h',
  I_2h: 'I_2h',
  I_4h: 'I_4h',
  I_6h: 'I_6h',
  I_8h: 'I_8h',
  I_12h: 'I_12h',
  I_1d: 'I_1d',
  I_3d: 'I_3d',
  I_1w: 'I_1w',
  I_1M: 'I_1M'
};

export type Interval = (typeof Interval)[keyof typeof Interval]

}

export type UserAccountType = $Enums.UserAccountType

export const UserAccountType: typeof $Enums.UserAccountType

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type SignUpType = $Enums.SignUpType

export const SignUpType: typeof $Enums.SignUpType

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type UserKycStatus = $Enums.UserKycStatus

export const UserKycStatus: typeof $Enums.UserKycStatus

export type BankVerificationStatus = $Enums.BankVerificationStatus

export const BankVerificationStatus: typeof $Enums.BankVerificationStatus

export type TwoFAStatus = $Enums.TwoFAStatus

export const TwoFAStatus: typeof $Enums.TwoFAStatus

export type Reason = $Enums.Reason

export const Reason: typeof $Enums.Reason

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type KycType = $Enums.KycType

export const KycType: typeof $Enums.KycType

export type HypervergeStatus = $Enums.HypervergeStatus

export const HypervergeStatus: typeof $Enums.HypervergeStatus

export type BankDetailsType = $Enums.BankDetailsType

export const BankDetailsType: typeof $Enums.BankDetailsType

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type InrCreditStatus = $Enums.InrCreditStatus

export const InrCreditStatus: typeof $Enums.InrCreditStatus

export type ProcessStatus = $Enums.ProcessStatus

export const ProcessStatus: typeof $Enums.ProcessStatus

export type InrOperation = $Enums.InrOperation

export const InrOperation: typeof $Enums.InrOperation

export type CryptoOperation = $Enums.CryptoOperation

export const CryptoOperation: typeof $Enums.CryptoOperation

export type PositionType = $Enums.PositionType

export const PositionType: typeof $Enums.PositionType

export type TradeOperation = $Enums.TradeOperation

export const TradeOperation: typeof $Enums.TradeOperation

export type ParameterGroup = $Enums.ParameterGroup

export const ParameterGroup: typeof $Enums.ParameterGroup

export type ParamType = $Enums.ParamType

export const ParamType: typeof $Enums.ParamType

export type ParentWalletType = $Enums.ParentWalletType

export const ParentWalletType: typeof $Enums.ParentWalletType

export type Interval = $Enums.Interval

export const Interval: typeof $Enums.Interval

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserAccounts
 * const userAccounts = await prisma.userAccount.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserAccounts
   * const userAccounts = await prisma.userAccount.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.userAccount`: Exposes CRUD operations for the **UserAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAccounts
    * const userAccounts = await prisma.userAccount.findMany()
    * ```
    */
  get userAccount(): Prisma.UserAccountDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.depositWithdrawLimits`: Exposes CRUD operations for the **DepositWithdrawLimits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepositWithdrawLimits
    * const depositWithdrawLimits = await prisma.depositWithdrawLimits.findMany()
    * ```
    */
  get depositWithdrawLimits(): Prisma.DepositWithdrawLimitsDelegate<ExtArgs>;

  /**
   * `prisma.twoFA`: Exposes CRUD operations for the **TwoFA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFAS
    * const twoFAS = await prisma.twoFA.findMany()
    * ```
    */
  get twoFA(): Prisma.TwoFADelegate<ExtArgs>;

  /**
   * `prisma.userKyc`: Exposes CRUD operations for the **UserKyc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserKycs
    * const userKycs = await prisma.userKyc.findMany()
    * ```
    */
  get userKyc(): Prisma.UserKycDelegate<ExtArgs>;

  /**
   * `prisma.encryptedUserData`: Exposes CRUD operations for the **EncryptedUserData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncryptedUserData
    * const encryptedUserData = await prisma.encryptedUserData.findMany()
    * ```
    */
  get encryptedUserData(): Prisma.EncryptedUserDataDelegate<ExtArgs>;

  /**
   * `prisma.userBankDetails`: Exposes CRUD operations for the **UserBankDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBankDetails
    * const userBankDetails = await prisma.userBankDetails.findMany()
    * ```
    */
  get userBankDetails(): Prisma.UserBankDetailsDelegate<ExtArgs>;

  /**
   * `prisma.fiatPayments`: Exposes CRUD operations for the **FiatPayments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FiatPayments
    * const fiatPayments = await prisma.fiatPayments.findMany()
    * ```
    */
  get fiatPayments(): Prisma.FiatPaymentsDelegate<ExtArgs>;

  /**
   * `prisma.cryptoDeposit`: Exposes CRUD operations for the **CryptoDeposit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoDeposits
    * const cryptoDeposits = await prisma.cryptoDeposit.findMany()
    * ```
    */
  get cryptoDeposit(): Prisma.CryptoDepositDelegate<ExtArgs>;

  /**
   * `prisma.inrConversionHistory`: Exposes CRUD operations for the **InrConversionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InrConversionHistories
    * const inrConversionHistories = await prisma.inrConversionHistory.findMany()
    * ```
    */
  get inrConversionHistory(): Prisma.InrConversionHistoryDelegate<ExtArgs>;

  /**
   * `prisma.bankFeed`: Exposes CRUD operations for the **BankFeed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankFeeds
    * const bankFeeds = await prisma.bankFeed.findMany()
    * ```
    */
  get bankFeed(): Prisma.BankFeedDelegate<ExtArgs>;

  /**
   * `prisma.inrLedger`: Exposes CRUD operations for the **InrLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InrLedgers
    * const inrLedgers = await prisma.inrLedger.findMany()
    * ```
    */
  get inrLedger(): Prisma.InrLedgerDelegate<ExtArgs>;

  /**
   * `prisma.cryptoLedger`: Exposes CRUD operations for the **CryptoLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoLedgers
    * const cryptoLedgers = await prisma.cryptoLedger.findMany()
    * ```
    */
  get cryptoLedger(): Prisma.CryptoLedgerDelegate<ExtArgs>;

  /**
   * `prisma.tradeLedger`: Exposes CRUD operations for the **TradeLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeLedgers
    * const tradeLedgers = await prisma.tradeLedger.findMany()
    * ```
    */
  get tradeLedger(): Prisma.TradeLedgerDelegate<ExtArgs>;

  /**
   * `prisma.systemConfigForDashboard`: Exposes CRUD operations for the **SystemConfigForDashboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigForDashboards
    * const systemConfigForDashboards = await prisma.systemConfigForDashboard.findMany()
    * ```
    */
  get systemConfigForDashboard(): Prisma.SystemConfigForDashboardDelegate<ExtArgs>;

  /**
   * `prisma.systemConfigChangeLog`: Exposes CRUD operations for the **SystemConfigChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigChangeLogs
    * const systemConfigChangeLogs = await prisma.systemConfigChangeLog.findMany()
    * ```
    */
  get systemConfigChangeLog(): Prisma.SystemConfigChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.inrWallet`: Exposes CRUD operations for the **InrWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InrWallets
    * const inrWallets = await prisma.inrWallet.findMany()
    * ```
    */
  get inrWallet(): Prisma.InrWalletDelegate<ExtArgs>;

  /**
   * `prisma.parentWallet`: Exposes CRUD operations for the **ParentWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParentWallets
    * const parentWallets = await prisma.parentWallet.findMany()
    * ```
    */
  get parentWallet(): Prisma.ParentWalletDelegate<ExtArgs>;

  /**
   * `prisma.stableCoin`: Exposes CRUD operations for the **StableCoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StableCoins
    * const stableCoins = await prisma.stableCoin.findMany()
    * ```
    */
  get stableCoin(): Prisma.StableCoinDelegate<ExtArgs>;

  /**
   * `prisma.cryptoWallet`: Exposes CRUD operations for the **CryptoWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoWallets
    * const cryptoWallets = await prisma.cryptoWallet.findMany()
    * ```
    */
  get cryptoWallet(): Prisma.CryptoWalletDelegate<ExtArgs>;

  /**
   * `prisma.perpetualContracts`: Exposes CRUD operations for the **PerpetualContracts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerpetualContracts
    * const perpetualContracts = await prisma.perpetualContracts.findMany()
    * ```
    */
  get perpetualContracts(): Prisma.PerpetualContractsDelegate<ExtArgs>;

  /**
   * `prisma.klineHistoricalData`: Exposes CRUD operations for the **KlineHistoricalData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KlineHistoricalData
    * const klineHistoricalData = await prisma.klineHistoricalData.findMany()
    * ```
    */
  get klineHistoricalData(): Prisma.KlineHistoricalDataDelegate<ExtArgs>;

  /**
   * `prisma.userOrderHistory`: Exposes CRUD operations for the **UserOrderHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOrderHistories
    * const userOrderHistories = await prisma.userOrderHistory.findMany()
    * ```
    */
  get userOrderHistory(): Prisma.UserOrderHistoryDelegate<ExtArgs>;

  /**
   * `prisma.userTradeHistory`: Exposes CRUD operations for the **UserTradeHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTradeHistories
    * const userTradeHistories = await prisma.userTradeHistory.findMany()
    * ```
    */
  get userTradeHistory(): Prisma.UserTradeHistoryDelegate<ExtArgs>;

  /**
   * `prisma.userPositionHistory`: Exposes CRUD operations for the **UserPositionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPositionHistories
    * const userPositionHistories = await prisma.userPositionHistory.findMany()
    * ```
    */
  get userPositionHistory(): Prisma.UserPositionHistoryDelegate<ExtArgs>;

  /**
   * `prisma.binanceOrderHistory`: Exposes CRUD operations for the **BinanceOrderHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinanceOrderHistories
    * const binanceOrderHistories = await prisma.binanceOrderHistory.findMany()
    * ```
    */
  get binanceOrderHistory(): Prisma.BinanceOrderHistoryDelegate<ExtArgs>;

  /**
   * `prisma.binanceTradeHistory`: Exposes CRUD operations for the **BinanceTradeHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinanceTradeHistories
    * const binanceTradeHistories = await prisma.binanceTradeHistory.findMany()
    * ```
    */
  get binanceTradeHistory(): Prisma.BinanceTradeHistoryDelegate<ExtArgs>;

  /**
   * `prisma.coinwiseTradeRecoincilliation`: Exposes CRUD operations for the **CoinwiseTradeRecoincilliation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoinwiseTradeRecoincilliations
    * const coinwiseTradeRecoincilliations = await prisma.coinwiseTradeRecoincilliation.findMany()
    * ```
    */
  get coinwiseTradeRecoincilliation(): Prisma.CoinwiseTradeRecoincilliationDelegate<ExtArgs>;

  /**
   * `prisma.coinwisePositionRecoincilliation`: Exposes CRUD operations for the **CoinwisePositionRecoincilliation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoinwisePositionRecoincilliations
    * const coinwisePositionRecoincilliations = await prisma.coinwisePositionRecoincilliation.findMany()
    * ```
    */
  get coinwisePositionRecoincilliation(): Prisma.CoinwisePositionRecoincilliationDelegate<ExtArgs>;

  /**
   * `prisma.invoices`: Exposes CRUD operations for the **Invoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoices.findMany()
    * ```
    */
  get invoices(): Prisma.InvoicesDelegate<ExtArgs>;

  /**
   * `prisma.reports`: Exposes CRUD operations for the **Reports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.reports.findMany()
    * ```
    */
  get reports(): Prisma.ReportsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.3.1
   * Query Engine version: 61e140623197a131c2a6189271ffee05a7aa9a59
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserAccount: 'UserAccount',
    User: 'User',
    DepositWithdrawLimits: 'DepositWithdrawLimits',
    TwoFA: 'TwoFA',
    UserKyc: 'UserKyc',
    EncryptedUserData: 'EncryptedUserData',
    UserBankDetails: 'UserBankDetails',
    FiatPayments: 'FiatPayments',
    CryptoDeposit: 'CryptoDeposit',
    InrConversionHistory: 'InrConversionHistory',
    BankFeed: 'BankFeed',
    InrLedger: 'InrLedger',
    CryptoLedger: 'CryptoLedger',
    TradeLedger: 'TradeLedger',
    SystemConfigForDashboard: 'SystemConfigForDashboard',
    SystemConfigChangeLog: 'SystemConfigChangeLog',
    InrWallet: 'InrWallet',
    ParentWallet: 'ParentWallet',
    StableCoin: 'StableCoin',
    CryptoWallet: 'CryptoWallet',
    PerpetualContracts: 'PerpetualContracts',
    KlineHistoricalData: 'KlineHistoricalData',
    UserOrderHistory: 'UserOrderHistory',
    UserTradeHistory: 'UserTradeHistory',
    UserPositionHistory: 'UserPositionHistory',
    BinanceOrderHistory: 'BinanceOrderHistory',
    BinanceTradeHistory: 'BinanceTradeHistory',
    CoinwiseTradeRecoincilliation: 'CoinwiseTradeRecoincilliation',
    CoinwisePositionRecoincilliation: 'CoinwisePositionRecoincilliation',
    Invoices: 'Invoices',
    Reports: 'Reports'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'userAccount' | 'user' | 'depositWithdrawLimits' | 'twoFA' | 'userKyc' | 'encryptedUserData' | 'userBankDetails' | 'fiatPayments' | 'cryptoDeposit' | 'inrConversionHistory' | 'bankFeed' | 'inrLedger' | 'cryptoLedger' | 'tradeLedger' | 'systemConfigForDashboard' | 'systemConfigChangeLog' | 'inrWallet' | 'parentWallet' | 'stableCoin' | 'cryptoWallet' | 'perpetualContracts' | 'klineHistoricalData' | 'userOrderHistory' | 'userTradeHistory' | 'userPositionHistory' | 'binanceOrderHistory' | 'binanceTradeHistory' | 'coinwiseTradeRecoincilliation' | 'coinwisePositionRecoincilliation' | 'invoices' | 'reports'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      UserAccount: {
        payload: Prisma.$UserAccountPayload<ExtArgs>
        fields: Prisma.UserAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findFirst: {
            args: Prisma.UserAccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findMany: {
            args: Prisma.UserAccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          create: {
            args: Prisma.UserAccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          createMany: {
            args: Prisma.UserAccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserAccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          update: {
            args: Prisma.UserAccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserAccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserAccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserAccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          aggregate: {
            args: Prisma.UserAccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserAccount>
          }
          groupBy: {
            args: Prisma.UserAccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAccountCountArgs<ExtArgs>,
            result: $Utils.Optional<UserAccountCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      DepositWithdrawLimits: {
        payload: Prisma.$DepositWithdrawLimitsPayload<ExtArgs>
        fields: Prisma.DepositWithdrawLimitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepositWithdrawLimitsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepositWithdrawLimitsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload>
          }
          findFirst: {
            args: Prisma.DepositWithdrawLimitsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepositWithdrawLimitsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload>
          }
          findMany: {
            args: Prisma.DepositWithdrawLimitsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload>[]
          }
          create: {
            args: Prisma.DepositWithdrawLimitsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload>
          }
          createMany: {
            args: Prisma.DepositWithdrawLimitsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DepositWithdrawLimitsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload>
          }
          update: {
            args: Prisma.DepositWithdrawLimitsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload>
          }
          deleteMany: {
            args: Prisma.DepositWithdrawLimitsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DepositWithdrawLimitsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DepositWithdrawLimitsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepositWithdrawLimitsPayload>
          }
          aggregate: {
            args: Prisma.DepositWithdrawLimitsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDepositWithdrawLimits>
          }
          groupBy: {
            args: Prisma.DepositWithdrawLimitsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DepositWithdrawLimitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepositWithdrawLimitsCountArgs<ExtArgs>,
            result: $Utils.Optional<DepositWithdrawLimitsCountAggregateOutputType> | number
          }
        }
      }
      TwoFA: {
        payload: Prisma.$TwoFAPayload<ExtArgs>
        fields: Prisma.TwoFAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFAFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFAFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload>
          }
          findFirst: {
            args: Prisma.TwoFAFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFAFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload>
          }
          findMany: {
            args: Prisma.TwoFAFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload>[]
          }
          create: {
            args: Prisma.TwoFACreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload>
          }
          createMany: {
            args: Prisma.TwoFACreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TwoFADeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload>
          }
          update: {
            args: Prisma.TwoFAUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload>
          }
          deleteMany: {
            args: Prisma.TwoFADeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFAUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TwoFAUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFAPayload>
          }
          aggregate: {
            args: Prisma.TwoFAAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTwoFA>
          }
          groupBy: {
            args: Prisma.TwoFAGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TwoFAGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFACountArgs<ExtArgs>,
            result: $Utils.Optional<TwoFACountAggregateOutputType> | number
          }
        }
      }
      UserKyc: {
        payload: Prisma.$UserKycPayload<ExtArgs>
        fields: Prisma.UserKycFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserKycFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserKycFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload>
          }
          findFirst: {
            args: Prisma.UserKycFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserKycFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload>
          }
          findMany: {
            args: Prisma.UserKycFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload>[]
          }
          create: {
            args: Prisma.UserKycCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload>
          }
          createMany: {
            args: Prisma.UserKycCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserKycDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload>
          }
          update: {
            args: Prisma.UserKycUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload>
          }
          deleteMany: {
            args: Prisma.UserKycDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserKycUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserKycUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserKycPayload>
          }
          aggregate: {
            args: Prisma.UserKycAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserKyc>
          }
          groupBy: {
            args: Prisma.UserKycGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserKycGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserKycCountArgs<ExtArgs>,
            result: $Utils.Optional<UserKycCountAggregateOutputType> | number
          }
        }
      }
      EncryptedUserData: {
        payload: Prisma.$EncryptedUserDataPayload<ExtArgs>
        fields: Prisma.EncryptedUserDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncryptedUserDataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncryptedUserDataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload>
          }
          findFirst: {
            args: Prisma.EncryptedUserDataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncryptedUserDataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload>
          }
          findMany: {
            args: Prisma.EncryptedUserDataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload>[]
          }
          create: {
            args: Prisma.EncryptedUserDataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload>
          }
          createMany: {
            args: Prisma.EncryptedUserDataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EncryptedUserDataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload>
          }
          update: {
            args: Prisma.EncryptedUserDataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload>
          }
          deleteMany: {
            args: Prisma.EncryptedUserDataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EncryptedUserDataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EncryptedUserDataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncryptedUserDataPayload>
          }
          aggregate: {
            args: Prisma.EncryptedUserDataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEncryptedUserData>
          }
          groupBy: {
            args: Prisma.EncryptedUserDataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EncryptedUserDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncryptedUserDataCountArgs<ExtArgs>,
            result: $Utils.Optional<EncryptedUserDataCountAggregateOutputType> | number
          }
        }
      }
      UserBankDetails: {
        payload: Prisma.$UserBankDetailsPayload<ExtArgs>
        fields: Prisma.UserBankDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBankDetailsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBankDetailsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload>
          }
          findFirst: {
            args: Prisma.UserBankDetailsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBankDetailsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload>
          }
          findMany: {
            args: Prisma.UserBankDetailsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload>[]
          }
          create: {
            args: Prisma.UserBankDetailsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload>
          }
          createMany: {
            args: Prisma.UserBankDetailsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserBankDetailsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload>
          }
          update: {
            args: Prisma.UserBankDetailsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload>
          }
          deleteMany: {
            args: Prisma.UserBankDetailsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserBankDetailsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserBankDetailsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBankDetailsPayload>
          }
          aggregate: {
            args: Prisma.UserBankDetailsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserBankDetails>
          }
          groupBy: {
            args: Prisma.UserBankDetailsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserBankDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBankDetailsCountArgs<ExtArgs>,
            result: $Utils.Optional<UserBankDetailsCountAggregateOutputType> | number
          }
        }
      }
      FiatPayments: {
        payload: Prisma.$FiatPaymentsPayload<ExtArgs>
        fields: Prisma.FiatPaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FiatPaymentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FiatPaymentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload>
          }
          findFirst: {
            args: Prisma.FiatPaymentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FiatPaymentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload>
          }
          findMany: {
            args: Prisma.FiatPaymentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload>[]
          }
          create: {
            args: Prisma.FiatPaymentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload>
          }
          createMany: {
            args: Prisma.FiatPaymentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FiatPaymentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload>
          }
          update: {
            args: Prisma.FiatPaymentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload>
          }
          deleteMany: {
            args: Prisma.FiatPaymentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FiatPaymentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FiatPaymentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FiatPaymentsPayload>
          }
          aggregate: {
            args: Prisma.FiatPaymentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFiatPayments>
          }
          groupBy: {
            args: Prisma.FiatPaymentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FiatPaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FiatPaymentsCountArgs<ExtArgs>,
            result: $Utils.Optional<FiatPaymentsCountAggregateOutputType> | number
          }
        }
      }
      CryptoDeposit: {
        payload: Prisma.$CryptoDepositPayload<ExtArgs>
        fields: Prisma.CryptoDepositFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoDepositFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoDepositFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload>
          }
          findFirst: {
            args: Prisma.CryptoDepositFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoDepositFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload>
          }
          findMany: {
            args: Prisma.CryptoDepositFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload>[]
          }
          create: {
            args: Prisma.CryptoDepositCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload>
          }
          createMany: {
            args: Prisma.CryptoDepositCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CryptoDepositDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload>
          }
          update: {
            args: Prisma.CryptoDepositUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload>
          }
          deleteMany: {
            args: Prisma.CryptoDepositDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoDepositUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CryptoDepositUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoDepositPayload>
          }
          aggregate: {
            args: Prisma.CryptoDepositAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCryptoDeposit>
          }
          groupBy: {
            args: Prisma.CryptoDepositGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CryptoDepositGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoDepositCountArgs<ExtArgs>,
            result: $Utils.Optional<CryptoDepositCountAggregateOutputType> | number
          }
        }
      }
      InrConversionHistory: {
        payload: Prisma.$InrConversionHistoryPayload<ExtArgs>
        fields: Prisma.InrConversionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InrConversionHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InrConversionHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload>
          }
          findFirst: {
            args: Prisma.InrConversionHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InrConversionHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload>
          }
          findMany: {
            args: Prisma.InrConversionHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload>[]
          }
          create: {
            args: Prisma.InrConversionHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload>
          }
          createMany: {
            args: Prisma.InrConversionHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InrConversionHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload>
          }
          update: {
            args: Prisma.InrConversionHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.InrConversionHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InrConversionHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InrConversionHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrConversionHistoryPayload>
          }
          aggregate: {
            args: Prisma.InrConversionHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInrConversionHistory>
          }
          groupBy: {
            args: Prisma.InrConversionHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InrConversionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InrConversionHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<InrConversionHistoryCountAggregateOutputType> | number
          }
        }
      }
      BankFeed: {
        payload: Prisma.$BankFeedPayload<ExtArgs>
        fields: Prisma.BankFeedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankFeedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankFeedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload>
          }
          findFirst: {
            args: Prisma.BankFeedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankFeedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload>
          }
          findMany: {
            args: Prisma.BankFeedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload>[]
          }
          create: {
            args: Prisma.BankFeedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload>
          }
          createMany: {
            args: Prisma.BankFeedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BankFeedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload>
          }
          update: {
            args: Prisma.BankFeedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload>
          }
          deleteMany: {
            args: Prisma.BankFeedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BankFeedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BankFeedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankFeedPayload>
          }
          aggregate: {
            args: Prisma.BankFeedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBankFeed>
          }
          groupBy: {
            args: Prisma.BankFeedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BankFeedGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankFeedCountArgs<ExtArgs>,
            result: $Utils.Optional<BankFeedCountAggregateOutputType> | number
          }
        }
      }
      InrLedger: {
        payload: Prisma.$InrLedgerPayload<ExtArgs>
        fields: Prisma.InrLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InrLedgerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InrLedgerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload>
          }
          findFirst: {
            args: Prisma.InrLedgerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InrLedgerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload>
          }
          findMany: {
            args: Prisma.InrLedgerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload>[]
          }
          create: {
            args: Prisma.InrLedgerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload>
          }
          createMany: {
            args: Prisma.InrLedgerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InrLedgerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload>
          }
          update: {
            args: Prisma.InrLedgerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload>
          }
          deleteMany: {
            args: Prisma.InrLedgerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InrLedgerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InrLedgerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrLedgerPayload>
          }
          aggregate: {
            args: Prisma.InrLedgerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInrLedger>
          }
          groupBy: {
            args: Prisma.InrLedgerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InrLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.InrLedgerCountArgs<ExtArgs>,
            result: $Utils.Optional<InrLedgerCountAggregateOutputType> | number
          }
        }
      }
      CryptoLedger: {
        payload: Prisma.$CryptoLedgerPayload<ExtArgs>
        fields: Prisma.CryptoLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoLedgerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoLedgerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload>
          }
          findFirst: {
            args: Prisma.CryptoLedgerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoLedgerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload>
          }
          findMany: {
            args: Prisma.CryptoLedgerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload>[]
          }
          create: {
            args: Prisma.CryptoLedgerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload>
          }
          createMany: {
            args: Prisma.CryptoLedgerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CryptoLedgerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload>
          }
          update: {
            args: Prisma.CryptoLedgerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload>
          }
          deleteMany: {
            args: Prisma.CryptoLedgerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoLedgerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CryptoLedgerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoLedgerPayload>
          }
          aggregate: {
            args: Prisma.CryptoLedgerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCryptoLedger>
          }
          groupBy: {
            args: Prisma.CryptoLedgerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CryptoLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoLedgerCountArgs<ExtArgs>,
            result: $Utils.Optional<CryptoLedgerCountAggregateOutputType> | number
          }
        }
      }
      TradeLedger: {
        payload: Prisma.$TradeLedgerPayload<ExtArgs>
        fields: Prisma.TradeLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeLedgerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeLedgerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload>
          }
          findFirst: {
            args: Prisma.TradeLedgerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeLedgerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload>
          }
          findMany: {
            args: Prisma.TradeLedgerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload>[]
          }
          create: {
            args: Prisma.TradeLedgerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload>
          }
          createMany: {
            args: Prisma.TradeLedgerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TradeLedgerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload>
          }
          update: {
            args: Prisma.TradeLedgerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload>
          }
          deleteMany: {
            args: Prisma.TradeLedgerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TradeLedgerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TradeLedgerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TradeLedgerPayload>
          }
          aggregate: {
            args: Prisma.TradeLedgerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTradeLedger>
          }
          groupBy: {
            args: Prisma.TradeLedgerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TradeLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeLedgerCountArgs<ExtArgs>,
            result: $Utils.Optional<TradeLedgerCountAggregateOutputType> | number
          }
        }
      }
      SystemConfigForDashboard: {
        payload: Prisma.$SystemConfigForDashboardPayload<ExtArgs>
        fields: Prisma.SystemConfigForDashboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigForDashboardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigForDashboardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigForDashboardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigForDashboardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload>
          }
          findMany: {
            args: Prisma.SystemConfigForDashboardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload>[]
          }
          create: {
            args: Prisma.SystemConfigForDashboardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload>
          }
          createMany: {
            args: Prisma.SystemConfigForDashboardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SystemConfigForDashboardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload>
          }
          update: {
            args: Prisma.SystemConfigForDashboardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigForDashboardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigForDashboardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigForDashboardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigForDashboardPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigForDashboardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSystemConfigForDashboard>
          }
          groupBy: {
            args: Prisma.SystemConfigForDashboardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SystemConfigForDashboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigForDashboardCountArgs<ExtArgs>,
            result: $Utils.Optional<SystemConfigForDashboardCountAggregateOutputType> | number
          }
        }
      }
      SystemConfigChangeLog: {
        payload: Prisma.$SystemConfigChangeLogPayload<ExtArgs>
        fields: Prisma.SystemConfigChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigChangeLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigChangeLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigChangeLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigChangeLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload>
          }
          findMany: {
            args: Prisma.SystemConfigChangeLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload>[]
          }
          create: {
            args: Prisma.SystemConfigChangeLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload>
          }
          createMany: {
            args: Prisma.SystemConfigChangeLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SystemConfigChangeLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload>
          }
          update: {
            args: Prisma.SystemConfigChangeLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigChangeLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigChangeLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigChangeLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SystemConfigChangeLogPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigChangeLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSystemConfigChangeLog>
          }
          groupBy: {
            args: Prisma.SystemConfigChangeLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SystemConfigChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigChangeLogCountArgs<ExtArgs>,
            result: $Utils.Optional<SystemConfigChangeLogCountAggregateOutputType> | number
          }
        }
      }
      InrWallet: {
        payload: Prisma.$InrWalletPayload<ExtArgs>
        fields: Prisma.InrWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InrWalletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InrWalletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload>
          }
          findFirst: {
            args: Prisma.InrWalletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InrWalletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload>
          }
          findMany: {
            args: Prisma.InrWalletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload>[]
          }
          create: {
            args: Prisma.InrWalletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload>
          }
          createMany: {
            args: Prisma.InrWalletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InrWalletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload>
          }
          update: {
            args: Prisma.InrWalletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload>
          }
          deleteMany: {
            args: Prisma.InrWalletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InrWalletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InrWalletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InrWalletPayload>
          }
          aggregate: {
            args: Prisma.InrWalletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInrWallet>
          }
          groupBy: {
            args: Prisma.InrWalletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InrWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.InrWalletCountArgs<ExtArgs>,
            result: $Utils.Optional<InrWalletCountAggregateOutputType> | number
          }
        }
      }
      ParentWallet: {
        payload: Prisma.$ParentWalletPayload<ExtArgs>
        fields: Prisma.ParentWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentWalletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentWalletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload>
          }
          findFirst: {
            args: Prisma.ParentWalletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentWalletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload>
          }
          findMany: {
            args: Prisma.ParentWalletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload>[]
          }
          create: {
            args: Prisma.ParentWalletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload>
          }
          createMany: {
            args: Prisma.ParentWalletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ParentWalletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload>
          }
          update: {
            args: Prisma.ParentWalletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload>
          }
          deleteMany: {
            args: Prisma.ParentWalletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ParentWalletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ParentWalletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentWalletPayload>
          }
          aggregate: {
            args: Prisma.ParentWalletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParentWallet>
          }
          groupBy: {
            args: Prisma.ParentWalletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParentWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentWalletCountArgs<ExtArgs>,
            result: $Utils.Optional<ParentWalletCountAggregateOutputType> | number
          }
        }
      }
      StableCoin: {
        payload: Prisma.$StableCoinPayload<ExtArgs>
        fields: Prisma.StableCoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StableCoinFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StableCoinFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload>
          }
          findFirst: {
            args: Prisma.StableCoinFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StableCoinFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload>
          }
          findMany: {
            args: Prisma.StableCoinFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload>[]
          }
          create: {
            args: Prisma.StableCoinCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload>
          }
          createMany: {
            args: Prisma.StableCoinCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StableCoinDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload>
          }
          update: {
            args: Prisma.StableCoinUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload>
          }
          deleteMany: {
            args: Prisma.StableCoinDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StableCoinUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StableCoinUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StableCoinPayload>
          }
          aggregate: {
            args: Prisma.StableCoinAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStableCoin>
          }
          groupBy: {
            args: Prisma.StableCoinGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StableCoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.StableCoinCountArgs<ExtArgs>,
            result: $Utils.Optional<StableCoinCountAggregateOutputType> | number
          }
        }
      }
      CryptoWallet: {
        payload: Prisma.$CryptoWalletPayload<ExtArgs>
        fields: Prisma.CryptoWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoWalletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoWalletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          findFirst: {
            args: Prisma.CryptoWalletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoWalletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          findMany: {
            args: Prisma.CryptoWalletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          create: {
            args: Prisma.CryptoWalletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          createMany: {
            args: Prisma.CryptoWalletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CryptoWalletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          update: {
            args: Prisma.CryptoWalletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          deleteMany: {
            args: Prisma.CryptoWalletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoWalletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CryptoWalletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          aggregate: {
            args: Prisma.CryptoWalletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCryptoWallet>
          }
          groupBy: {
            args: Prisma.CryptoWalletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CryptoWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoWalletCountArgs<ExtArgs>,
            result: $Utils.Optional<CryptoWalletCountAggregateOutputType> | number
          }
        }
      }
      PerpetualContracts: {
        payload: Prisma.$PerpetualContractsPayload<ExtArgs>
        fields: Prisma.PerpetualContractsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerpetualContractsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerpetualContractsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload>
          }
          findFirst: {
            args: Prisma.PerpetualContractsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerpetualContractsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload>
          }
          findMany: {
            args: Prisma.PerpetualContractsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload>[]
          }
          create: {
            args: Prisma.PerpetualContractsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload>
          }
          createMany: {
            args: Prisma.PerpetualContractsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PerpetualContractsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload>
          }
          update: {
            args: Prisma.PerpetualContractsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload>
          }
          deleteMany: {
            args: Prisma.PerpetualContractsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PerpetualContractsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PerpetualContractsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PerpetualContractsPayload>
          }
          aggregate: {
            args: Prisma.PerpetualContractsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePerpetualContracts>
          }
          groupBy: {
            args: Prisma.PerpetualContractsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PerpetualContractsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerpetualContractsCountArgs<ExtArgs>,
            result: $Utils.Optional<PerpetualContractsCountAggregateOutputType> | number
          }
        }
      }
      KlineHistoricalData: {
        payload: Prisma.$KlineHistoricalDataPayload<ExtArgs>
        fields: Prisma.KlineHistoricalDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KlineHistoricalDataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KlineHistoricalDataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload>
          }
          findFirst: {
            args: Prisma.KlineHistoricalDataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KlineHistoricalDataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload>
          }
          findMany: {
            args: Prisma.KlineHistoricalDataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload>[]
          }
          create: {
            args: Prisma.KlineHistoricalDataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload>
          }
          createMany: {
            args: Prisma.KlineHistoricalDataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.KlineHistoricalDataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload>
          }
          update: {
            args: Prisma.KlineHistoricalDataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload>
          }
          deleteMany: {
            args: Prisma.KlineHistoricalDataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.KlineHistoricalDataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.KlineHistoricalDataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KlineHistoricalDataPayload>
          }
          aggregate: {
            args: Prisma.KlineHistoricalDataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKlineHistoricalData>
          }
          groupBy: {
            args: Prisma.KlineHistoricalDataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<KlineHistoricalDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.KlineHistoricalDataCountArgs<ExtArgs>,
            result: $Utils.Optional<KlineHistoricalDataCountAggregateOutputType> | number
          }
        }
      }
      UserOrderHistory: {
        payload: Prisma.$UserOrderHistoryPayload<ExtArgs>
        fields: Prisma.UserOrderHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOrderHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOrderHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserOrderHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOrderHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload>
          }
          findMany: {
            args: Prisma.UserOrderHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload>[]
          }
          create: {
            args: Prisma.UserOrderHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload>
          }
          createMany: {
            args: Prisma.UserOrderHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserOrderHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload>
          }
          update: {
            args: Prisma.UserOrderHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserOrderHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserOrderHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserOrderHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrderHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserOrderHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserOrderHistory>
          }
          groupBy: {
            args: Prisma.UserOrderHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserOrderHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOrderHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<UserOrderHistoryCountAggregateOutputType> | number
          }
        }
      }
      UserTradeHistory: {
        payload: Prisma.$UserTradeHistoryPayload<ExtArgs>
        fields: Prisma.UserTradeHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTradeHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTradeHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserTradeHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTradeHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload>
          }
          findMany: {
            args: Prisma.UserTradeHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload>[]
          }
          create: {
            args: Prisma.UserTradeHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload>
          }
          createMany: {
            args: Prisma.UserTradeHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserTradeHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload>
          }
          update: {
            args: Prisma.UserTradeHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserTradeHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserTradeHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserTradeHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserTradeHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserTradeHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserTradeHistory>
          }
          groupBy: {
            args: Prisma.UserTradeHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserTradeHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTradeHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<UserTradeHistoryCountAggregateOutputType> | number
          }
        }
      }
      UserPositionHistory: {
        payload: Prisma.$UserPositionHistoryPayload<ExtArgs>
        fields: Prisma.UserPositionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPositionHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPositionHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserPositionHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPositionHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload>
          }
          findMany: {
            args: Prisma.UserPositionHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload>[]
          }
          create: {
            args: Prisma.UserPositionHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload>
          }
          createMany: {
            args: Prisma.UserPositionHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserPositionHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload>
          }
          update: {
            args: Prisma.UserPositionHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserPositionHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserPositionHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserPositionHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPositionHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserPositionHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPositionHistory>
          }
          groupBy: {
            args: Prisma.UserPositionHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPositionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPositionHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPositionHistoryCountAggregateOutputType> | number
          }
        }
      }
      BinanceOrderHistory: {
        payload: Prisma.$BinanceOrderHistoryPayload<ExtArgs>
        fields: Prisma.BinanceOrderHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BinanceOrderHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BinanceOrderHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload>
          }
          findFirst: {
            args: Prisma.BinanceOrderHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BinanceOrderHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload>
          }
          findMany: {
            args: Prisma.BinanceOrderHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload>[]
          }
          create: {
            args: Prisma.BinanceOrderHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload>
          }
          createMany: {
            args: Prisma.BinanceOrderHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BinanceOrderHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload>
          }
          update: {
            args: Prisma.BinanceOrderHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload>
          }
          deleteMany: {
            args: Prisma.BinanceOrderHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BinanceOrderHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BinanceOrderHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceOrderHistoryPayload>
          }
          aggregate: {
            args: Prisma.BinanceOrderHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBinanceOrderHistory>
          }
          groupBy: {
            args: Prisma.BinanceOrderHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BinanceOrderHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BinanceOrderHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<BinanceOrderHistoryCountAggregateOutputType> | number
          }
        }
      }
      BinanceTradeHistory: {
        payload: Prisma.$BinanceTradeHistoryPayload<ExtArgs>
        fields: Prisma.BinanceTradeHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BinanceTradeHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BinanceTradeHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload>
          }
          findFirst: {
            args: Prisma.BinanceTradeHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BinanceTradeHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload>
          }
          findMany: {
            args: Prisma.BinanceTradeHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload>[]
          }
          create: {
            args: Prisma.BinanceTradeHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload>
          }
          createMany: {
            args: Prisma.BinanceTradeHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BinanceTradeHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload>
          }
          update: {
            args: Prisma.BinanceTradeHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload>
          }
          deleteMany: {
            args: Prisma.BinanceTradeHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BinanceTradeHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BinanceTradeHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BinanceTradeHistoryPayload>
          }
          aggregate: {
            args: Prisma.BinanceTradeHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBinanceTradeHistory>
          }
          groupBy: {
            args: Prisma.BinanceTradeHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BinanceTradeHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BinanceTradeHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<BinanceTradeHistoryCountAggregateOutputType> | number
          }
        }
      }
      CoinwiseTradeRecoincilliation: {
        payload: Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>
        fields: Prisma.CoinwiseTradeRecoincilliationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoinwiseTradeRecoincilliationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoinwiseTradeRecoincilliationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload>
          }
          findFirst: {
            args: Prisma.CoinwiseTradeRecoincilliationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoinwiseTradeRecoincilliationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload>
          }
          findMany: {
            args: Prisma.CoinwiseTradeRecoincilliationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload>[]
          }
          create: {
            args: Prisma.CoinwiseTradeRecoincilliationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload>
          }
          createMany: {
            args: Prisma.CoinwiseTradeRecoincilliationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CoinwiseTradeRecoincilliationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload>
          }
          update: {
            args: Prisma.CoinwiseTradeRecoincilliationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload>
          }
          deleteMany: {
            args: Prisma.CoinwiseTradeRecoincilliationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CoinwiseTradeRecoincilliationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CoinwiseTradeRecoincilliationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwiseTradeRecoincilliationPayload>
          }
          aggregate: {
            args: Prisma.CoinwiseTradeRecoincilliationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCoinwiseTradeRecoincilliation>
          }
          groupBy: {
            args: Prisma.CoinwiseTradeRecoincilliationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CoinwiseTradeRecoincilliationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoinwiseTradeRecoincilliationCountArgs<ExtArgs>,
            result: $Utils.Optional<CoinwiseTradeRecoincilliationCountAggregateOutputType> | number
          }
        }
      }
      CoinwisePositionRecoincilliation: {
        payload: Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>
        fields: Prisma.CoinwisePositionRecoincilliationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoinwisePositionRecoincilliationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoinwisePositionRecoincilliationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload>
          }
          findFirst: {
            args: Prisma.CoinwisePositionRecoincilliationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoinwisePositionRecoincilliationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload>
          }
          findMany: {
            args: Prisma.CoinwisePositionRecoincilliationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload>[]
          }
          create: {
            args: Prisma.CoinwisePositionRecoincilliationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload>
          }
          createMany: {
            args: Prisma.CoinwisePositionRecoincilliationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CoinwisePositionRecoincilliationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload>
          }
          update: {
            args: Prisma.CoinwisePositionRecoincilliationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload>
          }
          deleteMany: {
            args: Prisma.CoinwisePositionRecoincilliationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CoinwisePositionRecoincilliationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CoinwisePositionRecoincilliationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoinwisePositionRecoincilliationPayload>
          }
          aggregate: {
            args: Prisma.CoinwisePositionRecoincilliationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCoinwisePositionRecoincilliation>
          }
          groupBy: {
            args: Prisma.CoinwisePositionRecoincilliationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CoinwisePositionRecoincilliationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoinwisePositionRecoincilliationCountArgs<ExtArgs>,
            result: $Utils.Optional<CoinwisePositionRecoincilliationCountAggregateOutputType> | number
          }
        }
      }
      Invoices: {
        payload: Prisma.$InvoicesPayload<ExtArgs>
        fields: Prisma.InvoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          findFirst: {
            args: Prisma.InvoicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          findMany: {
            args: Prisma.InvoicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>[]
          }
          create: {
            args: Prisma.InvoicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          createMany: {
            args: Prisma.InvoicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvoicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          update: {
            args: Prisma.InvoicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          deleteMany: {
            args: Prisma.InvoicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvoicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvoicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          aggregate: {
            args: Prisma.InvoicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvoices>
          }
          groupBy: {
            args: Prisma.InvoicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoicesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvoicesCountAggregateOutputType> | number
          }
        }
      }
      Reports: {
        payload: Prisma.$ReportsPayload<ExtArgs>
        fields: Prisma.ReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload>
          }
          findFirst: {
            args: Prisma.ReportsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload>
          }
          findMany: {
            args: Prisma.ReportsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload>[]
          }
          create: {
            args: Prisma.ReportsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload>
          }
          createMany: {
            args: Prisma.ReportsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload>
          }
          update: {
            args: Prisma.ReportsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload>
          }
          deleteMany: {
            args: Prisma.ReportsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportsPayload>
          }
          aggregate: {
            args: Prisma.ReportsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReports>
          }
          groupBy: {
            args: Prisma.ReportsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportsCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserAccountCountOutputType
   */

  export type UserAccountCountOutputType = {
    InrLedgerRel: number
    CryptoLedgerRel: number
    TradeLedgerRel: number
    CryptoWalletRel: number
    InrConvRel: number
  }

  export type UserAccountCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    InrLedgerRel?: boolean | UserAccountCountOutputTypeCountInrLedgerRelArgs
    CryptoLedgerRel?: boolean | UserAccountCountOutputTypeCountCryptoLedgerRelArgs
    TradeLedgerRel?: boolean | UserAccountCountOutputTypeCountTradeLedgerRelArgs
    CryptoWalletRel?: boolean | UserAccountCountOutputTypeCountCryptoWalletRelArgs
    InrConvRel?: boolean | UserAccountCountOutputTypeCountInrConvRelArgs
  }

  // Custom InputTypes

  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccountCountOutputType
     */
    select?: UserAccountCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeCountInrLedgerRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InrLedgerWhereInput
  }


  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeCountCryptoLedgerRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CryptoLedgerWhereInput
  }


  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeCountTradeLedgerRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TradeLedgerWhereInput
  }


  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeCountCryptoWalletRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CryptoWalletWhereInput
  }


  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeCountInrConvRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InrConversionHistoryWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    UserBankDetailsRel: number
    FiatPaymentsRel: number
    TwoFARel: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    UserBankDetailsRel?: boolean | UserCountOutputTypeCountUserBankDetailsRelArgs
    FiatPaymentsRel?: boolean | UserCountOutputTypeCountFiatPaymentsRelArgs
    TwoFARel?: boolean | UserCountOutputTypeCountTwoFARelArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserBankDetailsRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserBankDetailsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFiatPaymentsRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FiatPaymentsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTwoFARelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TwoFAWhereInput
  }



  /**
   * Count Type UserBankDetailsCountOutputType
   */

  export type UserBankDetailsCountOutputType = {
    UserBankRel: number
    FiatPaymentsRel: number
    UserRel: number
  }

  export type UserBankDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    UserBankRel?: boolean | UserBankDetailsCountOutputTypeCountUserBankRelArgs
    FiatPaymentsRel?: boolean | UserBankDetailsCountOutputTypeCountFiatPaymentsRelArgs
    UserRel?: boolean | UserBankDetailsCountOutputTypeCountUserRelArgs
  }

  // Custom InputTypes

  /**
   * UserBankDetailsCountOutputType without action
   */
  export type UserBankDetailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetailsCountOutputType
     */
    select?: UserBankDetailsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserBankDetailsCountOutputType without action
   */
  export type UserBankDetailsCountOutputTypeCountUserBankRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FiatPaymentsWhereInput
  }


  /**
   * UserBankDetailsCountOutputType without action
   */
  export type UserBankDetailsCountOutputTypeCountFiatPaymentsRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FiatPaymentsWhereInput
  }


  /**
   * UserBankDetailsCountOutputType without action
   */
  export type UserBankDetailsCountOutputTypeCountUserRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type CryptoDepositCountOutputType
   */

  export type CryptoDepositCountOutputType = {
    inrConvHistRel: number
  }

  export type CryptoDepositCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    inrConvHistRel?: boolean | CryptoDepositCountOutputTypeCountInrConvHistRelArgs
  }

  // Custom InputTypes

  /**
   * CryptoDepositCountOutputType without action
   */
  export type CryptoDepositCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDepositCountOutputType
     */
    select?: CryptoDepositCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CryptoDepositCountOutputType without action
   */
  export type CryptoDepositCountOutputTypeCountInrConvHistRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InrConversionHistoryWhereInput
  }



  /**
   * Count Type ParentWalletCountOutputType
   */

  export type ParentWalletCountOutputType = {
    childCryptoWallet: number
    parentWallet: number
  }

  export type ParentWalletCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    childCryptoWallet?: boolean | ParentWalletCountOutputTypeCountChildCryptoWalletArgs
    parentWallet?: boolean | ParentWalletCountOutputTypeCountParentWalletArgs
  }

  // Custom InputTypes

  /**
   * ParentWalletCountOutputType without action
   */
  export type ParentWalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWalletCountOutputType
     */
    select?: ParentWalletCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ParentWalletCountOutputType without action
   */
  export type ParentWalletCountOutputTypeCountChildCryptoWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CryptoWalletWhereInput
  }


  /**
   * ParentWalletCountOutputType without action
   */
  export type ParentWalletCountOutputTypeCountParentWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StableCoinWhereInput
  }



  /**
   * Count Type CryptoWalletCountOutputType
   */

  export type CryptoWalletCountOutputType = {
    cryptoDeposit: number
  }

  export type CryptoWalletCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    cryptoDeposit?: boolean | CryptoWalletCountOutputTypeCountCryptoDepositArgs
  }

  // Custom InputTypes

  /**
   * CryptoWalletCountOutputType without action
   */
  export type CryptoWalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWalletCountOutputType
     */
    select?: CryptoWalletCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CryptoWalletCountOutputType without action
   */
  export type CryptoWalletCountOutputTypeCountCryptoDepositArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CryptoDepositWhereInput
  }



  /**
   * Models
   */

  /**
   * Model UserAccount
   */

  export type AggregateUserAccount = {
    _count: UserAccountCountAggregateOutputType | null
    _avg: UserAccountAvgAggregateOutputType | null
    _sum: UserAccountSumAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  export type UserAccountAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    parentAccount: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserAccountSumAggregateOutputType = {
    id: number | null
    userId: number | null
    parentAccount: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserAccountMinAggregateOutputType = {
    id: number | null
    userId: number | null
    parentAccount: number | null
    accountType: $Enums.UserAccountType | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserAccountMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    parentAccount: number | null
    accountType: $Enums.UserAccountType | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserAccountCountAggregateOutputType = {
    id: number
    userId: number
    parentAccount: number
    accountType: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserAccountAvgAggregateInputType = {
    id?: true
    userId?: true
    parentAccount?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserAccountSumAggregateInputType = {
    id?: true
    userId?: true
    parentAccount?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserAccountMinAggregateInputType = {
    id?: true
    userId?: true
    parentAccount?: true
    accountType?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    parentAccount?: true
    accountType?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserAccountCountAggregateInputType = {
    id?: true
    userId?: true
    parentAccount?: true
    accountType?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserAccountAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccount to aggregate.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAccounts
    **/
    _count?: true | UserAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAccountMaxAggregateInputType
  }

  export type GetUserAccountAggregateType<T extends UserAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAccount[P]>
      : GetScalarType<T[P], AggregateUserAccount[P]>
  }




  export type UserAccountGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithAggregationInput | UserAccountOrderByWithAggregationInput[]
    by: UserAccountScalarFieldEnum[] | UserAccountScalarFieldEnum
    having?: UserAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAccountCountAggregateInputType | true
    _avg?: UserAccountAvgAggregateInputType
    _sum?: UserAccountSumAggregateInputType
    _min?: UserAccountMinAggregateInputType
    _max?: UserAccountMaxAggregateInputType
  }

  export type UserAccountGroupByOutputType = {
    id: number
    userId: number
    parentAccount: number | null
    accountType: $Enums.UserAccountType
    isActive: boolean
    createdAt: Date
    createdBy: number | null
    updatedAt: Date
    updatedBy: number | null
    _count: UserAccountCountAggregateOutputType | null
    _avg: UserAccountAvgAggregateOutputType | null
    _sum: UserAccountSumAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  type GetUserAccountGroupByPayload<T extends UserAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserAccountSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    parentAccount?: boolean
    accountType?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    UserRel?: boolean | UserDefaultArgs<ExtArgs>
    InrLedgerRel?: boolean | UserAccount$InrLedgerRelArgs<ExtArgs>
    CryptoLedgerRel?: boolean | UserAccount$CryptoLedgerRelArgs<ExtArgs>
    TradeLedgerRel?: boolean | UserAccount$TradeLedgerRelArgs<ExtArgs>
    InrWalletRel?: boolean | UserAccount$InrWalletRelArgs<ExtArgs>
    CryptoWalletRel?: boolean | UserAccount$CryptoWalletRelArgs<ExtArgs>
    InrConvRel?: boolean | UserAccount$InrConvRelArgs<ExtArgs>
    _count?: boolean | UserAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccount"]>

  export type UserAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    parentAccount?: boolean
    accountType?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type UserAccountInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    UserRel?: boolean | UserDefaultArgs<ExtArgs>
    InrLedgerRel?: boolean | UserAccount$InrLedgerRelArgs<ExtArgs>
    CryptoLedgerRel?: boolean | UserAccount$CryptoLedgerRelArgs<ExtArgs>
    TradeLedgerRel?: boolean | UserAccount$TradeLedgerRelArgs<ExtArgs>
    InrWalletRel?: boolean | UserAccount$InrWalletRelArgs<ExtArgs>
    CryptoWalletRel?: boolean | UserAccount$CryptoWalletRelArgs<ExtArgs>
    InrConvRel?: boolean | UserAccount$InrConvRelArgs<ExtArgs>
    _count?: boolean | UserAccountCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserAccountPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "UserAccount"
    objects: {
      UserRel: Prisma.$UserPayload<ExtArgs>
      InrLedgerRel: Prisma.$InrLedgerPayload<ExtArgs>[]
      CryptoLedgerRel: Prisma.$CryptoLedgerPayload<ExtArgs>[]
      TradeLedgerRel: Prisma.$TradeLedgerPayload<ExtArgs>[]
      InrWalletRel: Prisma.$InrWalletPayload<ExtArgs> | null
      CryptoWalletRel: Prisma.$CryptoWalletPayload<ExtArgs>[]
      InrConvRel: Prisma.$InrConversionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      parentAccount: number | null
      accountType: $Enums.UserAccountType
      isActive: boolean
      createdAt: Date
      createdBy: number | null
      updatedAt: Date
      updatedBy: number | null
    }, ExtArgs["result"]["userAccount"]>
    composites: {}
  }


  type UserAccountGetPayload<S extends boolean | null | undefined | UserAccountDefaultArgs> = $Result.GetResult<Prisma.$UserAccountPayload, S>

  type UserAccountCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserAccountFindManyArgs, 'select' | 'include'> & {
      select?: UserAccountCountAggregateInputType | true
    }

  export interface UserAccountDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAccount'], meta: { name: 'UserAccount' } }
    /**
     * Find zero or one UserAccount that matches the filter.
     * @param {UserAccountFindUniqueArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserAccountFindUniqueArgs<ExtArgs>>
    ): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserAccount that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserAccountFindUniqueOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAccountFindFirstArgs<ExtArgs>>
    ): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAccounts
     * const userAccounts = await prisma.userAccount.findMany()
     * 
     * // Get first 10 UserAccounts
     * const userAccounts = await prisma.userAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAccountWithIdOnly = await prisma.userAccount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserAccount.
     * @param {UserAccountCreateArgs} args - Arguments to create a UserAccount.
     * @example
     * // Create one UserAccount
     * const UserAccount = await prisma.userAccount.create({
     *   data: {
     *     // ... data to create a UserAccount
     *   }
     * })
     * 
    **/
    create<T extends UserAccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAccountCreateArgs<ExtArgs>>
    ): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserAccounts.
     *     @param {UserAccountCreateManyArgs} args - Arguments to create many UserAccounts.
     *     @example
     *     // Create many UserAccounts
     *     const userAccount = await prisma.userAccount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAccount.
     * @param {UserAccountDeleteArgs} args - Arguments to delete one UserAccount.
     * @example
     * // Delete one UserAccount
     * const UserAccount = await prisma.userAccount.delete({
     *   where: {
     *     // ... filter to delete one UserAccount
     *   }
     * })
     * 
    **/
    delete<T extends UserAccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserAccountDeleteArgs<ExtArgs>>
    ): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserAccount.
     * @param {UserAccountUpdateArgs} args - Arguments to update one UserAccount.
     * @example
     * // Update one UserAccount
     * const userAccount = await prisma.userAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAccountUpdateArgs<ExtArgs>>
    ): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserAccounts.
     * @param {UserAccountDeleteManyArgs} args - Arguments to filter UserAccounts to delete.
     * @example
     * // Delete a few UserAccounts
     * const { count } = await prisma.userAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAccounts
     * const userAccount = await prisma.userAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserAccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAccount.
     * @param {UserAccountUpsertArgs} args - Arguments to update or create a UserAccount.
     * @example
     * // Update or create a UserAccount
     * const userAccount = await prisma.userAccount.upsert({
     *   create: {
     *     // ... data to create a UserAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAccount we want to update
     *   }
     * })
    **/
    upsert<T extends UserAccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserAccountUpsertArgs<ExtArgs>>
    ): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountCountArgs} args - Arguments to filter UserAccounts to count.
     * @example
     * // Count the number of UserAccounts
     * const count = await prisma.userAccount.count({
     *   where: {
     *     // ... the filter for the UserAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserAccountCountArgs>(
      args?: Subset<T, UserAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAccountAggregateArgs>(args: Subset<T, UserAccountAggregateArgs>): Prisma.PrismaPromise<GetUserAccountAggregateType<T>>

    /**
     * Group by UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAccount model
   */
  readonly fields: UserAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAccountClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    UserRel<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    InrLedgerRel<T extends UserAccount$InrLedgerRelArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$InrLedgerRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'findMany'> | Null>;

    CryptoLedgerRel<T extends UserAccount$CryptoLedgerRelArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$CryptoLedgerRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'findMany'> | Null>;

    TradeLedgerRel<T extends UserAccount$TradeLedgerRelArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$TradeLedgerRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'findMany'> | Null>;

    InrWalletRel<T extends UserAccount$InrWalletRelArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$InrWalletRelArgs<ExtArgs>>): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    CryptoWalletRel<T extends UserAccount$CryptoWalletRelArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$CryptoWalletRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'findMany'> | Null>;

    InrConvRel<T extends UserAccount$InrConvRelArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$InrConvRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserAccount model
   */ 
  interface UserAccountFieldRefs {
    readonly id: FieldRef<"UserAccount", 'Int'>
    readonly userId: FieldRef<"UserAccount", 'Int'>
    readonly parentAccount: FieldRef<"UserAccount", 'Int'>
    readonly accountType: FieldRef<"UserAccount", 'UserAccountType'>
    readonly isActive: FieldRef<"UserAccount", 'Boolean'>
    readonly createdAt: FieldRef<"UserAccount", 'DateTime'>
    readonly createdBy: FieldRef<"UserAccount", 'Int'>
    readonly updatedAt: FieldRef<"UserAccount", 'DateTime'>
    readonly updatedBy: FieldRef<"UserAccount", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserAccount findUnique
   */
  export type UserAccountFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }


  /**
   * UserAccount findUniqueOrThrow
   */
  export type UserAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }


  /**
   * UserAccount findFirst
   */
  export type UserAccountFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }


  /**
   * UserAccount findFirstOrThrow
   */
  export type UserAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }


  /**
   * UserAccount findMany
   */
  export type UserAccountFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccounts to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }


  /**
   * UserAccount create
   */
  export type UserAccountCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAccount.
     */
    data: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
  }


  /**
   * UserAccount createMany
   */
  export type UserAccountCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserAccount update
   */
  export type UserAccountUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAccount.
     */
    data: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
    /**
     * Choose, which UserAccount to update.
     */
    where: UserAccountWhereUniqueInput
  }


  /**
   * UserAccount updateMany
   */
  export type UserAccountUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAccounts.
     */
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserAccounts to update
     */
    where?: UserAccountWhereInput
  }


  /**
   * UserAccount upsert
   */
  export type UserAccountUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAccount to update in case it exists.
     */
    where: UserAccountWhereUniqueInput
    /**
     * In case the UserAccount found by the `where` argument doesn't exist, create a new UserAccount with this data.
     */
    create: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
    /**
     * In case the UserAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
  }


  /**
   * UserAccount delete
   */
  export type UserAccountDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter which UserAccount to delete.
     */
    where: UserAccountWhereUniqueInput
  }


  /**
   * UserAccount deleteMany
   */
  export type UserAccountDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccounts to delete
     */
    where?: UserAccountWhereInput
  }


  /**
   * UserAccount.InrLedgerRel
   */
  export type UserAccount$InrLedgerRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    where?: InrLedgerWhereInput
    orderBy?: InrLedgerOrderByWithRelationInput | InrLedgerOrderByWithRelationInput[]
    cursor?: InrLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InrLedgerScalarFieldEnum | InrLedgerScalarFieldEnum[]
  }


  /**
   * UserAccount.CryptoLedgerRel
   */
  export type UserAccount$CryptoLedgerRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    where?: CryptoLedgerWhereInput
    orderBy?: CryptoLedgerOrderByWithRelationInput | CryptoLedgerOrderByWithRelationInput[]
    cursor?: CryptoLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoLedgerScalarFieldEnum | CryptoLedgerScalarFieldEnum[]
  }


  /**
   * UserAccount.TradeLedgerRel
   */
  export type UserAccount$TradeLedgerRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    where?: TradeLedgerWhereInput
    orderBy?: TradeLedgerOrderByWithRelationInput | TradeLedgerOrderByWithRelationInput[]
    cursor?: TradeLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeLedgerScalarFieldEnum | TradeLedgerScalarFieldEnum[]
  }


  /**
   * UserAccount.InrWalletRel
   */
  export type UserAccount$InrWalletRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    where?: InrWalletWhereInput
  }


  /**
   * UserAccount.CryptoWalletRel
   */
  export type UserAccount$CryptoWalletRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    where?: CryptoWalletWhereInput
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    cursor?: CryptoWalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }


  /**
   * UserAccount.InrConvRel
   */
  export type UserAccount$InrConvRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    where?: InrConversionHistoryWhereInput
    orderBy?: InrConversionHistoryOrderByWithRelationInput | InrConversionHistoryOrderByWithRelationInput[]
    cursor?: InrConversionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InrConversionHistoryScalarFieldEnum | InrConversionHistoryScalarFieldEnum[]
  }


  /**
   * UserAccount without action
   */
  export type UserAccountDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    kycId: number | null
    bankDetailsId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    kycId: number | null
    bankDetailsId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    userType: $Enums.UserType | null
    signupType: $Enums.SignUpType | null
    role: $Enums.Role | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    phoneCountryCode: string | null
    initVector: string | null
    password: string | null
    passwordUpdatedAt: Date | null
    kycStatus: $Enums.UserKycStatus | null
    kycId: number | null
    bankVerificationStatus: $Enums.BankVerificationStatus | null
    bankDetailsId: number | null
    isActive: boolean | null
    inrDepositEnabled: boolean | null
    cryptoDepositEnabled: boolean | null
    inrWithdrawEnabled: boolean | null
    cryptoWithdrawEnabled: boolean | null
    tradeEnabled: boolean | null
    emailVerified: Date | null
    phoneVerified: Date | null
    lastLogin: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    userType: $Enums.UserType | null
    signupType: $Enums.SignUpType | null
    role: $Enums.Role | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    phoneCountryCode: string | null
    initVector: string | null
    password: string | null
    passwordUpdatedAt: Date | null
    kycStatus: $Enums.UserKycStatus | null
    kycId: number | null
    bankVerificationStatus: $Enums.BankVerificationStatus | null
    bankDetailsId: number | null
    isActive: boolean | null
    inrDepositEnabled: boolean | null
    cryptoDepositEnabled: boolean | null
    inrWithdrawEnabled: boolean | null
    cryptoWithdrawEnabled: boolean | null
    tradeEnabled: boolean | null
    emailVerified: Date | null
    phoneVerified: Date | null
    lastLogin: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userType: number
    signupType: number
    role: number
    email: number
    phone: number
    firstName: number
    lastName: number
    phoneCountryCode: number
    initVector: number
    password: number
    passwordUpdatedAt: number
    kycStatus: number
    kycId: number
    bankVerificationStatus: number
    bankDetailsId: number
    isActive: number
    inrDepositEnabled: number
    cryptoDepositEnabled: number
    inrWithdrawEnabled: number
    cryptoWithdrawEnabled: number
    tradeEnabled: number
    emailVerified: number
    phoneVerified: number
    lastLogin: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    kycId?: true
    bankDetailsId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    kycId?: true
    bankDetailsId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    userType?: true
    signupType?: true
    role?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    phoneCountryCode?: true
    initVector?: true
    password?: true
    passwordUpdatedAt?: true
    kycStatus?: true
    kycId?: true
    bankVerificationStatus?: true
    bankDetailsId?: true
    isActive?: true
    inrDepositEnabled?: true
    cryptoDepositEnabled?: true
    inrWithdrawEnabled?: true
    cryptoWithdrawEnabled?: true
    tradeEnabled?: true
    emailVerified?: true
    phoneVerified?: true
    lastLogin?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userType?: true
    signupType?: true
    role?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    phoneCountryCode?: true
    initVector?: true
    password?: true
    passwordUpdatedAt?: true
    kycStatus?: true
    kycId?: true
    bankVerificationStatus?: true
    bankDetailsId?: true
    isActive?: true
    inrDepositEnabled?: true
    cryptoDepositEnabled?: true
    inrWithdrawEnabled?: true
    cryptoWithdrawEnabled?: true
    tradeEnabled?: true
    emailVerified?: true
    phoneVerified?: true
    lastLogin?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userType?: true
    signupType?: true
    role?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    phoneCountryCode?: true
    initVector?: true
    password?: true
    passwordUpdatedAt?: true
    kycStatus?: true
    kycId?: true
    bankVerificationStatus?: true
    bankDetailsId?: true
    isActive?: true
    inrDepositEnabled?: true
    cryptoDepositEnabled?: true
    inrWithdrawEnabled?: true
    cryptoWithdrawEnabled?: true
    tradeEnabled?: true
    emailVerified?: true
    phoneVerified?: true
    lastLogin?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    userType: $Enums.UserType
    signupType: $Enums.SignUpType | null
    role: $Enums.Role
    email: string
    phone: string | null
    firstName: string | null
    lastName: string | null
    phoneCountryCode: string
    initVector: string | null
    password: string | null
    passwordUpdatedAt: Date | null
    kycStatus: $Enums.UserKycStatus
    kycId: number | null
    bankVerificationStatus: $Enums.BankVerificationStatus
    bankDetailsId: number | null
    isActive: boolean
    inrDepositEnabled: boolean
    cryptoDepositEnabled: boolean
    inrWithdrawEnabled: boolean
    cryptoWithdrawEnabled: boolean
    tradeEnabled: boolean
    emailVerified: Date | null
    phoneVerified: Date | null
    lastLogin: Date | null
    createdAt: Date
    createdBy: number | null
    updatedAt: Date
    updatedBy: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userType?: boolean
    signupType?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneCountryCode?: boolean
    initVector?: boolean
    password?: boolean
    passwordUpdatedAt?: boolean
    kycStatus?: boolean
    kycId?: boolean
    bankVerificationStatus?: boolean
    bankDetailsId?: boolean
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    UserKycRel?: boolean | User$UserKycRelArgs<ExtArgs>
    BankDetailRel?: boolean | User$BankDetailRelArgs<ExtArgs>
    UserBankDetailsRel?: boolean | User$UserBankDetailsRelArgs<ExtArgs>
    FiatPaymentsRel?: boolean | User$FiatPaymentsRelArgs<ExtArgs>
    UserAccountRel?: boolean | User$UserAccountRelArgs<ExtArgs>
    TwoFARel?: boolean | User$TwoFARelArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    userType?: boolean
    signupType?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneCountryCode?: boolean
    initVector?: boolean
    password?: boolean
    passwordUpdatedAt?: boolean
    kycStatus?: boolean
    kycId?: boolean
    bankVerificationStatus?: boolean
    bankDetailsId?: boolean
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    UserKycRel?: boolean | User$UserKycRelArgs<ExtArgs>
    BankDetailRel?: boolean | User$BankDetailRelArgs<ExtArgs>
    UserBankDetailsRel?: boolean | User$UserBankDetailsRelArgs<ExtArgs>
    FiatPaymentsRel?: boolean | User$FiatPaymentsRelArgs<ExtArgs>
    UserAccountRel?: boolean | User$UserAccountRelArgs<ExtArgs>
    TwoFARel?: boolean | User$TwoFARelArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      UserKycRel: Prisma.$UserKycPayload<ExtArgs> | null
      BankDetailRel: Prisma.$UserBankDetailsPayload<ExtArgs> | null
      UserBankDetailsRel: Prisma.$UserBankDetailsPayload<ExtArgs>[]
      FiatPaymentsRel: Prisma.$FiatPaymentsPayload<ExtArgs>[]
      UserAccountRel: Prisma.$UserAccountPayload<ExtArgs> | null
      TwoFARel: Prisma.$TwoFAPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      userType: $Enums.UserType
      signupType: $Enums.SignUpType | null
      role: $Enums.Role
      email: string
      phone: string | null
      firstName: string | null
      lastName: string | null
      phoneCountryCode: string
      initVector: string | null
      password: string | null
      passwordUpdatedAt: Date | null
      kycStatus: $Enums.UserKycStatus
      kycId: number | null
      bankVerificationStatus: $Enums.BankVerificationStatus
      bankDetailsId: number | null
      isActive: boolean
      inrDepositEnabled: boolean
      cryptoDepositEnabled: boolean
      inrWithdrawEnabled: boolean
      cryptoWithdrawEnabled: boolean
      tradeEnabled: boolean
      emailVerified: Date | null
      phoneVerified: Date | null
      lastLogin: Date | null
      createdAt: Date
      createdBy: number | null
      updatedAt: Date
      updatedBy: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    UserKycRel<T extends User$UserKycRelArgs<ExtArgs> = {}>(args?: Subset<T, User$UserKycRelArgs<ExtArgs>>): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    BankDetailRel<T extends User$BankDetailRelArgs<ExtArgs> = {}>(args?: Subset<T, User$BankDetailRelArgs<ExtArgs>>): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    UserBankDetailsRel<T extends User$UserBankDetailsRelArgs<ExtArgs> = {}>(args?: Subset<T, User$UserBankDetailsRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findMany'> | Null>;

    FiatPaymentsRel<T extends User$FiatPaymentsRelArgs<ExtArgs> = {}>(args?: Subset<T, User$FiatPaymentsRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    UserAccountRel<T extends User$UserAccountRelArgs<ExtArgs> = {}>(args?: Subset<T, User$UserAccountRelArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    TwoFARel<T extends User$TwoFARelArgs<ExtArgs> = {}>(args?: Subset<T, User$TwoFARelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly userType: FieldRef<"User", 'UserType'>
    readonly signupType: FieldRef<"User", 'SignUpType'>
    readonly role: FieldRef<"User", 'Role'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phoneCountryCode: FieldRef<"User", 'String'>
    readonly initVector: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly passwordUpdatedAt: FieldRef<"User", 'DateTime'>
    readonly kycStatus: FieldRef<"User", 'UserKycStatus'>
    readonly kycId: FieldRef<"User", 'Int'>
    readonly bankVerificationStatus: FieldRef<"User", 'BankVerificationStatus'>
    readonly bankDetailsId: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly inrDepositEnabled: FieldRef<"User", 'Boolean'>
    readonly cryptoDepositEnabled: FieldRef<"User", 'Boolean'>
    readonly inrWithdrawEnabled: FieldRef<"User", 'Boolean'>
    readonly cryptoWithdrawEnabled: FieldRef<"User", 'Boolean'>
    readonly tradeEnabled: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly phoneVerified: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly createdBy: FieldRef<"User", 'Int'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly updatedBy: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.UserKycRel
   */
  export type User$UserKycRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    where?: UserKycWhereInput
  }


  /**
   * User.BankDetailRel
   */
  export type User$BankDetailRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    where?: UserBankDetailsWhereInput
  }


  /**
   * User.UserBankDetailsRel
   */
  export type User$UserBankDetailsRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    where?: UserBankDetailsWhereInput
    orderBy?: UserBankDetailsOrderByWithRelationInput | UserBankDetailsOrderByWithRelationInput[]
    cursor?: UserBankDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBankDetailsScalarFieldEnum | UserBankDetailsScalarFieldEnum[]
  }


  /**
   * User.FiatPaymentsRel
   */
  export type User$FiatPaymentsRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    where?: FiatPaymentsWhereInput
    orderBy?: FiatPaymentsOrderByWithRelationInput | FiatPaymentsOrderByWithRelationInput[]
    cursor?: FiatPaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FiatPaymentsScalarFieldEnum | FiatPaymentsScalarFieldEnum[]
  }


  /**
   * User.UserAccountRel
   */
  export type User$UserAccountRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
  }


  /**
   * User.TwoFARel
   */
  export type User$TwoFARelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    where?: TwoFAWhereInput
    orderBy?: TwoFAOrderByWithRelationInput | TwoFAOrderByWithRelationInput[]
    cursor?: TwoFAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwoFAScalarFieldEnum | TwoFAScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model DepositWithdrawLimits
   */

  export type AggregateDepositWithdrawLimits = {
    _count: DepositWithdrawLimitsCountAggregateOutputType | null
    _avg: DepositWithdrawLimitsAvgAggregateOutputType | null
    _sum: DepositWithdrawLimitsSumAggregateOutputType | null
    _min: DepositWithdrawLimitsMinAggregateOutputType | null
    _max: DepositWithdrawLimitsMaxAggregateOutputType | null
  }

  export type DepositWithdrawLimitsAvgAggregateOutputType = {
    id: number | null
    fiatDepositLimit: number | null
    fiatWithdrawLimit: number | null
    cryptoDepositLimit: number | null
    cryptoWithdrawLimit: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type DepositWithdrawLimitsSumAggregateOutputType = {
    id: number | null
    fiatDepositLimit: number | null
    fiatWithdrawLimit: number | null
    cryptoDepositLimit: number | null
    cryptoWithdrawLimit: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type DepositWithdrawLimitsMinAggregateOutputType = {
    id: number | null
    userType: $Enums.UserType | null
    fiatDepositLimit: number | null
    fiatWithdrawLimit: number | null
    cryptoDepositLimit: number | null
    cryptoWithdrawLimit: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type DepositWithdrawLimitsMaxAggregateOutputType = {
    id: number | null
    userType: $Enums.UserType | null
    fiatDepositLimit: number | null
    fiatWithdrawLimit: number | null
    cryptoDepositLimit: number | null
    cryptoWithdrawLimit: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type DepositWithdrawLimitsCountAggregateOutputType = {
    id: number
    userType: number
    fiatDepositLimit: number
    fiatWithdrawLimit: number
    cryptoDepositLimit: number
    cryptoWithdrawLimit: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type DepositWithdrawLimitsAvgAggregateInputType = {
    id?: true
    fiatDepositLimit?: true
    fiatWithdrawLimit?: true
    cryptoDepositLimit?: true
    cryptoWithdrawLimit?: true
    createdBy?: true
    updatedBy?: true
  }

  export type DepositWithdrawLimitsSumAggregateInputType = {
    id?: true
    fiatDepositLimit?: true
    fiatWithdrawLimit?: true
    cryptoDepositLimit?: true
    cryptoWithdrawLimit?: true
    createdBy?: true
    updatedBy?: true
  }

  export type DepositWithdrawLimitsMinAggregateInputType = {
    id?: true
    userType?: true
    fiatDepositLimit?: true
    fiatWithdrawLimit?: true
    cryptoDepositLimit?: true
    cryptoWithdrawLimit?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type DepositWithdrawLimitsMaxAggregateInputType = {
    id?: true
    userType?: true
    fiatDepositLimit?: true
    fiatWithdrawLimit?: true
    cryptoDepositLimit?: true
    cryptoWithdrawLimit?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type DepositWithdrawLimitsCountAggregateInputType = {
    id?: true
    userType?: true
    fiatDepositLimit?: true
    fiatWithdrawLimit?: true
    cryptoDepositLimit?: true
    cryptoWithdrawLimit?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type DepositWithdrawLimitsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepositWithdrawLimits to aggregate.
     */
    where?: DepositWithdrawLimitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepositWithdrawLimits to fetch.
     */
    orderBy?: DepositWithdrawLimitsOrderByWithRelationInput | DepositWithdrawLimitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepositWithdrawLimitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepositWithdrawLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepositWithdrawLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepositWithdrawLimits
    **/
    _count?: true | DepositWithdrawLimitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositWithdrawLimitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositWithdrawLimitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositWithdrawLimitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositWithdrawLimitsMaxAggregateInputType
  }

  export type GetDepositWithdrawLimitsAggregateType<T extends DepositWithdrawLimitsAggregateArgs> = {
        [P in keyof T & keyof AggregateDepositWithdrawLimits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepositWithdrawLimits[P]>
      : GetScalarType<T[P], AggregateDepositWithdrawLimits[P]>
  }




  export type DepositWithdrawLimitsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DepositWithdrawLimitsWhereInput
    orderBy?: DepositWithdrawLimitsOrderByWithAggregationInput | DepositWithdrawLimitsOrderByWithAggregationInput[]
    by: DepositWithdrawLimitsScalarFieldEnum[] | DepositWithdrawLimitsScalarFieldEnum
    having?: DepositWithdrawLimitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositWithdrawLimitsCountAggregateInputType | true
    _avg?: DepositWithdrawLimitsAvgAggregateInputType
    _sum?: DepositWithdrawLimitsSumAggregateInputType
    _min?: DepositWithdrawLimitsMinAggregateInputType
    _max?: DepositWithdrawLimitsMaxAggregateInputType
  }

  export type DepositWithdrawLimitsGroupByOutputType = {
    id: number
    userType: $Enums.UserType
    fiatDepositLimit: number
    fiatWithdrawLimit: number
    cryptoDepositLimit: number | null
    cryptoWithdrawLimit: number | null
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number | null
    _count: DepositWithdrawLimitsCountAggregateOutputType | null
    _avg: DepositWithdrawLimitsAvgAggregateOutputType | null
    _sum: DepositWithdrawLimitsSumAggregateOutputType | null
    _min: DepositWithdrawLimitsMinAggregateOutputType | null
    _max: DepositWithdrawLimitsMaxAggregateOutputType | null
  }

  type GetDepositWithdrawLimitsGroupByPayload<T extends DepositWithdrawLimitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositWithdrawLimitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositWithdrawLimitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositWithdrawLimitsGroupByOutputType[P]>
            : GetScalarType<T[P], DepositWithdrawLimitsGroupByOutputType[P]>
        }
      >
    >


  export type DepositWithdrawLimitsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userType?: boolean
    fiatDepositLimit?: boolean
    fiatWithdrawLimit?: boolean
    cryptoDepositLimit?: boolean
    cryptoWithdrawLimit?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["depositWithdrawLimits"]>

  export type DepositWithdrawLimitsSelectScalar = {
    id?: boolean
    userType?: boolean
    fiatDepositLimit?: boolean
    fiatWithdrawLimit?: boolean
    cryptoDepositLimit?: boolean
    cryptoWithdrawLimit?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $DepositWithdrawLimitsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DepositWithdrawLimits"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      userType: $Enums.UserType
      fiatDepositLimit: number
      fiatWithdrawLimit: number
      cryptoDepositLimit: number | null
      cryptoWithdrawLimit: number | null
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number | null
    }, ExtArgs["result"]["depositWithdrawLimits"]>
    composites: {}
  }


  type DepositWithdrawLimitsGetPayload<S extends boolean | null | undefined | DepositWithdrawLimitsDefaultArgs> = $Result.GetResult<Prisma.$DepositWithdrawLimitsPayload, S>

  type DepositWithdrawLimitsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DepositWithdrawLimitsFindManyArgs, 'select' | 'include'> & {
      select?: DepositWithdrawLimitsCountAggregateInputType | true
    }

  export interface DepositWithdrawLimitsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepositWithdrawLimits'], meta: { name: 'DepositWithdrawLimits' } }
    /**
     * Find zero or one DepositWithdrawLimits that matches the filter.
     * @param {DepositWithdrawLimitsFindUniqueArgs} args - Arguments to find a DepositWithdrawLimits
     * @example
     * // Get one DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DepositWithdrawLimitsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DepositWithdrawLimitsFindUniqueArgs<ExtArgs>>
    ): Prisma__DepositWithdrawLimitsClient<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DepositWithdrawLimits that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DepositWithdrawLimitsFindUniqueOrThrowArgs} args - Arguments to find a DepositWithdrawLimits
     * @example
     * // Get one DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DepositWithdrawLimitsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DepositWithdrawLimitsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DepositWithdrawLimitsClient<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DepositWithdrawLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositWithdrawLimitsFindFirstArgs} args - Arguments to find a DepositWithdrawLimits
     * @example
     * // Get one DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DepositWithdrawLimitsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DepositWithdrawLimitsFindFirstArgs<ExtArgs>>
    ): Prisma__DepositWithdrawLimitsClient<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DepositWithdrawLimits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositWithdrawLimitsFindFirstOrThrowArgs} args - Arguments to find a DepositWithdrawLimits
     * @example
     * // Get one DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DepositWithdrawLimitsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DepositWithdrawLimitsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DepositWithdrawLimitsClient<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DepositWithdrawLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositWithdrawLimitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.findMany()
     * 
     * // Get first 10 DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositWithdrawLimitsWithIdOnly = await prisma.depositWithdrawLimits.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DepositWithdrawLimitsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepositWithdrawLimitsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DepositWithdrawLimits.
     * @param {DepositWithdrawLimitsCreateArgs} args - Arguments to create a DepositWithdrawLimits.
     * @example
     * // Create one DepositWithdrawLimits
     * const DepositWithdrawLimits = await prisma.depositWithdrawLimits.create({
     *   data: {
     *     // ... data to create a DepositWithdrawLimits
     *   }
     * })
     * 
    **/
    create<T extends DepositWithdrawLimitsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DepositWithdrawLimitsCreateArgs<ExtArgs>>
    ): Prisma__DepositWithdrawLimitsClient<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DepositWithdrawLimits.
     *     @param {DepositWithdrawLimitsCreateManyArgs} args - Arguments to create many DepositWithdrawLimits.
     *     @example
     *     // Create many DepositWithdrawLimits
     *     const depositWithdrawLimits = await prisma.depositWithdrawLimits.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DepositWithdrawLimitsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepositWithdrawLimitsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DepositWithdrawLimits.
     * @param {DepositWithdrawLimitsDeleteArgs} args - Arguments to delete one DepositWithdrawLimits.
     * @example
     * // Delete one DepositWithdrawLimits
     * const DepositWithdrawLimits = await prisma.depositWithdrawLimits.delete({
     *   where: {
     *     // ... filter to delete one DepositWithdrawLimits
     *   }
     * })
     * 
    **/
    delete<T extends DepositWithdrawLimitsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DepositWithdrawLimitsDeleteArgs<ExtArgs>>
    ): Prisma__DepositWithdrawLimitsClient<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DepositWithdrawLimits.
     * @param {DepositWithdrawLimitsUpdateArgs} args - Arguments to update one DepositWithdrawLimits.
     * @example
     * // Update one DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DepositWithdrawLimitsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DepositWithdrawLimitsUpdateArgs<ExtArgs>>
    ): Prisma__DepositWithdrawLimitsClient<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DepositWithdrawLimits.
     * @param {DepositWithdrawLimitsDeleteManyArgs} args - Arguments to filter DepositWithdrawLimits to delete.
     * @example
     * // Delete a few DepositWithdrawLimits
     * const { count } = await prisma.depositWithdrawLimits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DepositWithdrawLimitsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepositWithdrawLimitsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepositWithdrawLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositWithdrawLimitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DepositWithdrawLimitsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DepositWithdrawLimitsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepositWithdrawLimits.
     * @param {DepositWithdrawLimitsUpsertArgs} args - Arguments to update or create a DepositWithdrawLimits.
     * @example
     * // Update or create a DepositWithdrawLimits
     * const depositWithdrawLimits = await prisma.depositWithdrawLimits.upsert({
     *   create: {
     *     // ... data to create a DepositWithdrawLimits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepositWithdrawLimits we want to update
     *   }
     * })
    **/
    upsert<T extends DepositWithdrawLimitsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DepositWithdrawLimitsUpsertArgs<ExtArgs>>
    ): Prisma__DepositWithdrawLimitsClient<$Result.GetResult<Prisma.$DepositWithdrawLimitsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DepositWithdrawLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositWithdrawLimitsCountArgs} args - Arguments to filter DepositWithdrawLimits to count.
     * @example
     * // Count the number of DepositWithdrawLimits
     * const count = await prisma.depositWithdrawLimits.count({
     *   where: {
     *     // ... the filter for the DepositWithdrawLimits we want to count
     *   }
     * })
    **/
    count<T extends DepositWithdrawLimitsCountArgs>(
      args?: Subset<T, DepositWithdrawLimitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositWithdrawLimitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepositWithdrawLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositWithdrawLimitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositWithdrawLimitsAggregateArgs>(args: Subset<T, DepositWithdrawLimitsAggregateArgs>): Prisma.PrismaPromise<GetDepositWithdrawLimitsAggregateType<T>>

    /**
     * Group by DepositWithdrawLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositWithdrawLimitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositWithdrawLimitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositWithdrawLimitsGroupByArgs['orderBy'] }
        : { orderBy?: DepositWithdrawLimitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositWithdrawLimitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositWithdrawLimitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepositWithdrawLimits model
   */
  readonly fields: DepositWithdrawLimitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepositWithdrawLimits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepositWithdrawLimitsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DepositWithdrawLimits model
   */ 
  interface DepositWithdrawLimitsFieldRefs {
    readonly id: FieldRef<"DepositWithdrawLimits", 'Int'>
    readonly userType: FieldRef<"DepositWithdrawLimits", 'UserType'>
    readonly fiatDepositLimit: FieldRef<"DepositWithdrawLimits", 'Float'>
    readonly fiatWithdrawLimit: FieldRef<"DepositWithdrawLimits", 'Float'>
    readonly cryptoDepositLimit: FieldRef<"DepositWithdrawLimits", 'Float'>
    readonly cryptoWithdrawLimit: FieldRef<"DepositWithdrawLimits", 'Float'>
    readonly createdAt: FieldRef<"DepositWithdrawLimits", 'DateTime'>
    readonly createdBy: FieldRef<"DepositWithdrawLimits", 'Int'>
    readonly updatedAt: FieldRef<"DepositWithdrawLimits", 'DateTime'>
    readonly updatedBy: FieldRef<"DepositWithdrawLimits", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * DepositWithdrawLimits findUnique
   */
  export type DepositWithdrawLimitsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * Filter, which DepositWithdrawLimits to fetch.
     */
    where: DepositWithdrawLimitsWhereUniqueInput
  }


  /**
   * DepositWithdrawLimits findUniqueOrThrow
   */
  export type DepositWithdrawLimitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * Filter, which DepositWithdrawLimits to fetch.
     */
    where: DepositWithdrawLimitsWhereUniqueInput
  }


  /**
   * DepositWithdrawLimits findFirst
   */
  export type DepositWithdrawLimitsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * Filter, which DepositWithdrawLimits to fetch.
     */
    where?: DepositWithdrawLimitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepositWithdrawLimits to fetch.
     */
    orderBy?: DepositWithdrawLimitsOrderByWithRelationInput | DepositWithdrawLimitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepositWithdrawLimits.
     */
    cursor?: DepositWithdrawLimitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepositWithdrawLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepositWithdrawLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepositWithdrawLimits.
     */
    distinct?: DepositWithdrawLimitsScalarFieldEnum | DepositWithdrawLimitsScalarFieldEnum[]
  }


  /**
   * DepositWithdrawLimits findFirstOrThrow
   */
  export type DepositWithdrawLimitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * Filter, which DepositWithdrawLimits to fetch.
     */
    where?: DepositWithdrawLimitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepositWithdrawLimits to fetch.
     */
    orderBy?: DepositWithdrawLimitsOrderByWithRelationInput | DepositWithdrawLimitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepositWithdrawLimits.
     */
    cursor?: DepositWithdrawLimitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepositWithdrawLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepositWithdrawLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepositWithdrawLimits.
     */
    distinct?: DepositWithdrawLimitsScalarFieldEnum | DepositWithdrawLimitsScalarFieldEnum[]
  }


  /**
   * DepositWithdrawLimits findMany
   */
  export type DepositWithdrawLimitsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * Filter, which DepositWithdrawLimits to fetch.
     */
    where?: DepositWithdrawLimitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepositWithdrawLimits to fetch.
     */
    orderBy?: DepositWithdrawLimitsOrderByWithRelationInput | DepositWithdrawLimitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepositWithdrawLimits.
     */
    cursor?: DepositWithdrawLimitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepositWithdrawLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepositWithdrawLimits.
     */
    skip?: number
    distinct?: DepositWithdrawLimitsScalarFieldEnum | DepositWithdrawLimitsScalarFieldEnum[]
  }


  /**
   * DepositWithdrawLimits create
   */
  export type DepositWithdrawLimitsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * The data needed to create a DepositWithdrawLimits.
     */
    data: XOR<DepositWithdrawLimitsCreateInput, DepositWithdrawLimitsUncheckedCreateInput>
  }


  /**
   * DepositWithdrawLimits createMany
   */
  export type DepositWithdrawLimitsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepositWithdrawLimits.
     */
    data: DepositWithdrawLimitsCreateManyInput | DepositWithdrawLimitsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DepositWithdrawLimits update
   */
  export type DepositWithdrawLimitsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * The data needed to update a DepositWithdrawLimits.
     */
    data: XOR<DepositWithdrawLimitsUpdateInput, DepositWithdrawLimitsUncheckedUpdateInput>
    /**
     * Choose, which DepositWithdrawLimits to update.
     */
    where: DepositWithdrawLimitsWhereUniqueInput
  }


  /**
   * DepositWithdrawLimits updateMany
   */
  export type DepositWithdrawLimitsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepositWithdrawLimits.
     */
    data: XOR<DepositWithdrawLimitsUpdateManyMutationInput, DepositWithdrawLimitsUncheckedUpdateManyInput>
    /**
     * Filter which DepositWithdrawLimits to update
     */
    where?: DepositWithdrawLimitsWhereInput
  }


  /**
   * DepositWithdrawLimits upsert
   */
  export type DepositWithdrawLimitsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * The filter to search for the DepositWithdrawLimits to update in case it exists.
     */
    where: DepositWithdrawLimitsWhereUniqueInput
    /**
     * In case the DepositWithdrawLimits found by the `where` argument doesn't exist, create a new DepositWithdrawLimits with this data.
     */
    create: XOR<DepositWithdrawLimitsCreateInput, DepositWithdrawLimitsUncheckedCreateInput>
    /**
     * In case the DepositWithdrawLimits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepositWithdrawLimitsUpdateInput, DepositWithdrawLimitsUncheckedUpdateInput>
  }


  /**
   * DepositWithdrawLimits delete
   */
  export type DepositWithdrawLimitsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
    /**
     * Filter which DepositWithdrawLimits to delete.
     */
    where: DepositWithdrawLimitsWhereUniqueInput
  }


  /**
   * DepositWithdrawLimits deleteMany
   */
  export type DepositWithdrawLimitsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepositWithdrawLimits to delete
     */
    where?: DepositWithdrawLimitsWhereInput
  }


  /**
   * DepositWithdrawLimits without action
   */
  export type DepositWithdrawLimitsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositWithdrawLimits
     */
    select?: DepositWithdrawLimitsSelect<ExtArgs> | null
  }



  /**
   * Model TwoFA
   */

  export type AggregateTwoFA = {
    _count: TwoFACountAggregateOutputType | null
    _avg: TwoFAAvgAggregateOutputType | null
    _sum: TwoFASumAggregateOutputType | null
    _min: TwoFAMinAggregateOutputType | null
    _max: TwoFAMaxAggregateOutputType | null
  }

  export type TwoFAAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    expiryTime: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type TwoFASumAggregateOutputType = {
    id: number | null
    userId: number | null
    expiryTime: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type TwoFAMinAggregateOutputType = {
    id: number | null
    userId: number | null
    email: string | null
    phone: string | null
    emailVerified: Date | null
    phoneVerified: Date | null
    status: $Enums.TwoFAStatus | null
    reason: $Enums.Reason | null
    expiryTime: number | null
    mobileVerifiedAtleastOnce: boolean | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type TwoFAMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    email: string | null
    phone: string | null
    emailVerified: Date | null
    phoneVerified: Date | null
    status: $Enums.TwoFAStatus | null
    reason: $Enums.Reason | null
    expiryTime: number | null
    mobileVerifiedAtleastOnce: boolean | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type TwoFACountAggregateOutputType = {
    id: number
    userId: number
    email: number
    phone: number
    emailVerified: number
    phoneVerified: number
    status: number
    reason: number
    expiryTime: number
    mobileVerifiedAtleastOnce: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type TwoFAAvgAggregateInputType = {
    id?: true
    userId?: true
    expiryTime?: true
    createdBy?: true
    updatedBy?: true
  }

  export type TwoFASumAggregateInputType = {
    id?: true
    userId?: true
    expiryTime?: true
    createdBy?: true
    updatedBy?: true
  }

  export type TwoFAMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    emailVerified?: true
    phoneVerified?: true
    status?: true
    reason?: true
    expiryTime?: true
    mobileVerifiedAtleastOnce?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TwoFAMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    emailVerified?: true
    phoneVerified?: true
    status?: true
    reason?: true
    expiryTime?: true
    mobileVerifiedAtleastOnce?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TwoFACountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    emailVerified?: true
    phoneVerified?: true
    status?: true
    reason?: true
    expiryTime?: true
    mobileVerifiedAtleastOnce?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type TwoFAAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFA to aggregate.
     */
    where?: TwoFAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFAS to fetch.
     */
    orderBy?: TwoFAOrderByWithRelationInput | TwoFAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFAS
    **/
    _count?: true | TwoFACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwoFAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwoFASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFAMaxAggregateInputType
  }

  export type GetTwoFAAggregateType<T extends TwoFAAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFA[P]>
      : GetScalarType<T[P], AggregateTwoFA[P]>
  }




  export type TwoFAGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TwoFAWhereInput
    orderBy?: TwoFAOrderByWithAggregationInput | TwoFAOrderByWithAggregationInput[]
    by: TwoFAScalarFieldEnum[] | TwoFAScalarFieldEnum
    having?: TwoFAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFACountAggregateInputType | true
    _avg?: TwoFAAvgAggregateInputType
    _sum?: TwoFASumAggregateInputType
    _min?: TwoFAMinAggregateInputType
    _max?: TwoFAMaxAggregateInputType
  }

  export type TwoFAGroupByOutputType = {
    id: number
    userId: number
    email: string
    phone: string | null
    emailVerified: Date | null
    phoneVerified: Date | null
    status: $Enums.TwoFAStatus
    reason: $Enums.Reason
    expiryTime: number
    mobileVerifiedAtleastOnce: boolean
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number | null
    _count: TwoFACountAggregateOutputType | null
    _avg: TwoFAAvgAggregateOutputType | null
    _sum: TwoFASumAggregateOutputType | null
    _min: TwoFAMinAggregateOutputType | null
    _max: TwoFAMaxAggregateOutputType | null
  }

  type GetTwoFAGroupByPayload<T extends TwoFAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFAGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFAGroupByOutputType[P]>
        }
      >
    >


  export type TwoFASelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    status?: boolean
    reason?: boolean
    expiryTime?: boolean
    mobileVerifiedAtleastOnce?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFA"]>

  export type TwoFASelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    status?: boolean
    reason?: boolean
    expiryTime?: boolean
    mobileVerifiedAtleastOnce?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type TwoFAInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $TwoFAPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "TwoFA"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      email: string
      phone: string | null
      emailVerified: Date | null
      phoneVerified: Date | null
      status: $Enums.TwoFAStatus
      reason: $Enums.Reason
      expiryTime: number
      mobileVerifiedAtleastOnce: boolean
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number | null
    }, ExtArgs["result"]["twoFA"]>
    composites: {}
  }


  type TwoFAGetPayload<S extends boolean | null | undefined | TwoFADefaultArgs> = $Result.GetResult<Prisma.$TwoFAPayload, S>

  type TwoFACountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TwoFAFindManyArgs, 'select' | 'include'> & {
      select?: TwoFACountAggregateInputType | true
    }

  export interface TwoFADelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFA'], meta: { name: 'TwoFA' } }
    /**
     * Find zero or one TwoFA that matches the filter.
     * @param {TwoFAFindUniqueArgs} args - Arguments to find a TwoFA
     * @example
     * // Get one TwoFA
     * const twoFA = await prisma.twoFA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwoFAFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFAFindUniqueArgs<ExtArgs>>
    ): Prisma__TwoFAClient<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TwoFA that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwoFAFindUniqueOrThrowArgs} args - Arguments to find a TwoFA
     * @example
     * // Get one TwoFA
     * const twoFA = await prisma.twoFA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwoFAFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFAFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TwoFAClient<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TwoFA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFAFindFirstArgs} args - Arguments to find a TwoFA
     * @example
     * // Get one TwoFA
     * const twoFA = await prisma.twoFA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwoFAFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFAFindFirstArgs<ExtArgs>>
    ): Prisma__TwoFAClient<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TwoFA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFAFindFirstOrThrowArgs} args - Arguments to find a TwoFA
     * @example
     * // Get one TwoFA
     * const twoFA = await prisma.twoFA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwoFAFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFAFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TwoFAClient<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TwoFAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFAFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFAS
     * const twoFAS = await prisma.twoFA.findMany()
     * 
     * // Get first 10 TwoFAS
     * const twoFAS = await prisma.twoFA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFAWithIdOnly = await prisma.twoFA.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwoFAFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFAFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TwoFA.
     * @param {TwoFACreateArgs} args - Arguments to create a TwoFA.
     * @example
     * // Create one TwoFA
     * const TwoFA = await prisma.twoFA.create({
     *   data: {
     *     // ... data to create a TwoFA
     *   }
     * })
     * 
    **/
    create<T extends TwoFACreateArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFACreateArgs<ExtArgs>>
    ): Prisma__TwoFAClient<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TwoFAS.
     *     @param {TwoFACreateManyArgs} args - Arguments to create many TwoFAS.
     *     @example
     *     // Create many TwoFAS
     *     const twoFA = await prisma.twoFA.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwoFACreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFACreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwoFA.
     * @param {TwoFADeleteArgs} args - Arguments to delete one TwoFA.
     * @example
     * // Delete one TwoFA
     * const TwoFA = await prisma.twoFA.delete({
     *   where: {
     *     // ... filter to delete one TwoFA
     *   }
     * })
     * 
    **/
    delete<T extends TwoFADeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFADeleteArgs<ExtArgs>>
    ): Prisma__TwoFAClient<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TwoFA.
     * @param {TwoFAUpdateArgs} args - Arguments to update one TwoFA.
     * @example
     * // Update one TwoFA
     * const twoFA = await prisma.twoFA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwoFAUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFAUpdateArgs<ExtArgs>>
    ): Prisma__TwoFAClient<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TwoFAS.
     * @param {TwoFADeleteManyArgs} args - Arguments to filter TwoFAS to delete.
     * @example
     * // Delete a few TwoFAS
     * const { count } = await prisma.twoFA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwoFADeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFADeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFAS
     * const twoFA = await prisma.twoFA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwoFAUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFAUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFA.
     * @param {TwoFAUpsertArgs} args - Arguments to update or create a TwoFA.
     * @example
     * // Update or create a TwoFA
     * const twoFA = await prisma.twoFA.upsert({
     *   create: {
     *     // ... data to create a TwoFA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFA we want to update
     *   }
     * })
    **/
    upsert<T extends TwoFAUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFAUpsertArgs<ExtArgs>>
    ): Prisma__TwoFAClient<$Result.GetResult<Prisma.$TwoFAPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TwoFAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFACountArgs} args - Arguments to filter TwoFAS to count.
     * @example
     * // Count the number of TwoFAS
     * const count = await prisma.twoFA.count({
     *   where: {
     *     // ... the filter for the TwoFAS we want to count
     *   }
     * })
    **/
    count<T extends TwoFACountArgs>(
      args?: Subset<T, TwoFACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFAAggregateArgs>(args: Subset<T, TwoFAAggregateArgs>): Prisma.PrismaPromise<GetTwoFAAggregateType<T>>

    /**
     * Group by TwoFA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFAGroupByArgs['orderBy'] }
        : { orderBy?: TwoFAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFA model
   */
  readonly fields: TwoFAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFAClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TwoFA model
   */ 
  interface TwoFAFieldRefs {
    readonly id: FieldRef<"TwoFA", 'Int'>
    readonly userId: FieldRef<"TwoFA", 'Int'>
    readonly email: FieldRef<"TwoFA", 'String'>
    readonly phone: FieldRef<"TwoFA", 'String'>
    readonly emailVerified: FieldRef<"TwoFA", 'DateTime'>
    readonly phoneVerified: FieldRef<"TwoFA", 'DateTime'>
    readonly status: FieldRef<"TwoFA", 'TwoFAStatus'>
    readonly reason: FieldRef<"TwoFA", 'Reason'>
    readonly expiryTime: FieldRef<"TwoFA", 'Int'>
    readonly mobileVerifiedAtleastOnce: FieldRef<"TwoFA", 'Boolean'>
    readonly createdAt: FieldRef<"TwoFA", 'DateTime'>
    readonly createdBy: FieldRef<"TwoFA", 'Int'>
    readonly updatedAt: FieldRef<"TwoFA", 'DateTime'>
    readonly updatedBy: FieldRef<"TwoFA", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TwoFA findUnique
   */
  export type TwoFAFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * Filter, which TwoFA to fetch.
     */
    where: TwoFAWhereUniqueInput
  }


  /**
   * TwoFA findUniqueOrThrow
   */
  export type TwoFAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * Filter, which TwoFA to fetch.
     */
    where: TwoFAWhereUniqueInput
  }


  /**
   * TwoFA findFirst
   */
  export type TwoFAFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * Filter, which TwoFA to fetch.
     */
    where?: TwoFAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFAS to fetch.
     */
    orderBy?: TwoFAOrderByWithRelationInput | TwoFAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFAS.
     */
    cursor?: TwoFAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFAS.
     */
    distinct?: TwoFAScalarFieldEnum | TwoFAScalarFieldEnum[]
  }


  /**
   * TwoFA findFirstOrThrow
   */
  export type TwoFAFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * Filter, which TwoFA to fetch.
     */
    where?: TwoFAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFAS to fetch.
     */
    orderBy?: TwoFAOrderByWithRelationInput | TwoFAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFAS.
     */
    cursor?: TwoFAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFAS.
     */
    distinct?: TwoFAScalarFieldEnum | TwoFAScalarFieldEnum[]
  }


  /**
   * TwoFA findMany
   */
  export type TwoFAFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * Filter, which TwoFAS to fetch.
     */
    where?: TwoFAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFAS to fetch.
     */
    orderBy?: TwoFAOrderByWithRelationInput | TwoFAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFAS.
     */
    cursor?: TwoFAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFAS.
     */
    skip?: number
    distinct?: TwoFAScalarFieldEnum | TwoFAScalarFieldEnum[]
  }


  /**
   * TwoFA create
   */
  export type TwoFACreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFA.
     */
    data: XOR<TwoFACreateInput, TwoFAUncheckedCreateInput>
  }


  /**
   * TwoFA createMany
   */
  export type TwoFACreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFAS.
     */
    data: TwoFACreateManyInput | TwoFACreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TwoFA update
   */
  export type TwoFAUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFA.
     */
    data: XOR<TwoFAUpdateInput, TwoFAUncheckedUpdateInput>
    /**
     * Choose, which TwoFA to update.
     */
    where: TwoFAWhereUniqueInput
  }


  /**
   * TwoFA updateMany
   */
  export type TwoFAUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFAS.
     */
    data: XOR<TwoFAUpdateManyMutationInput, TwoFAUncheckedUpdateManyInput>
    /**
     * Filter which TwoFAS to update
     */
    where?: TwoFAWhereInput
  }


  /**
   * TwoFA upsert
   */
  export type TwoFAUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFA to update in case it exists.
     */
    where: TwoFAWhereUniqueInput
    /**
     * In case the TwoFA found by the `where` argument doesn't exist, create a new TwoFA with this data.
     */
    create: XOR<TwoFACreateInput, TwoFAUncheckedCreateInput>
    /**
     * In case the TwoFA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFAUpdateInput, TwoFAUncheckedUpdateInput>
  }


  /**
   * TwoFA delete
   */
  export type TwoFADeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
    /**
     * Filter which TwoFA to delete.
     */
    where: TwoFAWhereUniqueInput
  }


  /**
   * TwoFA deleteMany
   */
  export type TwoFADeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFAS to delete
     */
    where?: TwoFAWhereInput
  }


  /**
   * TwoFA without action
   */
  export type TwoFADefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFA
     */
    select?: TwoFASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFAInclude<ExtArgs> | null
  }



  /**
   * Model UserKyc
   */

  export type AggregateUserKyc = {
    _count: UserKycCountAggregateOutputType | null
    _avg: UserKycAvgAggregateOutputType | null
    _sum: UserKycSumAggregateOutputType | null
    _min: UserKycMinAggregateOutputType | null
    _max: UserKycMaxAggregateOutputType | null
  }

  export type UserKycAvgAggregateOutputType = {
    id: number | null
    encryptedUserDataId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserKycSumAggregateOutputType = {
    id: number | null
    encryptedUserDataId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserKycMinAggregateOutputType = {
    id: number | null
    encryptedUserDataId: number | null
    fullName: string | null
    gender: $Enums.Gender | null
    dob: string | null
    address: string | null
    fatherName: string | null
    kycType: $Enums.KycType | null
    kycStatus: $Enums.UserKycStatus | null
    hyperVergeStatus: $Enums.HypervergeStatus | null
    panStatus: $Enums.UserKycStatus | null
    aadharFrontStatus: $Enums.UserKycStatus | null
    aadharBackStatus: $Enums.UserKycStatus | null
    selfieStatus: $Enums.UserKycStatus | null
    aadharPanNameMatchStatus: $Enums.UserKycStatus | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserKycMaxAggregateOutputType = {
    id: number | null
    encryptedUserDataId: number | null
    fullName: string | null
    gender: $Enums.Gender | null
    dob: string | null
    address: string | null
    fatherName: string | null
    kycType: $Enums.KycType | null
    kycStatus: $Enums.UserKycStatus | null
    hyperVergeStatus: $Enums.HypervergeStatus | null
    panStatus: $Enums.UserKycStatus | null
    aadharFrontStatus: $Enums.UserKycStatus | null
    aadharBackStatus: $Enums.UserKycStatus | null
    selfieStatus: $Enums.UserKycStatus | null
    aadharPanNameMatchStatus: $Enums.UserKycStatus | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserKycCountAggregateOutputType = {
    id: number
    encryptedUserDataId: number
    fullName: number
    gender: number
    dob: number
    address: number
    fatherName: number
    kycType: number
    kycStatus: number
    hyperVergeStatus: number
    panStatus: number
    aadharFrontStatus: number
    aadharBackStatus: number
    selfieStatus: number
    aadharPanNameMatchStatus: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserKycAvgAggregateInputType = {
    id?: true
    encryptedUserDataId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserKycSumAggregateInputType = {
    id?: true
    encryptedUserDataId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserKycMinAggregateInputType = {
    id?: true
    encryptedUserDataId?: true
    fullName?: true
    gender?: true
    dob?: true
    address?: true
    fatherName?: true
    kycType?: true
    kycStatus?: true
    hyperVergeStatus?: true
    panStatus?: true
    aadharFrontStatus?: true
    aadharBackStatus?: true
    selfieStatus?: true
    aadharPanNameMatchStatus?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserKycMaxAggregateInputType = {
    id?: true
    encryptedUserDataId?: true
    fullName?: true
    gender?: true
    dob?: true
    address?: true
    fatherName?: true
    kycType?: true
    kycStatus?: true
    hyperVergeStatus?: true
    panStatus?: true
    aadharFrontStatus?: true
    aadharBackStatus?: true
    selfieStatus?: true
    aadharPanNameMatchStatus?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserKycCountAggregateInputType = {
    id?: true
    encryptedUserDataId?: true
    fullName?: true
    gender?: true
    dob?: true
    address?: true
    fatherName?: true
    kycType?: true
    kycStatus?: true
    hyperVergeStatus?: true
    panStatus?: true
    aadharFrontStatus?: true
    aadharBackStatus?: true
    selfieStatus?: true
    aadharPanNameMatchStatus?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserKycAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserKyc to aggregate.
     */
    where?: UserKycWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserKycs to fetch.
     */
    orderBy?: UserKycOrderByWithRelationInput | UserKycOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserKycWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserKycs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserKycs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserKycs
    **/
    _count?: true | UserKycCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserKycAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserKycSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserKycMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserKycMaxAggregateInputType
  }

  export type GetUserKycAggregateType<T extends UserKycAggregateArgs> = {
        [P in keyof T & keyof AggregateUserKyc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserKyc[P]>
      : GetScalarType<T[P], AggregateUserKyc[P]>
  }




  export type UserKycGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserKycWhereInput
    orderBy?: UserKycOrderByWithAggregationInput | UserKycOrderByWithAggregationInput[]
    by: UserKycScalarFieldEnum[] | UserKycScalarFieldEnum
    having?: UserKycScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserKycCountAggregateInputType | true
    _avg?: UserKycAvgAggregateInputType
    _sum?: UserKycSumAggregateInputType
    _min?: UserKycMinAggregateInputType
    _max?: UserKycMaxAggregateInputType
  }

  export type UserKycGroupByOutputType = {
    id: number
    encryptedUserDataId: number | null
    fullName: string | null
    gender: $Enums.Gender | null
    dob: string | null
    address: string | null
    fatherName: string | null
    kycType: $Enums.KycType
    kycStatus: $Enums.UserKycStatus
    hyperVergeStatus: $Enums.HypervergeStatus | null
    panStatus: $Enums.UserKycStatus
    aadharFrontStatus: $Enums.UserKycStatus
    aadharBackStatus: $Enums.UserKycStatus
    selfieStatus: $Enums.UserKycStatus
    aadharPanNameMatchStatus: $Enums.UserKycStatus
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number | null
    _count: UserKycCountAggregateOutputType | null
    _avg: UserKycAvgAggregateOutputType | null
    _sum: UserKycSumAggregateOutputType | null
    _min: UserKycMinAggregateOutputType | null
    _max: UserKycMaxAggregateOutputType | null
  }

  type GetUserKycGroupByPayload<T extends UserKycGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserKycGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserKycGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserKycGroupByOutputType[P]>
            : GetScalarType<T[P], UserKycGroupByOutputType[P]>
        }
      >
    >


  export type UserKycSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encryptedUserDataId?: boolean
    fullName?: boolean
    gender?: boolean
    dob?: boolean
    address?: boolean
    fatherName?: boolean
    kycType?: boolean
    kycStatus?: boolean
    hyperVergeStatus?: boolean
    panStatus?: boolean
    aadharFrontStatus?: boolean
    aadharBackStatus?: boolean
    selfieStatus?: boolean
    aadharPanNameMatchStatus?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    EncryptedUserDataRel?: boolean | UserKyc$EncryptedUserDataRelArgs<ExtArgs>
    UserRel?: boolean | UserKyc$UserRelArgs<ExtArgs>
  }, ExtArgs["result"]["userKyc"]>

  export type UserKycSelectScalar = {
    id?: boolean
    encryptedUserDataId?: boolean
    fullName?: boolean
    gender?: boolean
    dob?: boolean
    address?: boolean
    fatherName?: boolean
    kycType?: boolean
    kycStatus?: boolean
    hyperVergeStatus?: boolean
    panStatus?: boolean
    aadharFrontStatus?: boolean
    aadharBackStatus?: boolean
    selfieStatus?: boolean
    aadharPanNameMatchStatus?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type UserKycInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    EncryptedUserDataRel?: boolean | UserKyc$EncryptedUserDataRelArgs<ExtArgs>
    UserRel?: boolean | UserKyc$UserRelArgs<ExtArgs>
  }


  export type $UserKycPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "UserKyc"
    objects: {
      EncryptedUserDataRel: Prisma.$EncryptedUserDataPayload<ExtArgs> | null
      UserRel: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      encryptedUserDataId: number | null
      fullName: string | null
      gender: $Enums.Gender | null
      dob: string | null
      address: string | null
      fatherName: string | null
      kycType: $Enums.KycType
      kycStatus: $Enums.UserKycStatus
      hyperVergeStatus: $Enums.HypervergeStatus | null
      panStatus: $Enums.UserKycStatus
      aadharFrontStatus: $Enums.UserKycStatus
      aadharBackStatus: $Enums.UserKycStatus
      selfieStatus: $Enums.UserKycStatus
      aadharPanNameMatchStatus: $Enums.UserKycStatus
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number | null
    }, ExtArgs["result"]["userKyc"]>
    composites: {}
  }


  type UserKycGetPayload<S extends boolean | null | undefined | UserKycDefaultArgs> = $Result.GetResult<Prisma.$UserKycPayload, S>

  type UserKycCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserKycFindManyArgs, 'select' | 'include'> & {
      select?: UserKycCountAggregateInputType | true
    }

  export interface UserKycDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserKyc'], meta: { name: 'UserKyc' } }
    /**
     * Find zero or one UserKyc that matches the filter.
     * @param {UserKycFindUniqueArgs} args - Arguments to find a UserKyc
     * @example
     * // Get one UserKyc
     * const userKyc = await prisma.userKyc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserKycFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserKycFindUniqueArgs<ExtArgs>>
    ): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserKyc that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserKycFindUniqueOrThrowArgs} args - Arguments to find a UserKyc
     * @example
     * // Get one UserKyc
     * const userKyc = await prisma.userKyc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserKycFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserKycFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserKyc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserKycFindFirstArgs} args - Arguments to find a UserKyc
     * @example
     * // Get one UserKyc
     * const userKyc = await prisma.userKyc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserKycFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserKycFindFirstArgs<ExtArgs>>
    ): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserKyc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserKycFindFirstOrThrowArgs} args - Arguments to find a UserKyc
     * @example
     * // Get one UserKyc
     * const userKyc = await prisma.userKyc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserKycFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserKycFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserKycs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserKycFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserKycs
     * const userKycs = await prisma.userKyc.findMany()
     * 
     * // Get first 10 UserKycs
     * const userKycs = await prisma.userKyc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userKycWithIdOnly = await prisma.userKyc.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserKycFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserKycFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserKyc.
     * @param {UserKycCreateArgs} args - Arguments to create a UserKyc.
     * @example
     * // Create one UserKyc
     * const UserKyc = await prisma.userKyc.create({
     *   data: {
     *     // ... data to create a UserKyc
     *   }
     * })
     * 
    **/
    create<T extends UserKycCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserKycCreateArgs<ExtArgs>>
    ): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserKycs.
     *     @param {UserKycCreateManyArgs} args - Arguments to create many UserKycs.
     *     @example
     *     // Create many UserKycs
     *     const userKyc = await prisma.userKyc.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserKycCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserKycCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserKyc.
     * @param {UserKycDeleteArgs} args - Arguments to delete one UserKyc.
     * @example
     * // Delete one UserKyc
     * const UserKyc = await prisma.userKyc.delete({
     *   where: {
     *     // ... filter to delete one UserKyc
     *   }
     * })
     * 
    **/
    delete<T extends UserKycDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserKycDeleteArgs<ExtArgs>>
    ): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserKyc.
     * @param {UserKycUpdateArgs} args - Arguments to update one UserKyc.
     * @example
     * // Update one UserKyc
     * const userKyc = await prisma.userKyc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserKycUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserKycUpdateArgs<ExtArgs>>
    ): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserKycs.
     * @param {UserKycDeleteManyArgs} args - Arguments to filter UserKycs to delete.
     * @example
     * // Delete a few UserKycs
     * const { count } = await prisma.userKyc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserKycDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserKycDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserKycs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserKycUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserKycs
     * const userKyc = await prisma.userKyc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserKycUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserKycUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserKyc.
     * @param {UserKycUpsertArgs} args - Arguments to update or create a UserKyc.
     * @example
     * // Update or create a UserKyc
     * const userKyc = await prisma.userKyc.upsert({
     *   create: {
     *     // ... data to create a UserKyc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserKyc we want to update
     *   }
     * })
    **/
    upsert<T extends UserKycUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserKycUpsertArgs<ExtArgs>>
    ): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserKycs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserKycCountArgs} args - Arguments to filter UserKycs to count.
     * @example
     * // Count the number of UserKycs
     * const count = await prisma.userKyc.count({
     *   where: {
     *     // ... the filter for the UserKycs we want to count
     *   }
     * })
    **/
    count<T extends UserKycCountArgs>(
      args?: Subset<T, UserKycCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserKycCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserKyc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserKycAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserKycAggregateArgs>(args: Subset<T, UserKycAggregateArgs>): Prisma.PrismaPromise<GetUserKycAggregateType<T>>

    /**
     * Group by UserKyc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserKycGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserKycGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserKycGroupByArgs['orderBy'] }
        : { orderBy?: UserKycGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserKycGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserKycGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserKyc model
   */
  readonly fields: UserKycFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserKyc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserKycClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    EncryptedUserDataRel<T extends UserKyc$EncryptedUserDataRelArgs<ExtArgs> = {}>(args?: Subset<T, UserKyc$EncryptedUserDataRelArgs<ExtArgs>>): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    UserRel<T extends UserKyc$UserRelArgs<ExtArgs> = {}>(args?: Subset<T, UserKyc$UserRelArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserKyc model
   */ 
  interface UserKycFieldRefs {
    readonly id: FieldRef<"UserKyc", 'Int'>
    readonly encryptedUserDataId: FieldRef<"UserKyc", 'Int'>
    readonly fullName: FieldRef<"UserKyc", 'String'>
    readonly gender: FieldRef<"UserKyc", 'Gender'>
    readonly dob: FieldRef<"UserKyc", 'String'>
    readonly address: FieldRef<"UserKyc", 'String'>
    readonly fatherName: FieldRef<"UserKyc", 'String'>
    readonly kycType: FieldRef<"UserKyc", 'KycType'>
    readonly kycStatus: FieldRef<"UserKyc", 'UserKycStatus'>
    readonly hyperVergeStatus: FieldRef<"UserKyc", 'HypervergeStatus'>
    readonly panStatus: FieldRef<"UserKyc", 'UserKycStatus'>
    readonly aadharFrontStatus: FieldRef<"UserKyc", 'UserKycStatus'>
    readonly aadharBackStatus: FieldRef<"UserKyc", 'UserKycStatus'>
    readonly selfieStatus: FieldRef<"UserKyc", 'UserKycStatus'>
    readonly aadharPanNameMatchStatus: FieldRef<"UserKyc", 'UserKycStatus'>
    readonly createdAt: FieldRef<"UserKyc", 'DateTime'>
    readonly createdBy: FieldRef<"UserKyc", 'Int'>
    readonly updatedAt: FieldRef<"UserKyc", 'DateTime'>
    readonly updatedBy: FieldRef<"UserKyc", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserKyc findUnique
   */
  export type UserKycFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * Filter, which UserKyc to fetch.
     */
    where: UserKycWhereUniqueInput
  }


  /**
   * UserKyc findUniqueOrThrow
   */
  export type UserKycFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * Filter, which UserKyc to fetch.
     */
    where: UserKycWhereUniqueInput
  }


  /**
   * UserKyc findFirst
   */
  export type UserKycFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * Filter, which UserKyc to fetch.
     */
    where?: UserKycWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserKycs to fetch.
     */
    orderBy?: UserKycOrderByWithRelationInput | UserKycOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserKycs.
     */
    cursor?: UserKycWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserKycs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserKycs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserKycs.
     */
    distinct?: UserKycScalarFieldEnum | UserKycScalarFieldEnum[]
  }


  /**
   * UserKyc findFirstOrThrow
   */
  export type UserKycFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * Filter, which UserKyc to fetch.
     */
    where?: UserKycWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserKycs to fetch.
     */
    orderBy?: UserKycOrderByWithRelationInput | UserKycOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserKycs.
     */
    cursor?: UserKycWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserKycs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserKycs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserKycs.
     */
    distinct?: UserKycScalarFieldEnum | UserKycScalarFieldEnum[]
  }


  /**
   * UserKyc findMany
   */
  export type UserKycFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * Filter, which UserKycs to fetch.
     */
    where?: UserKycWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserKycs to fetch.
     */
    orderBy?: UserKycOrderByWithRelationInput | UserKycOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserKycs.
     */
    cursor?: UserKycWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserKycs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserKycs.
     */
    skip?: number
    distinct?: UserKycScalarFieldEnum | UserKycScalarFieldEnum[]
  }


  /**
   * UserKyc create
   */
  export type UserKycCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * The data needed to create a UserKyc.
     */
    data: XOR<UserKycCreateInput, UserKycUncheckedCreateInput>
  }


  /**
   * UserKyc createMany
   */
  export type UserKycCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserKycs.
     */
    data: UserKycCreateManyInput | UserKycCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserKyc update
   */
  export type UserKycUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * The data needed to update a UserKyc.
     */
    data: XOR<UserKycUpdateInput, UserKycUncheckedUpdateInput>
    /**
     * Choose, which UserKyc to update.
     */
    where: UserKycWhereUniqueInput
  }


  /**
   * UserKyc updateMany
   */
  export type UserKycUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserKycs.
     */
    data: XOR<UserKycUpdateManyMutationInput, UserKycUncheckedUpdateManyInput>
    /**
     * Filter which UserKycs to update
     */
    where?: UserKycWhereInput
  }


  /**
   * UserKyc upsert
   */
  export type UserKycUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * The filter to search for the UserKyc to update in case it exists.
     */
    where: UserKycWhereUniqueInput
    /**
     * In case the UserKyc found by the `where` argument doesn't exist, create a new UserKyc with this data.
     */
    create: XOR<UserKycCreateInput, UserKycUncheckedCreateInput>
    /**
     * In case the UserKyc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserKycUpdateInput, UserKycUncheckedUpdateInput>
  }


  /**
   * UserKyc delete
   */
  export type UserKycDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    /**
     * Filter which UserKyc to delete.
     */
    where: UserKycWhereUniqueInput
  }


  /**
   * UserKyc deleteMany
   */
  export type UserKycDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserKycs to delete
     */
    where?: UserKycWhereInput
  }


  /**
   * UserKyc.EncryptedUserDataRel
   */
  export type UserKyc$EncryptedUserDataRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    where?: EncryptedUserDataWhereInput
  }


  /**
   * UserKyc.UserRel
   */
  export type UserKyc$UserRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * UserKyc without action
   */
  export type UserKycDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
  }



  /**
   * Model EncryptedUserData
   */

  export type AggregateEncryptedUserData = {
    _count: EncryptedUserDataCountAggregateOutputType | null
    _avg: EncryptedUserDataAvgAggregateOutputType | null
    _sum: EncryptedUserDataSumAggregateOutputType | null
    _min: EncryptedUserDataMinAggregateOutputType | null
    _max: EncryptedUserDataMaxAggregateOutputType | null
  }

  export type EncryptedUserDataAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type EncryptedUserDataSumAggregateOutputType = {
    id: number | null
    userId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type EncryptedUserDataMinAggregateOutputType = {
    id: number | null
    panNumber: string | null
    aadharNumber: string | null
    userId: number | null
    fileKey: string | null
    bucketName: string | null
    initVector: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type EncryptedUserDataMaxAggregateOutputType = {
    id: number | null
    panNumber: string | null
    aadharNumber: string | null
    userId: number | null
    fileKey: string | null
    bucketName: string | null
    initVector: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type EncryptedUserDataCountAggregateOutputType = {
    id: number
    panNumber: number
    aadharNumber: number
    userId: number
    fileKey: number
    bucketName: number
    initVector: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type EncryptedUserDataAvgAggregateInputType = {
    id?: true
    userId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type EncryptedUserDataSumAggregateInputType = {
    id?: true
    userId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type EncryptedUserDataMinAggregateInputType = {
    id?: true
    panNumber?: true
    aadharNumber?: true
    userId?: true
    fileKey?: true
    bucketName?: true
    initVector?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type EncryptedUserDataMaxAggregateInputType = {
    id?: true
    panNumber?: true
    aadharNumber?: true
    userId?: true
    fileKey?: true
    bucketName?: true
    initVector?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type EncryptedUserDataCountAggregateInputType = {
    id?: true
    panNumber?: true
    aadharNumber?: true
    userId?: true
    fileKey?: true
    bucketName?: true
    initVector?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type EncryptedUserDataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncryptedUserData to aggregate.
     */
    where?: EncryptedUserDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncryptedUserData to fetch.
     */
    orderBy?: EncryptedUserDataOrderByWithRelationInput | EncryptedUserDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncryptedUserDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncryptedUserData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncryptedUserData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncryptedUserData
    **/
    _count?: true | EncryptedUserDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncryptedUserDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncryptedUserDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncryptedUserDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncryptedUserDataMaxAggregateInputType
  }

  export type GetEncryptedUserDataAggregateType<T extends EncryptedUserDataAggregateArgs> = {
        [P in keyof T & keyof AggregateEncryptedUserData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncryptedUserData[P]>
      : GetScalarType<T[P], AggregateEncryptedUserData[P]>
  }




  export type EncryptedUserDataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EncryptedUserDataWhereInput
    orderBy?: EncryptedUserDataOrderByWithAggregationInput | EncryptedUserDataOrderByWithAggregationInput[]
    by: EncryptedUserDataScalarFieldEnum[] | EncryptedUserDataScalarFieldEnum
    having?: EncryptedUserDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncryptedUserDataCountAggregateInputType | true
    _avg?: EncryptedUserDataAvgAggregateInputType
    _sum?: EncryptedUserDataSumAggregateInputType
    _min?: EncryptedUserDataMinAggregateInputType
    _max?: EncryptedUserDataMaxAggregateInputType
  }

  export type EncryptedUserDataGroupByOutputType = {
    id: number
    panNumber: string | null
    aadharNumber: string | null
    userId: number
    fileKey: string | null
    bucketName: string | null
    initVector: string | null
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number | null
    _count: EncryptedUserDataCountAggregateOutputType | null
    _avg: EncryptedUserDataAvgAggregateOutputType | null
    _sum: EncryptedUserDataSumAggregateOutputType | null
    _min: EncryptedUserDataMinAggregateOutputType | null
    _max: EncryptedUserDataMaxAggregateOutputType | null
  }

  type GetEncryptedUserDataGroupByPayload<T extends EncryptedUserDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncryptedUserDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncryptedUserDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncryptedUserDataGroupByOutputType[P]>
            : GetScalarType<T[P], EncryptedUserDataGroupByOutputType[P]>
        }
      >
    >


  export type EncryptedUserDataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    panNumber?: boolean
    aadharNumber?: boolean
    userId?: boolean
    fileKey?: boolean
    bucketName?: boolean
    initVector?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    UserKyc?: boolean | EncryptedUserData$UserKycArgs<ExtArgs>
  }, ExtArgs["result"]["encryptedUserData"]>

  export type EncryptedUserDataSelectScalar = {
    id?: boolean
    panNumber?: boolean
    aadharNumber?: boolean
    userId?: boolean
    fileKey?: boolean
    bucketName?: boolean
    initVector?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type EncryptedUserDataInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    UserKyc?: boolean | EncryptedUserData$UserKycArgs<ExtArgs>
  }


  export type $EncryptedUserDataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "EncryptedUserData"
    objects: {
      UserKyc: Prisma.$UserKycPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      panNumber: string | null
      aadharNumber: string | null
      userId: number
      fileKey: string | null
      bucketName: string | null
      initVector: string | null
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number | null
    }, ExtArgs["result"]["encryptedUserData"]>
    composites: {}
  }


  type EncryptedUserDataGetPayload<S extends boolean | null | undefined | EncryptedUserDataDefaultArgs> = $Result.GetResult<Prisma.$EncryptedUserDataPayload, S>

  type EncryptedUserDataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EncryptedUserDataFindManyArgs, 'select' | 'include'> & {
      select?: EncryptedUserDataCountAggregateInputType | true
    }

  export interface EncryptedUserDataDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncryptedUserData'], meta: { name: 'EncryptedUserData' } }
    /**
     * Find zero or one EncryptedUserData that matches the filter.
     * @param {EncryptedUserDataFindUniqueArgs} args - Arguments to find a EncryptedUserData
     * @example
     * // Get one EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EncryptedUserDataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EncryptedUserDataFindUniqueArgs<ExtArgs>>
    ): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EncryptedUserData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EncryptedUserDataFindUniqueOrThrowArgs} args - Arguments to find a EncryptedUserData
     * @example
     * // Get one EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EncryptedUserDataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncryptedUserDataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EncryptedUserData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncryptedUserDataFindFirstArgs} args - Arguments to find a EncryptedUserData
     * @example
     * // Get one EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EncryptedUserDataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EncryptedUserDataFindFirstArgs<ExtArgs>>
    ): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EncryptedUserData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncryptedUserDataFindFirstOrThrowArgs} args - Arguments to find a EncryptedUserData
     * @example
     * // Get one EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EncryptedUserDataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncryptedUserDataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EncryptedUserData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncryptedUserDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.findMany()
     * 
     * // Get first 10 EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encryptedUserDataWithIdOnly = await prisma.encryptedUserData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EncryptedUserDataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncryptedUserDataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EncryptedUserData.
     * @param {EncryptedUserDataCreateArgs} args - Arguments to create a EncryptedUserData.
     * @example
     * // Create one EncryptedUserData
     * const EncryptedUserData = await prisma.encryptedUserData.create({
     *   data: {
     *     // ... data to create a EncryptedUserData
     *   }
     * })
     * 
    **/
    create<T extends EncryptedUserDataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EncryptedUserDataCreateArgs<ExtArgs>>
    ): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EncryptedUserData.
     *     @param {EncryptedUserDataCreateManyArgs} args - Arguments to create many EncryptedUserData.
     *     @example
     *     // Create many EncryptedUserData
     *     const encryptedUserData = await prisma.encryptedUserData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EncryptedUserDataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncryptedUserDataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EncryptedUserData.
     * @param {EncryptedUserDataDeleteArgs} args - Arguments to delete one EncryptedUserData.
     * @example
     * // Delete one EncryptedUserData
     * const EncryptedUserData = await prisma.encryptedUserData.delete({
     *   where: {
     *     // ... filter to delete one EncryptedUserData
     *   }
     * })
     * 
    **/
    delete<T extends EncryptedUserDataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EncryptedUserDataDeleteArgs<ExtArgs>>
    ): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EncryptedUserData.
     * @param {EncryptedUserDataUpdateArgs} args - Arguments to update one EncryptedUserData.
     * @example
     * // Update one EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EncryptedUserDataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EncryptedUserDataUpdateArgs<ExtArgs>>
    ): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EncryptedUserData.
     * @param {EncryptedUserDataDeleteManyArgs} args - Arguments to filter EncryptedUserData to delete.
     * @example
     * // Delete a few EncryptedUserData
     * const { count } = await prisma.encryptedUserData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EncryptedUserDataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncryptedUserDataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncryptedUserData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncryptedUserDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EncryptedUserDataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EncryptedUserDataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncryptedUserData.
     * @param {EncryptedUserDataUpsertArgs} args - Arguments to update or create a EncryptedUserData.
     * @example
     * // Update or create a EncryptedUserData
     * const encryptedUserData = await prisma.encryptedUserData.upsert({
     *   create: {
     *     // ... data to create a EncryptedUserData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncryptedUserData we want to update
     *   }
     * })
    **/
    upsert<T extends EncryptedUserDataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EncryptedUserDataUpsertArgs<ExtArgs>>
    ): Prisma__EncryptedUserDataClient<$Result.GetResult<Prisma.$EncryptedUserDataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EncryptedUserData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncryptedUserDataCountArgs} args - Arguments to filter EncryptedUserData to count.
     * @example
     * // Count the number of EncryptedUserData
     * const count = await prisma.encryptedUserData.count({
     *   where: {
     *     // ... the filter for the EncryptedUserData we want to count
     *   }
     * })
    **/
    count<T extends EncryptedUserDataCountArgs>(
      args?: Subset<T, EncryptedUserDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncryptedUserDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncryptedUserData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncryptedUserDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncryptedUserDataAggregateArgs>(args: Subset<T, EncryptedUserDataAggregateArgs>): Prisma.PrismaPromise<GetEncryptedUserDataAggregateType<T>>

    /**
     * Group by EncryptedUserData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncryptedUserDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncryptedUserDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncryptedUserDataGroupByArgs['orderBy'] }
        : { orderBy?: EncryptedUserDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncryptedUserDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncryptedUserDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncryptedUserData model
   */
  readonly fields: EncryptedUserDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncryptedUserData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncryptedUserDataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    UserKyc<T extends EncryptedUserData$UserKycArgs<ExtArgs> = {}>(args?: Subset<T, EncryptedUserData$UserKycArgs<ExtArgs>>): Prisma__UserKycClient<$Result.GetResult<Prisma.$UserKycPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EncryptedUserData model
   */ 
  interface EncryptedUserDataFieldRefs {
    readonly id: FieldRef<"EncryptedUserData", 'Int'>
    readonly panNumber: FieldRef<"EncryptedUserData", 'String'>
    readonly aadharNumber: FieldRef<"EncryptedUserData", 'String'>
    readonly userId: FieldRef<"EncryptedUserData", 'Int'>
    readonly fileKey: FieldRef<"EncryptedUserData", 'String'>
    readonly bucketName: FieldRef<"EncryptedUserData", 'String'>
    readonly initVector: FieldRef<"EncryptedUserData", 'String'>
    readonly createdAt: FieldRef<"EncryptedUserData", 'DateTime'>
    readonly createdBy: FieldRef<"EncryptedUserData", 'Int'>
    readonly updatedAt: FieldRef<"EncryptedUserData", 'DateTime'>
    readonly updatedBy: FieldRef<"EncryptedUserData", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EncryptedUserData findUnique
   */
  export type EncryptedUserDataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * Filter, which EncryptedUserData to fetch.
     */
    where: EncryptedUserDataWhereUniqueInput
  }


  /**
   * EncryptedUserData findUniqueOrThrow
   */
  export type EncryptedUserDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * Filter, which EncryptedUserData to fetch.
     */
    where: EncryptedUserDataWhereUniqueInput
  }


  /**
   * EncryptedUserData findFirst
   */
  export type EncryptedUserDataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * Filter, which EncryptedUserData to fetch.
     */
    where?: EncryptedUserDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncryptedUserData to fetch.
     */
    orderBy?: EncryptedUserDataOrderByWithRelationInput | EncryptedUserDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncryptedUserData.
     */
    cursor?: EncryptedUserDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncryptedUserData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncryptedUserData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncryptedUserData.
     */
    distinct?: EncryptedUserDataScalarFieldEnum | EncryptedUserDataScalarFieldEnum[]
  }


  /**
   * EncryptedUserData findFirstOrThrow
   */
  export type EncryptedUserDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * Filter, which EncryptedUserData to fetch.
     */
    where?: EncryptedUserDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncryptedUserData to fetch.
     */
    orderBy?: EncryptedUserDataOrderByWithRelationInput | EncryptedUserDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncryptedUserData.
     */
    cursor?: EncryptedUserDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncryptedUserData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncryptedUserData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncryptedUserData.
     */
    distinct?: EncryptedUserDataScalarFieldEnum | EncryptedUserDataScalarFieldEnum[]
  }


  /**
   * EncryptedUserData findMany
   */
  export type EncryptedUserDataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * Filter, which EncryptedUserData to fetch.
     */
    where?: EncryptedUserDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncryptedUserData to fetch.
     */
    orderBy?: EncryptedUserDataOrderByWithRelationInput | EncryptedUserDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncryptedUserData.
     */
    cursor?: EncryptedUserDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncryptedUserData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncryptedUserData.
     */
    skip?: number
    distinct?: EncryptedUserDataScalarFieldEnum | EncryptedUserDataScalarFieldEnum[]
  }


  /**
   * EncryptedUserData create
   */
  export type EncryptedUserDataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * The data needed to create a EncryptedUserData.
     */
    data: XOR<EncryptedUserDataCreateInput, EncryptedUserDataUncheckedCreateInput>
  }


  /**
   * EncryptedUserData createMany
   */
  export type EncryptedUserDataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncryptedUserData.
     */
    data: EncryptedUserDataCreateManyInput | EncryptedUserDataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EncryptedUserData update
   */
  export type EncryptedUserDataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * The data needed to update a EncryptedUserData.
     */
    data: XOR<EncryptedUserDataUpdateInput, EncryptedUserDataUncheckedUpdateInput>
    /**
     * Choose, which EncryptedUserData to update.
     */
    where: EncryptedUserDataWhereUniqueInput
  }


  /**
   * EncryptedUserData updateMany
   */
  export type EncryptedUserDataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncryptedUserData.
     */
    data: XOR<EncryptedUserDataUpdateManyMutationInput, EncryptedUserDataUncheckedUpdateManyInput>
    /**
     * Filter which EncryptedUserData to update
     */
    where?: EncryptedUserDataWhereInput
  }


  /**
   * EncryptedUserData upsert
   */
  export type EncryptedUserDataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * The filter to search for the EncryptedUserData to update in case it exists.
     */
    where: EncryptedUserDataWhereUniqueInput
    /**
     * In case the EncryptedUserData found by the `where` argument doesn't exist, create a new EncryptedUserData with this data.
     */
    create: XOR<EncryptedUserDataCreateInput, EncryptedUserDataUncheckedCreateInput>
    /**
     * In case the EncryptedUserData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncryptedUserDataUpdateInput, EncryptedUserDataUncheckedUpdateInput>
  }


  /**
   * EncryptedUserData delete
   */
  export type EncryptedUserDataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
    /**
     * Filter which EncryptedUserData to delete.
     */
    where: EncryptedUserDataWhereUniqueInput
  }


  /**
   * EncryptedUserData deleteMany
   */
  export type EncryptedUserDataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncryptedUserData to delete
     */
    where?: EncryptedUserDataWhereInput
  }


  /**
   * EncryptedUserData.UserKyc
   */
  export type EncryptedUserData$UserKycArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserKyc
     */
    select?: UserKycSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserKycInclude<ExtArgs> | null
    where?: UserKycWhereInput
  }


  /**
   * EncryptedUserData without action
   */
  export type EncryptedUserDataDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncryptedUserData
     */
    select?: EncryptedUserDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncryptedUserDataInclude<ExtArgs> | null
  }



  /**
   * Model UserBankDetails
   */

  export type AggregateUserBankDetails = {
    _count: UserBankDetailsCountAggregateOutputType | null
    _avg: UserBankDetailsAvgAggregateOutputType | null
    _sum: UserBankDetailsSumAggregateOutputType | null
    _min: UserBankDetailsMinAggregateOutputType | null
    _max: UserBankDetailsMaxAggregateOutputType | null
  }

  export type UserBankDetailsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserBankDetailsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserBankDetailsMinAggregateOutputType = {
    id: number | null
    bankDetailsType: $Enums.BankDetailsType | null
    userId: number | null
    bankAccountNumber: string | null
    bankName: string | null
    accountHolderName: string | null
    ifsc: string | null
    bankVerificationStatus: $Enums.BankVerificationStatus | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserBankDetailsMaxAggregateOutputType = {
    id: number | null
    bankDetailsType: $Enums.BankDetailsType | null
    userId: number | null
    bankAccountNumber: string | null
    bankName: string | null
    accountHolderName: string | null
    ifsc: string | null
    bankVerificationStatus: $Enums.BankVerificationStatus | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserBankDetailsCountAggregateOutputType = {
    id: number
    bankDetailsType: number
    userId: number
    bankAccountNumber: number
    bankName: number
    accountHolderName: number
    ifsc: number
    bankVerificationStatus: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserBankDetailsAvgAggregateInputType = {
    id?: true
    userId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserBankDetailsSumAggregateInputType = {
    id?: true
    userId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserBankDetailsMinAggregateInputType = {
    id?: true
    bankDetailsType?: true
    userId?: true
    bankAccountNumber?: true
    bankName?: true
    accountHolderName?: true
    ifsc?: true
    bankVerificationStatus?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserBankDetailsMaxAggregateInputType = {
    id?: true
    bankDetailsType?: true
    userId?: true
    bankAccountNumber?: true
    bankName?: true
    accountHolderName?: true
    ifsc?: true
    bankVerificationStatus?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserBankDetailsCountAggregateInputType = {
    id?: true
    bankDetailsType?: true
    userId?: true
    bankAccountNumber?: true
    bankName?: true
    accountHolderName?: true
    ifsc?: true
    bankVerificationStatus?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserBankDetailsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBankDetails to aggregate.
     */
    where?: UserBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBankDetails to fetch.
     */
    orderBy?: UserBankDetailsOrderByWithRelationInput | UserBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBankDetails
    **/
    _count?: true | UserBankDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBankDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBankDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBankDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBankDetailsMaxAggregateInputType
  }

  export type GetUserBankDetailsAggregateType<T extends UserBankDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBankDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBankDetails[P]>
      : GetScalarType<T[P], AggregateUserBankDetails[P]>
  }




  export type UserBankDetailsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserBankDetailsWhereInput
    orderBy?: UserBankDetailsOrderByWithAggregationInput | UserBankDetailsOrderByWithAggregationInput[]
    by: UserBankDetailsScalarFieldEnum[] | UserBankDetailsScalarFieldEnum
    having?: UserBankDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBankDetailsCountAggregateInputType | true
    _avg?: UserBankDetailsAvgAggregateInputType
    _sum?: UserBankDetailsSumAggregateInputType
    _min?: UserBankDetailsMinAggregateInputType
    _max?: UserBankDetailsMaxAggregateInputType
  }

  export type UserBankDetailsGroupByOutputType = {
    id: number
    bankDetailsType: $Enums.BankDetailsType
    userId: number | null
    bankAccountNumber: string | null
    bankName: string | null
    accountHolderName: string | null
    ifsc: string | null
    bankVerificationStatus: $Enums.BankVerificationStatus
    isActive: boolean
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number | null
    _count: UserBankDetailsCountAggregateOutputType | null
    _avg: UserBankDetailsAvgAggregateOutputType | null
    _sum: UserBankDetailsSumAggregateOutputType | null
    _min: UserBankDetailsMinAggregateOutputType | null
    _max: UserBankDetailsMaxAggregateOutputType | null
  }

  type GetUserBankDetailsGroupByPayload<T extends UserBankDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBankDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBankDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBankDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], UserBankDetailsGroupByOutputType[P]>
        }
      >
    >


  export type UserBankDetailsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankDetailsType?: boolean
    userId?: boolean
    bankAccountNumber?: boolean
    bankName?: boolean
    accountHolderName?: boolean
    ifsc?: boolean
    bankVerificationStatus?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    userRel?: boolean | UserBankDetails$userRelArgs<ExtArgs>
    UserBankRel?: boolean | UserBankDetails$UserBankRelArgs<ExtArgs>
    FiatPaymentsRel?: boolean | UserBankDetails$FiatPaymentsRelArgs<ExtArgs>
    UserRel?: boolean | UserBankDetails$UserRelArgs<ExtArgs>
    _count?: boolean | UserBankDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBankDetails"]>

  export type UserBankDetailsSelectScalar = {
    id?: boolean
    bankDetailsType?: boolean
    userId?: boolean
    bankAccountNumber?: boolean
    bankName?: boolean
    accountHolderName?: boolean
    ifsc?: boolean
    bankVerificationStatus?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type UserBankDetailsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userRel?: boolean | UserBankDetails$userRelArgs<ExtArgs>
    UserBankRel?: boolean | UserBankDetails$UserBankRelArgs<ExtArgs>
    FiatPaymentsRel?: boolean | UserBankDetails$FiatPaymentsRelArgs<ExtArgs>
    UserRel?: boolean | UserBankDetails$UserRelArgs<ExtArgs>
    _count?: boolean | UserBankDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserBankDetailsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "UserBankDetails"
    objects: {
      userRel: Prisma.$UserPayload<ExtArgs> | null
      UserBankRel: Prisma.$FiatPaymentsPayload<ExtArgs>[]
      FiatPaymentsRel: Prisma.$FiatPaymentsPayload<ExtArgs>[]
      UserRel: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      bankDetailsType: $Enums.BankDetailsType
      userId: number | null
      bankAccountNumber: string | null
      bankName: string | null
      accountHolderName: string | null
      ifsc: string | null
      bankVerificationStatus: $Enums.BankVerificationStatus
      isActive: boolean
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number | null
    }, ExtArgs["result"]["userBankDetails"]>
    composites: {}
  }


  type UserBankDetailsGetPayload<S extends boolean | null | undefined | UserBankDetailsDefaultArgs> = $Result.GetResult<Prisma.$UserBankDetailsPayload, S>

  type UserBankDetailsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserBankDetailsFindManyArgs, 'select' | 'include'> & {
      select?: UserBankDetailsCountAggregateInputType | true
    }

  export interface UserBankDetailsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBankDetails'], meta: { name: 'UserBankDetails' } }
    /**
     * Find zero or one UserBankDetails that matches the filter.
     * @param {UserBankDetailsFindUniqueArgs} args - Arguments to find a UserBankDetails
     * @example
     * // Get one UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserBankDetailsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserBankDetailsFindUniqueArgs<ExtArgs>>
    ): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserBankDetails that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserBankDetailsFindUniqueOrThrowArgs} args - Arguments to find a UserBankDetails
     * @example
     * // Get one UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserBankDetailsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBankDetailsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserBankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBankDetailsFindFirstArgs} args - Arguments to find a UserBankDetails
     * @example
     * // Get one UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserBankDetailsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBankDetailsFindFirstArgs<ExtArgs>>
    ): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserBankDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBankDetailsFindFirstOrThrowArgs} args - Arguments to find a UserBankDetails
     * @example
     * // Get one UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserBankDetailsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBankDetailsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserBankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBankDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.findMany()
     * 
     * // Get first 10 UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBankDetailsWithIdOnly = await prisma.userBankDetails.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserBankDetailsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBankDetailsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserBankDetails.
     * @param {UserBankDetailsCreateArgs} args - Arguments to create a UserBankDetails.
     * @example
     * // Create one UserBankDetails
     * const UserBankDetails = await prisma.userBankDetails.create({
     *   data: {
     *     // ... data to create a UserBankDetails
     *   }
     * })
     * 
    **/
    create<T extends UserBankDetailsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserBankDetailsCreateArgs<ExtArgs>>
    ): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserBankDetails.
     *     @param {UserBankDetailsCreateManyArgs} args - Arguments to create many UserBankDetails.
     *     @example
     *     // Create many UserBankDetails
     *     const userBankDetails = await prisma.userBankDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserBankDetailsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBankDetailsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserBankDetails.
     * @param {UserBankDetailsDeleteArgs} args - Arguments to delete one UserBankDetails.
     * @example
     * // Delete one UserBankDetails
     * const UserBankDetails = await prisma.userBankDetails.delete({
     *   where: {
     *     // ... filter to delete one UserBankDetails
     *   }
     * })
     * 
    **/
    delete<T extends UserBankDetailsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserBankDetailsDeleteArgs<ExtArgs>>
    ): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserBankDetails.
     * @param {UserBankDetailsUpdateArgs} args - Arguments to update one UserBankDetails.
     * @example
     * // Update one UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserBankDetailsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserBankDetailsUpdateArgs<ExtArgs>>
    ): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserBankDetails.
     * @param {UserBankDetailsDeleteManyArgs} args - Arguments to filter UserBankDetails to delete.
     * @example
     * // Delete a few UserBankDetails
     * const { count } = await prisma.userBankDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserBankDetailsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBankDetailsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBankDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserBankDetailsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserBankDetailsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBankDetails.
     * @param {UserBankDetailsUpsertArgs} args - Arguments to update or create a UserBankDetails.
     * @example
     * // Update or create a UserBankDetails
     * const userBankDetails = await prisma.userBankDetails.upsert({
     *   create: {
     *     // ... data to create a UserBankDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBankDetails we want to update
     *   }
     * })
    **/
    upsert<T extends UserBankDetailsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserBankDetailsUpsertArgs<ExtArgs>>
    ): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBankDetailsCountArgs} args - Arguments to filter UserBankDetails to count.
     * @example
     * // Count the number of UserBankDetails
     * const count = await prisma.userBankDetails.count({
     *   where: {
     *     // ... the filter for the UserBankDetails we want to count
     *   }
     * })
    **/
    count<T extends UserBankDetailsCountArgs>(
      args?: Subset<T, UserBankDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBankDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBankDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBankDetailsAggregateArgs>(args: Subset<T, UserBankDetailsAggregateArgs>): Prisma.PrismaPromise<GetUserBankDetailsAggregateType<T>>

    /**
     * Group by UserBankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBankDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBankDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBankDetailsGroupByArgs['orderBy'] }
        : { orderBy?: UserBankDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBankDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBankDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBankDetails model
   */
  readonly fields: UserBankDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBankDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBankDetailsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userRel<T extends UserBankDetails$userRelArgs<ExtArgs> = {}>(args?: Subset<T, UserBankDetails$userRelArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    UserBankRel<T extends UserBankDetails$UserBankRelArgs<ExtArgs> = {}>(args?: Subset<T, UserBankDetails$UserBankRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    FiatPaymentsRel<T extends UserBankDetails$FiatPaymentsRelArgs<ExtArgs> = {}>(args?: Subset<T, UserBankDetails$FiatPaymentsRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    UserRel<T extends UserBankDetails$UserRelArgs<ExtArgs> = {}>(args?: Subset<T, UserBankDetails$UserRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserBankDetails model
   */ 
  interface UserBankDetailsFieldRefs {
    readonly id: FieldRef<"UserBankDetails", 'Int'>
    readonly bankDetailsType: FieldRef<"UserBankDetails", 'BankDetailsType'>
    readonly userId: FieldRef<"UserBankDetails", 'Int'>
    readonly bankAccountNumber: FieldRef<"UserBankDetails", 'String'>
    readonly bankName: FieldRef<"UserBankDetails", 'String'>
    readonly accountHolderName: FieldRef<"UserBankDetails", 'String'>
    readonly ifsc: FieldRef<"UserBankDetails", 'String'>
    readonly bankVerificationStatus: FieldRef<"UserBankDetails", 'BankVerificationStatus'>
    readonly isActive: FieldRef<"UserBankDetails", 'Boolean'>
    readonly createdAt: FieldRef<"UserBankDetails", 'DateTime'>
    readonly createdBy: FieldRef<"UserBankDetails", 'Int'>
    readonly updatedAt: FieldRef<"UserBankDetails", 'DateTime'>
    readonly updatedBy: FieldRef<"UserBankDetails", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserBankDetails findUnique
   */
  export type UserBankDetailsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserBankDetails to fetch.
     */
    where: UserBankDetailsWhereUniqueInput
  }


  /**
   * UserBankDetails findUniqueOrThrow
   */
  export type UserBankDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserBankDetails to fetch.
     */
    where: UserBankDetailsWhereUniqueInput
  }


  /**
   * UserBankDetails findFirst
   */
  export type UserBankDetailsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserBankDetails to fetch.
     */
    where?: UserBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBankDetails to fetch.
     */
    orderBy?: UserBankDetailsOrderByWithRelationInput | UserBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBankDetails.
     */
    cursor?: UserBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBankDetails.
     */
    distinct?: UserBankDetailsScalarFieldEnum | UserBankDetailsScalarFieldEnum[]
  }


  /**
   * UserBankDetails findFirstOrThrow
   */
  export type UserBankDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserBankDetails to fetch.
     */
    where?: UserBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBankDetails to fetch.
     */
    orderBy?: UserBankDetailsOrderByWithRelationInput | UserBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBankDetails.
     */
    cursor?: UserBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBankDetails.
     */
    distinct?: UserBankDetailsScalarFieldEnum | UserBankDetailsScalarFieldEnum[]
  }


  /**
   * UserBankDetails findMany
   */
  export type UserBankDetailsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UserBankDetails to fetch.
     */
    where?: UserBankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBankDetails to fetch.
     */
    orderBy?: UserBankDetailsOrderByWithRelationInput | UserBankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBankDetails.
     */
    cursor?: UserBankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBankDetails.
     */
    skip?: number
    distinct?: UserBankDetailsScalarFieldEnum | UserBankDetailsScalarFieldEnum[]
  }


  /**
   * UserBankDetails create
   */
  export type UserBankDetailsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBankDetails.
     */
    data: XOR<UserBankDetailsCreateInput, UserBankDetailsUncheckedCreateInput>
  }


  /**
   * UserBankDetails createMany
   */
  export type UserBankDetailsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBankDetails.
     */
    data: UserBankDetailsCreateManyInput | UserBankDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserBankDetails update
   */
  export type UserBankDetailsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBankDetails.
     */
    data: XOR<UserBankDetailsUpdateInput, UserBankDetailsUncheckedUpdateInput>
    /**
     * Choose, which UserBankDetails to update.
     */
    where: UserBankDetailsWhereUniqueInput
  }


  /**
   * UserBankDetails updateMany
   */
  export type UserBankDetailsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBankDetails.
     */
    data: XOR<UserBankDetailsUpdateManyMutationInput, UserBankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which UserBankDetails to update
     */
    where?: UserBankDetailsWhereInput
  }


  /**
   * UserBankDetails upsert
   */
  export type UserBankDetailsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBankDetails to update in case it exists.
     */
    where: UserBankDetailsWhereUniqueInput
    /**
     * In case the UserBankDetails found by the `where` argument doesn't exist, create a new UserBankDetails with this data.
     */
    create: XOR<UserBankDetailsCreateInput, UserBankDetailsUncheckedCreateInput>
    /**
     * In case the UserBankDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBankDetailsUpdateInput, UserBankDetailsUncheckedUpdateInput>
  }


  /**
   * UserBankDetails delete
   */
  export type UserBankDetailsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    /**
     * Filter which UserBankDetails to delete.
     */
    where: UserBankDetailsWhereUniqueInput
  }


  /**
   * UserBankDetails deleteMany
   */
  export type UserBankDetailsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBankDetails to delete
     */
    where?: UserBankDetailsWhereInput
  }


  /**
   * UserBankDetails.userRel
   */
  export type UserBankDetails$userRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * UserBankDetails.UserBankRel
   */
  export type UserBankDetails$UserBankRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    where?: FiatPaymentsWhereInput
    orderBy?: FiatPaymentsOrderByWithRelationInput | FiatPaymentsOrderByWithRelationInput[]
    cursor?: FiatPaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FiatPaymentsScalarFieldEnum | FiatPaymentsScalarFieldEnum[]
  }


  /**
   * UserBankDetails.FiatPaymentsRel
   */
  export type UserBankDetails$FiatPaymentsRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    where?: FiatPaymentsWhereInput
    orderBy?: FiatPaymentsOrderByWithRelationInput | FiatPaymentsOrderByWithRelationInput[]
    cursor?: FiatPaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FiatPaymentsScalarFieldEnum | FiatPaymentsScalarFieldEnum[]
  }


  /**
   * UserBankDetails.UserRel
   */
  export type UserBankDetails$UserRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * UserBankDetails without action
   */
  export type UserBankDetailsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
  }



  /**
   * Model FiatPayments
   */

  export type AggregateFiatPayments = {
    _count: FiatPaymentsCountAggregateOutputType | null
    _avg: FiatPaymentsAvgAggregateOutputType | null
    _sum: FiatPaymentsSumAggregateOutputType | null
    _min: FiatPaymentsMinAggregateOutputType | null
    _max: FiatPaymentsMaxAggregateOutputType | null
  }

  export type FiatPaymentsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    systemBankId: number | null
    userBankId: number | null
    amount: number | null
    fee: number | null
    amountCredited: number | null
    amountDebited: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type FiatPaymentsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    systemBankId: number | null
    userBankId: number | null
    amount: number | null
    fee: number | null
    amountCredited: number | null
    amountDebited: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type FiatPaymentsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    paymentType: $Enums.PaymentType | null
    paymentStatus: $Enums.PaymentStatus | null
    systemBankId: number | null
    userBankId: number | null
    systemAccountNumber: string | null
    userAccountNumber: string | null
    amount: number | null
    fee: number | null
    amountCredited: number | null
    amountDebited: number | null
    bankProofUrl: string | null
    receiptNumber: string | null
    userRemarks: string | null
    adminRemarks: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type FiatPaymentsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    paymentType: $Enums.PaymentType | null
    paymentStatus: $Enums.PaymentStatus | null
    systemBankId: number | null
    userBankId: number | null
    systemAccountNumber: string | null
    userAccountNumber: string | null
    amount: number | null
    fee: number | null
    amountCredited: number | null
    amountDebited: number | null
    bankProofUrl: string | null
    receiptNumber: string | null
    userRemarks: string | null
    adminRemarks: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type FiatPaymentsCountAggregateOutputType = {
    id: number
    userId: number
    paymentType: number
    paymentStatus: number
    systemBankId: number
    userBankId: number
    systemAccountNumber: number
    userAccountNumber: number
    amount: number
    fee: number
    amountCredited: number
    amountDebited: number
    bankProofUrl: number
    receiptNumber: number
    userRemarks: number
    adminRemarks: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type FiatPaymentsAvgAggregateInputType = {
    id?: true
    userId?: true
    systemBankId?: true
    userBankId?: true
    amount?: true
    fee?: true
    amountCredited?: true
    amountDebited?: true
    createdBy?: true
    updatedBy?: true
  }

  export type FiatPaymentsSumAggregateInputType = {
    id?: true
    userId?: true
    systemBankId?: true
    userBankId?: true
    amount?: true
    fee?: true
    amountCredited?: true
    amountDebited?: true
    createdBy?: true
    updatedBy?: true
  }

  export type FiatPaymentsMinAggregateInputType = {
    id?: true
    userId?: true
    paymentType?: true
    paymentStatus?: true
    systemBankId?: true
    userBankId?: true
    systemAccountNumber?: true
    userAccountNumber?: true
    amount?: true
    fee?: true
    amountCredited?: true
    amountDebited?: true
    bankProofUrl?: true
    receiptNumber?: true
    userRemarks?: true
    adminRemarks?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type FiatPaymentsMaxAggregateInputType = {
    id?: true
    userId?: true
    paymentType?: true
    paymentStatus?: true
    systemBankId?: true
    userBankId?: true
    systemAccountNumber?: true
    userAccountNumber?: true
    amount?: true
    fee?: true
    amountCredited?: true
    amountDebited?: true
    bankProofUrl?: true
    receiptNumber?: true
    userRemarks?: true
    adminRemarks?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type FiatPaymentsCountAggregateInputType = {
    id?: true
    userId?: true
    paymentType?: true
    paymentStatus?: true
    systemBankId?: true
    userBankId?: true
    systemAccountNumber?: true
    userAccountNumber?: true
    amount?: true
    fee?: true
    amountCredited?: true
    amountDebited?: true
    bankProofUrl?: true
    receiptNumber?: true
    userRemarks?: true
    adminRemarks?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type FiatPaymentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiatPayments to aggregate.
     */
    where?: FiatPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiatPayments to fetch.
     */
    orderBy?: FiatPaymentsOrderByWithRelationInput | FiatPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FiatPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiatPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiatPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FiatPayments
    **/
    _count?: true | FiatPaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FiatPaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FiatPaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiatPaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiatPaymentsMaxAggregateInputType
  }

  export type GetFiatPaymentsAggregateType<T extends FiatPaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregateFiatPayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiatPayments[P]>
      : GetScalarType<T[P], AggregateFiatPayments[P]>
  }




  export type FiatPaymentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FiatPaymentsWhereInput
    orderBy?: FiatPaymentsOrderByWithAggregationInput | FiatPaymentsOrderByWithAggregationInput[]
    by: FiatPaymentsScalarFieldEnum[] | FiatPaymentsScalarFieldEnum
    having?: FiatPaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiatPaymentsCountAggregateInputType | true
    _avg?: FiatPaymentsAvgAggregateInputType
    _sum?: FiatPaymentsSumAggregateInputType
    _min?: FiatPaymentsMinAggregateInputType
    _max?: FiatPaymentsMaxAggregateInputType
  }

  export type FiatPaymentsGroupByOutputType = {
    id: number
    userId: number
    paymentType: $Enums.PaymentType
    paymentStatus: $Enums.PaymentStatus
    systemBankId: number
    userBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited: number | null
    amountDebited: number | null
    bankProofUrl: string | null
    receiptNumber: string | null
    userRemarks: string | null
    adminRemarks: string | null
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: FiatPaymentsCountAggregateOutputType | null
    _avg: FiatPaymentsAvgAggregateOutputType | null
    _sum: FiatPaymentsSumAggregateOutputType | null
    _min: FiatPaymentsMinAggregateOutputType | null
    _max: FiatPaymentsMaxAggregateOutputType | null
  }

  type GetFiatPaymentsGroupByPayload<T extends FiatPaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FiatPaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiatPaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiatPaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], FiatPaymentsGroupByOutputType[P]>
        }
      >
    >


  export type FiatPaymentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentType?: boolean
    paymentStatus?: boolean
    systemBankId?: boolean
    userBankId?: boolean
    systemAccountNumber?: boolean
    userAccountNumber?: boolean
    amount?: boolean
    fee?: boolean
    amountCredited?: boolean
    amountDebited?: boolean
    bankProofUrl?: boolean
    receiptNumber?: boolean
    userRemarks?: boolean
    adminRemarks?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    user?: boolean | FiatPayments$userArgs<ExtArgs>
    systemBankRel?: boolean | FiatPayments$systemBankRelArgs<ExtArgs>
    userBankRel?: boolean | FiatPayments$userBankRelArgs<ExtArgs>
    BankFeedRel?: boolean | FiatPayments$BankFeedRelArgs<ExtArgs>
  }, ExtArgs["result"]["fiatPayments"]>

  export type FiatPaymentsSelectScalar = {
    id?: boolean
    userId?: boolean
    paymentType?: boolean
    paymentStatus?: boolean
    systemBankId?: boolean
    userBankId?: boolean
    systemAccountNumber?: boolean
    userAccountNumber?: boolean
    amount?: boolean
    fee?: boolean
    amountCredited?: boolean
    amountDebited?: boolean
    bankProofUrl?: boolean
    receiptNumber?: boolean
    userRemarks?: boolean
    adminRemarks?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type FiatPaymentsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | FiatPayments$userArgs<ExtArgs>
    systemBankRel?: boolean | FiatPayments$systemBankRelArgs<ExtArgs>
    userBankRel?: boolean | FiatPayments$userBankRelArgs<ExtArgs>
    BankFeedRel?: boolean | FiatPayments$BankFeedRelArgs<ExtArgs>
  }


  export type $FiatPaymentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "FiatPayments"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      systemBankRel: Prisma.$UserBankDetailsPayload<ExtArgs> | null
      userBankRel: Prisma.$UserBankDetailsPayload<ExtArgs> | null
      BankFeedRel: Prisma.$BankFeedPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      paymentType: $Enums.PaymentType
      paymentStatus: $Enums.PaymentStatus
      systemBankId: number
      userBankId: number
      systemAccountNumber: string
      userAccountNumber: string
      amount: number
      fee: number
      amountCredited: number | null
      amountDebited: number | null
      bankProofUrl: string | null
      receiptNumber: string | null
      userRemarks: string | null
      adminRemarks: string | null
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["fiatPayments"]>
    composites: {}
  }


  type FiatPaymentsGetPayload<S extends boolean | null | undefined | FiatPaymentsDefaultArgs> = $Result.GetResult<Prisma.$FiatPaymentsPayload, S>

  type FiatPaymentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FiatPaymentsFindManyArgs, 'select' | 'include'> & {
      select?: FiatPaymentsCountAggregateInputType | true
    }

  export interface FiatPaymentsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FiatPayments'], meta: { name: 'FiatPayments' } }
    /**
     * Find zero or one FiatPayments that matches the filter.
     * @param {FiatPaymentsFindUniqueArgs} args - Arguments to find a FiatPayments
     * @example
     * // Get one FiatPayments
     * const fiatPayments = await prisma.fiatPayments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FiatPaymentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FiatPaymentsFindUniqueArgs<ExtArgs>>
    ): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FiatPayments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FiatPaymentsFindUniqueOrThrowArgs} args - Arguments to find a FiatPayments
     * @example
     * // Get one FiatPayments
     * const fiatPayments = await prisma.fiatPayments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FiatPaymentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FiatPaymentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FiatPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiatPaymentsFindFirstArgs} args - Arguments to find a FiatPayments
     * @example
     * // Get one FiatPayments
     * const fiatPayments = await prisma.fiatPayments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FiatPaymentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FiatPaymentsFindFirstArgs<ExtArgs>>
    ): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FiatPayments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiatPaymentsFindFirstOrThrowArgs} args - Arguments to find a FiatPayments
     * @example
     * // Get one FiatPayments
     * const fiatPayments = await prisma.fiatPayments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FiatPaymentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FiatPaymentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FiatPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiatPaymentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FiatPayments
     * const fiatPayments = await prisma.fiatPayments.findMany()
     * 
     * // Get first 10 FiatPayments
     * const fiatPayments = await prisma.fiatPayments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiatPaymentsWithIdOnly = await prisma.fiatPayments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FiatPaymentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FiatPaymentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FiatPayments.
     * @param {FiatPaymentsCreateArgs} args - Arguments to create a FiatPayments.
     * @example
     * // Create one FiatPayments
     * const FiatPayments = await prisma.fiatPayments.create({
     *   data: {
     *     // ... data to create a FiatPayments
     *   }
     * })
     * 
    **/
    create<T extends FiatPaymentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FiatPaymentsCreateArgs<ExtArgs>>
    ): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FiatPayments.
     *     @param {FiatPaymentsCreateManyArgs} args - Arguments to create many FiatPayments.
     *     @example
     *     // Create many FiatPayments
     *     const fiatPayments = await prisma.fiatPayments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FiatPaymentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FiatPaymentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FiatPayments.
     * @param {FiatPaymentsDeleteArgs} args - Arguments to delete one FiatPayments.
     * @example
     * // Delete one FiatPayments
     * const FiatPayments = await prisma.fiatPayments.delete({
     *   where: {
     *     // ... filter to delete one FiatPayments
     *   }
     * })
     * 
    **/
    delete<T extends FiatPaymentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FiatPaymentsDeleteArgs<ExtArgs>>
    ): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FiatPayments.
     * @param {FiatPaymentsUpdateArgs} args - Arguments to update one FiatPayments.
     * @example
     * // Update one FiatPayments
     * const fiatPayments = await prisma.fiatPayments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FiatPaymentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FiatPaymentsUpdateArgs<ExtArgs>>
    ): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FiatPayments.
     * @param {FiatPaymentsDeleteManyArgs} args - Arguments to filter FiatPayments to delete.
     * @example
     * // Delete a few FiatPayments
     * const { count } = await prisma.fiatPayments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FiatPaymentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FiatPaymentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiatPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiatPaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FiatPayments
     * const fiatPayments = await prisma.fiatPayments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FiatPaymentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FiatPaymentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FiatPayments.
     * @param {FiatPaymentsUpsertArgs} args - Arguments to update or create a FiatPayments.
     * @example
     * // Update or create a FiatPayments
     * const fiatPayments = await prisma.fiatPayments.upsert({
     *   create: {
     *     // ... data to create a FiatPayments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FiatPayments we want to update
     *   }
     * })
    **/
    upsert<T extends FiatPaymentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FiatPaymentsUpsertArgs<ExtArgs>>
    ): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FiatPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiatPaymentsCountArgs} args - Arguments to filter FiatPayments to count.
     * @example
     * // Count the number of FiatPayments
     * const count = await prisma.fiatPayments.count({
     *   where: {
     *     // ... the filter for the FiatPayments we want to count
     *   }
     * })
    **/
    count<T extends FiatPaymentsCountArgs>(
      args?: Subset<T, FiatPaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiatPaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FiatPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiatPaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiatPaymentsAggregateArgs>(args: Subset<T, FiatPaymentsAggregateArgs>): Prisma.PrismaPromise<GetFiatPaymentsAggregateType<T>>

    /**
     * Group by FiatPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiatPaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiatPaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiatPaymentsGroupByArgs['orderBy'] }
        : { orderBy?: FiatPaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiatPaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiatPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FiatPayments model
   */
  readonly fields: FiatPaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FiatPayments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FiatPaymentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends FiatPayments$userArgs<ExtArgs> = {}>(args?: Subset<T, FiatPayments$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    systemBankRel<T extends FiatPayments$systemBankRelArgs<ExtArgs> = {}>(args?: Subset<T, FiatPayments$systemBankRelArgs<ExtArgs>>): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    userBankRel<T extends FiatPayments$userBankRelArgs<ExtArgs> = {}>(args?: Subset<T, FiatPayments$userBankRelArgs<ExtArgs>>): Prisma__UserBankDetailsClient<$Result.GetResult<Prisma.$UserBankDetailsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    BankFeedRel<T extends FiatPayments$BankFeedRelArgs<ExtArgs> = {}>(args?: Subset<T, FiatPayments$BankFeedRelArgs<ExtArgs>>): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FiatPayments model
   */ 
  interface FiatPaymentsFieldRefs {
    readonly id: FieldRef<"FiatPayments", 'Int'>
    readonly userId: FieldRef<"FiatPayments", 'Int'>
    readonly paymentType: FieldRef<"FiatPayments", 'PaymentType'>
    readonly paymentStatus: FieldRef<"FiatPayments", 'PaymentStatus'>
    readonly systemBankId: FieldRef<"FiatPayments", 'Int'>
    readonly userBankId: FieldRef<"FiatPayments", 'Int'>
    readonly systemAccountNumber: FieldRef<"FiatPayments", 'String'>
    readonly userAccountNumber: FieldRef<"FiatPayments", 'String'>
    readonly amount: FieldRef<"FiatPayments", 'Float'>
    readonly fee: FieldRef<"FiatPayments", 'Float'>
    readonly amountCredited: FieldRef<"FiatPayments", 'Float'>
    readonly amountDebited: FieldRef<"FiatPayments", 'Float'>
    readonly bankProofUrl: FieldRef<"FiatPayments", 'String'>
    readonly receiptNumber: FieldRef<"FiatPayments", 'String'>
    readonly userRemarks: FieldRef<"FiatPayments", 'String'>
    readonly adminRemarks: FieldRef<"FiatPayments", 'String'>
    readonly createdAt: FieldRef<"FiatPayments", 'DateTime'>
    readonly createdBy: FieldRef<"FiatPayments", 'Int'>
    readonly updatedAt: FieldRef<"FiatPayments", 'DateTime'>
    readonly updatedBy: FieldRef<"FiatPayments", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * FiatPayments findUnique
   */
  export type FiatPaymentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which FiatPayments to fetch.
     */
    where: FiatPaymentsWhereUniqueInput
  }


  /**
   * FiatPayments findUniqueOrThrow
   */
  export type FiatPaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which FiatPayments to fetch.
     */
    where: FiatPaymentsWhereUniqueInput
  }


  /**
   * FiatPayments findFirst
   */
  export type FiatPaymentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which FiatPayments to fetch.
     */
    where?: FiatPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiatPayments to fetch.
     */
    orderBy?: FiatPaymentsOrderByWithRelationInput | FiatPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiatPayments.
     */
    cursor?: FiatPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiatPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiatPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiatPayments.
     */
    distinct?: FiatPaymentsScalarFieldEnum | FiatPaymentsScalarFieldEnum[]
  }


  /**
   * FiatPayments findFirstOrThrow
   */
  export type FiatPaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which FiatPayments to fetch.
     */
    where?: FiatPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiatPayments to fetch.
     */
    orderBy?: FiatPaymentsOrderByWithRelationInput | FiatPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiatPayments.
     */
    cursor?: FiatPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiatPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiatPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiatPayments.
     */
    distinct?: FiatPaymentsScalarFieldEnum | FiatPaymentsScalarFieldEnum[]
  }


  /**
   * FiatPayments findMany
   */
  export type FiatPaymentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which FiatPayments to fetch.
     */
    where?: FiatPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiatPayments to fetch.
     */
    orderBy?: FiatPaymentsOrderByWithRelationInput | FiatPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FiatPayments.
     */
    cursor?: FiatPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiatPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiatPayments.
     */
    skip?: number
    distinct?: FiatPaymentsScalarFieldEnum | FiatPaymentsScalarFieldEnum[]
  }


  /**
   * FiatPayments create
   */
  export type FiatPaymentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a FiatPayments.
     */
    data: XOR<FiatPaymentsCreateInput, FiatPaymentsUncheckedCreateInput>
  }


  /**
   * FiatPayments createMany
   */
  export type FiatPaymentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FiatPayments.
     */
    data: FiatPaymentsCreateManyInput | FiatPaymentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FiatPayments update
   */
  export type FiatPaymentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a FiatPayments.
     */
    data: XOR<FiatPaymentsUpdateInput, FiatPaymentsUncheckedUpdateInput>
    /**
     * Choose, which FiatPayments to update.
     */
    where: FiatPaymentsWhereUniqueInput
  }


  /**
   * FiatPayments updateMany
   */
  export type FiatPaymentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FiatPayments.
     */
    data: XOR<FiatPaymentsUpdateManyMutationInput, FiatPaymentsUncheckedUpdateManyInput>
    /**
     * Filter which FiatPayments to update
     */
    where?: FiatPaymentsWhereInput
  }


  /**
   * FiatPayments upsert
   */
  export type FiatPaymentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the FiatPayments to update in case it exists.
     */
    where: FiatPaymentsWhereUniqueInput
    /**
     * In case the FiatPayments found by the `where` argument doesn't exist, create a new FiatPayments with this data.
     */
    create: XOR<FiatPaymentsCreateInput, FiatPaymentsUncheckedCreateInput>
    /**
     * In case the FiatPayments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FiatPaymentsUpdateInput, FiatPaymentsUncheckedUpdateInput>
  }


  /**
   * FiatPayments delete
   */
  export type FiatPaymentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    /**
     * Filter which FiatPayments to delete.
     */
    where: FiatPaymentsWhereUniqueInput
  }


  /**
   * FiatPayments deleteMany
   */
  export type FiatPaymentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiatPayments to delete
     */
    where?: FiatPaymentsWhereInput
  }


  /**
   * FiatPayments.user
   */
  export type FiatPayments$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * FiatPayments.systemBankRel
   */
  export type FiatPayments$systemBankRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    where?: UserBankDetailsWhereInput
  }


  /**
   * FiatPayments.userBankRel
   */
  export type FiatPayments$userBankRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBankDetails
     */
    select?: UserBankDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBankDetailsInclude<ExtArgs> | null
    where?: UserBankDetailsWhereInput
  }


  /**
   * FiatPayments.BankFeedRel
   */
  export type FiatPayments$BankFeedRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    where?: BankFeedWhereInput
  }


  /**
   * FiatPayments without action
   */
  export type FiatPaymentsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
  }



  /**
   * Model CryptoDeposit
   */

  export type AggregateCryptoDeposit = {
    _count: CryptoDepositCountAggregateOutputType | null
    _avg: CryptoDepositAvgAggregateOutputType | null
    _sum: CryptoDepositSumAggregateOutputType | null
    _min: CryptoDepositMinAggregateOutputType | null
    _max: CryptoDepositMaxAggregateOutputType | null
  }

  export type CryptoDepositAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    cryptoWalletId: number | null
    walletId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CryptoDepositSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    cryptoWalletId: number | null
    walletId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CryptoDepositMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    cryptoWalletId: number | null
    liminalTxnRefId: string | null
    coin: string | null
    walletId: number | null
    timestamp: string | null
    fee: string | null
    effectiveChange: string | null
    runningBalance: string | null
    externalAddress: string | null
    effectiveChangeUsd: string | null
    tokenContractAddress: string | null
    explorerLink: string | null
    sequenceId: string | null
    type: string | null
    conversionRate: string | null
    isConverted: boolean | null
    conversionTimestamp: Date | null
    inrCreditStatus: $Enums.InrCreditStatus | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CryptoDepositMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    cryptoWalletId: number | null
    liminalTxnRefId: string | null
    coin: string | null
    walletId: number | null
    timestamp: string | null
    fee: string | null
    effectiveChange: string | null
    runningBalance: string | null
    externalAddress: string | null
    effectiveChangeUsd: string | null
    tokenContractAddress: string | null
    explorerLink: string | null
    sequenceId: string | null
    type: string | null
    conversionRate: string | null
    isConverted: boolean | null
    conversionTimestamp: Date | null
    inrCreditStatus: $Enums.InrCreditStatus | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CryptoDepositCountAggregateOutputType = {
    id: number
    accountId: number
    cryptoWalletId: number
    liminalTxnRefId: number
    coin: number
    walletId: number
    timestamp: number
    fee: number
    effectiveChange: number
    runningBalance: number
    externalAddress: number
    effectiveChangeUsd: number
    wallet: number
    tokenContractAddress: number
    explorerLink: number
    inputs: number
    outputs: number
    sequenceId: number
    type: number
    conversionRate: number
    isConverted: number
    conversionTimestamp: number
    inrCreditStatus: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type CryptoDepositAvgAggregateInputType = {
    id?: true
    accountId?: true
    cryptoWalletId?: true
    walletId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CryptoDepositSumAggregateInputType = {
    id?: true
    accountId?: true
    cryptoWalletId?: true
    walletId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CryptoDepositMinAggregateInputType = {
    id?: true
    accountId?: true
    cryptoWalletId?: true
    liminalTxnRefId?: true
    coin?: true
    walletId?: true
    timestamp?: true
    fee?: true
    effectiveChange?: true
    runningBalance?: true
    externalAddress?: true
    effectiveChangeUsd?: true
    tokenContractAddress?: true
    explorerLink?: true
    sequenceId?: true
    type?: true
    conversionRate?: true
    isConverted?: true
    conversionTimestamp?: true
    inrCreditStatus?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CryptoDepositMaxAggregateInputType = {
    id?: true
    accountId?: true
    cryptoWalletId?: true
    liminalTxnRefId?: true
    coin?: true
    walletId?: true
    timestamp?: true
    fee?: true
    effectiveChange?: true
    runningBalance?: true
    externalAddress?: true
    effectiveChangeUsd?: true
    tokenContractAddress?: true
    explorerLink?: true
    sequenceId?: true
    type?: true
    conversionRate?: true
    isConverted?: true
    conversionTimestamp?: true
    inrCreditStatus?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CryptoDepositCountAggregateInputType = {
    id?: true
    accountId?: true
    cryptoWalletId?: true
    liminalTxnRefId?: true
    coin?: true
    walletId?: true
    timestamp?: true
    fee?: true
    effectiveChange?: true
    runningBalance?: true
    externalAddress?: true
    effectiveChangeUsd?: true
    wallet?: true
    tokenContractAddress?: true
    explorerLink?: true
    inputs?: true
    outputs?: true
    sequenceId?: true
    type?: true
    conversionRate?: true
    isConverted?: true
    conversionTimestamp?: true
    inrCreditStatus?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type CryptoDepositAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoDeposit to aggregate.
     */
    where?: CryptoDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoDeposits to fetch.
     */
    orderBy?: CryptoDepositOrderByWithRelationInput | CryptoDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoDeposits
    **/
    _count?: true | CryptoDepositCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoDepositAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoDepositSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoDepositMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoDepositMaxAggregateInputType
  }

  export type GetCryptoDepositAggregateType<T extends CryptoDepositAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoDeposit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoDeposit[P]>
      : GetScalarType<T[P], AggregateCryptoDeposit[P]>
  }




  export type CryptoDepositGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CryptoDepositWhereInput
    orderBy?: CryptoDepositOrderByWithAggregationInput | CryptoDepositOrderByWithAggregationInput[]
    by: CryptoDepositScalarFieldEnum[] | CryptoDepositScalarFieldEnum
    having?: CryptoDepositScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoDepositCountAggregateInputType | true
    _avg?: CryptoDepositAvgAggregateInputType
    _sum?: CryptoDepositSumAggregateInputType
    _min?: CryptoDepositMinAggregateInputType
    _max?: CryptoDepositMaxAggregateInputType
  }

  export type CryptoDepositGroupByOutputType = {
    id: number
    accountId: number
    cryptoWalletId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee: string | null
    effectiveChange: string | null
    runningBalance: string | null
    externalAddress: string | null
    effectiveChangeUsd: string | null
    wallet: JsonValue | null
    tokenContractAddress: string | null
    explorerLink: string | null
    inputs: JsonValue[]
    outputs: JsonValue[]
    sequenceId: string | null
    type: string | null
    conversionRate: string | null
    isConverted: boolean | null
    conversionTimestamp: Date | null
    inrCreditStatus: $Enums.InrCreditStatus
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: CryptoDepositCountAggregateOutputType | null
    _avg: CryptoDepositAvgAggregateOutputType | null
    _sum: CryptoDepositSumAggregateOutputType | null
    _min: CryptoDepositMinAggregateOutputType | null
    _max: CryptoDepositMaxAggregateOutputType | null
  }

  type GetCryptoDepositGroupByPayload<T extends CryptoDepositGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoDepositGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoDepositGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoDepositGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoDepositGroupByOutputType[P]>
        }
      >
    >


  export type CryptoDepositSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    cryptoWalletId?: boolean
    liminalTxnRefId?: boolean
    coin?: boolean
    walletId?: boolean
    timestamp?: boolean
    fee?: boolean
    effectiveChange?: boolean
    runningBalance?: boolean
    externalAddress?: boolean
    effectiveChangeUsd?: boolean
    wallet?: boolean
    tokenContractAddress?: boolean
    explorerLink?: boolean
    inputs?: boolean
    outputs?: boolean
    sequenceId?: boolean
    type?: boolean
    conversionRate?: boolean
    isConverted?: boolean
    conversionTimestamp?: boolean
    inrCreditStatus?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    cryptoWallet?: boolean | CryptoDeposit$cryptoWalletArgs<ExtArgs>
    inrConvHistRel?: boolean | CryptoDeposit$inrConvHistRelArgs<ExtArgs>
    _count?: boolean | CryptoDepositCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoDeposit"]>

  export type CryptoDepositSelectScalar = {
    id?: boolean
    accountId?: boolean
    cryptoWalletId?: boolean
    liminalTxnRefId?: boolean
    coin?: boolean
    walletId?: boolean
    timestamp?: boolean
    fee?: boolean
    effectiveChange?: boolean
    runningBalance?: boolean
    externalAddress?: boolean
    effectiveChangeUsd?: boolean
    wallet?: boolean
    tokenContractAddress?: boolean
    explorerLink?: boolean
    inputs?: boolean
    outputs?: boolean
    sequenceId?: boolean
    type?: boolean
    conversionRate?: boolean
    isConverted?: boolean
    conversionTimestamp?: boolean
    inrCreditStatus?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type CryptoDepositInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    cryptoWallet?: boolean | CryptoDeposit$cryptoWalletArgs<ExtArgs>
    inrConvHistRel?: boolean | CryptoDeposit$inrConvHistRelArgs<ExtArgs>
    _count?: boolean | CryptoDepositCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CryptoDepositPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CryptoDeposit"
    objects: {
      cryptoWallet: Prisma.$CryptoWalletPayload<ExtArgs> | null
      inrConvHistRel: Prisma.$InrConversionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      accountId: number
      cryptoWalletId: number
      liminalTxnRefId: string
      coin: string
      walletId: number
      timestamp: string
      fee: string | null
      effectiveChange: string | null
      runningBalance: string | null
      externalAddress: string | null
      effectiveChangeUsd: string | null
      wallet: Prisma.JsonValue | null
      tokenContractAddress: string | null
      explorerLink: string | null
      inputs: Prisma.JsonValue[]
      outputs: Prisma.JsonValue[]
      sequenceId: string | null
      type: string | null
      conversionRate: string | null
      isConverted: boolean | null
      conversionTimestamp: Date | null
      inrCreditStatus: $Enums.InrCreditStatus
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["cryptoDeposit"]>
    composites: {}
  }


  type CryptoDepositGetPayload<S extends boolean | null | undefined | CryptoDepositDefaultArgs> = $Result.GetResult<Prisma.$CryptoDepositPayload, S>

  type CryptoDepositCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CryptoDepositFindManyArgs, 'select' | 'include'> & {
      select?: CryptoDepositCountAggregateInputType | true
    }

  export interface CryptoDepositDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoDeposit'], meta: { name: 'CryptoDeposit' } }
    /**
     * Find zero or one CryptoDeposit that matches the filter.
     * @param {CryptoDepositFindUniqueArgs} args - Arguments to find a CryptoDeposit
     * @example
     * // Get one CryptoDeposit
     * const cryptoDeposit = await prisma.cryptoDeposit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CryptoDepositFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoDepositFindUniqueArgs<ExtArgs>>
    ): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CryptoDeposit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CryptoDepositFindUniqueOrThrowArgs} args - Arguments to find a CryptoDeposit
     * @example
     * // Get one CryptoDeposit
     * const cryptoDeposit = await prisma.cryptoDeposit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CryptoDepositFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoDepositFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CryptoDeposit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoDepositFindFirstArgs} args - Arguments to find a CryptoDeposit
     * @example
     * // Get one CryptoDeposit
     * const cryptoDeposit = await prisma.cryptoDeposit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CryptoDepositFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoDepositFindFirstArgs<ExtArgs>>
    ): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CryptoDeposit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoDepositFindFirstOrThrowArgs} args - Arguments to find a CryptoDeposit
     * @example
     * // Get one CryptoDeposit
     * const cryptoDeposit = await prisma.cryptoDeposit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CryptoDepositFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoDepositFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CryptoDeposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoDepositFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoDeposits
     * const cryptoDeposits = await prisma.cryptoDeposit.findMany()
     * 
     * // Get first 10 CryptoDeposits
     * const cryptoDeposits = await prisma.cryptoDeposit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoDepositWithIdOnly = await prisma.cryptoDeposit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CryptoDepositFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoDepositFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CryptoDeposit.
     * @param {CryptoDepositCreateArgs} args - Arguments to create a CryptoDeposit.
     * @example
     * // Create one CryptoDeposit
     * const CryptoDeposit = await prisma.cryptoDeposit.create({
     *   data: {
     *     // ... data to create a CryptoDeposit
     *   }
     * })
     * 
    **/
    create<T extends CryptoDepositCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoDepositCreateArgs<ExtArgs>>
    ): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CryptoDeposits.
     *     @param {CryptoDepositCreateManyArgs} args - Arguments to create many CryptoDeposits.
     *     @example
     *     // Create many CryptoDeposits
     *     const cryptoDeposit = await prisma.cryptoDeposit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CryptoDepositCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoDepositCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CryptoDeposit.
     * @param {CryptoDepositDeleteArgs} args - Arguments to delete one CryptoDeposit.
     * @example
     * // Delete one CryptoDeposit
     * const CryptoDeposit = await prisma.cryptoDeposit.delete({
     *   where: {
     *     // ... filter to delete one CryptoDeposit
     *   }
     * })
     * 
    **/
    delete<T extends CryptoDepositDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoDepositDeleteArgs<ExtArgs>>
    ): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CryptoDeposit.
     * @param {CryptoDepositUpdateArgs} args - Arguments to update one CryptoDeposit.
     * @example
     * // Update one CryptoDeposit
     * const cryptoDeposit = await prisma.cryptoDeposit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CryptoDepositUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoDepositUpdateArgs<ExtArgs>>
    ): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CryptoDeposits.
     * @param {CryptoDepositDeleteManyArgs} args - Arguments to filter CryptoDeposits to delete.
     * @example
     * // Delete a few CryptoDeposits
     * const { count } = await prisma.cryptoDeposit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CryptoDepositDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoDepositDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoDeposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoDepositUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoDeposits
     * const cryptoDeposit = await prisma.cryptoDeposit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CryptoDepositUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoDepositUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoDeposit.
     * @param {CryptoDepositUpsertArgs} args - Arguments to update or create a CryptoDeposit.
     * @example
     * // Update or create a CryptoDeposit
     * const cryptoDeposit = await prisma.cryptoDeposit.upsert({
     *   create: {
     *     // ... data to create a CryptoDeposit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoDeposit we want to update
     *   }
     * })
    **/
    upsert<T extends CryptoDepositUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoDepositUpsertArgs<ExtArgs>>
    ): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CryptoDeposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoDepositCountArgs} args - Arguments to filter CryptoDeposits to count.
     * @example
     * // Count the number of CryptoDeposits
     * const count = await prisma.cryptoDeposit.count({
     *   where: {
     *     // ... the filter for the CryptoDeposits we want to count
     *   }
     * })
    **/
    count<T extends CryptoDepositCountArgs>(
      args?: Subset<T, CryptoDepositCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoDepositCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoDeposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoDepositAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoDepositAggregateArgs>(args: Subset<T, CryptoDepositAggregateArgs>): Prisma.PrismaPromise<GetCryptoDepositAggregateType<T>>

    /**
     * Group by CryptoDeposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoDepositGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoDepositGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoDepositGroupByArgs['orderBy'] }
        : { orderBy?: CryptoDepositGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoDepositGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoDepositGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoDeposit model
   */
  readonly fields: CryptoDepositFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoDeposit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoDepositClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cryptoWallet<T extends CryptoDeposit$cryptoWalletArgs<ExtArgs> = {}>(args?: Subset<T, CryptoDeposit$cryptoWalletArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    inrConvHistRel<T extends CryptoDeposit$inrConvHistRelArgs<ExtArgs> = {}>(args?: Subset<T, CryptoDeposit$inrConvHistRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CryptoDeposit model
   */ 
  interface CryptoDepositFieldRefs {
    readonly id: FieldRef<"CryptoDeposit", 'Int'>
    readonly accountId: FieldRef<"CryptoDeposit", 'Int'>
    readonly cryptoWalletId: FieldRef<"CryptoDeposit", 'Int'>
    readonly liminalTxnRefId: FieldRef<"CryptoDeposit", 'String'>
    readonly coin: FieldRef<"CryptoDeposit", 'String'>
    readonly walletId: FieldRef<"CryptoDeposit", 'Int'>
    readonly timestamp: FieldRef<"CryptoDeposit", 'String'>
    readonly fee: FieldRef<"CryptoDeposit", 'String'>
    readonly effectiveChange: FieldRef<"CryptoDeposit", 'String'>
    readonly runningBalance: FieldRef<"CryptoDeposit", 'String'>
    readonly externalAddress: FieldRef<"CryptoDeposit", 'String'>
    readonly effectiveChangeUsd: FieldRef<"CryptoDeposit", 'String'>
    readonly wallet: FieldRef<"CryptoDeposit", 'Json'>
    readonly tokenContractAddress: FieldRef<"CryptoDeposit", 'String'>
    readonly explorerLink: FieldRef<"CryptoDeposit", 'String'>
    readonly inputs: FieldRef<"CryptoDeposit", 'Json[]'>
    readonly outputs: FieldRef<"CryptoDeposit", 'Json[]'>
    readonly sequenceId: FieldRef<"CryptoDeposit", 'String'>
    readonly type: FieldRef<"CryptoDeposit", 'String'>
    readonly conversionRate: FieldRef<"CryptoDeposit", 'String'>
    readonly isConverted: FieldRef<"CryptoDeposit", 'Boolean'>
    readonly conversionTimestamp: FieldRef<"CryptoDeposit", 'DateTime'>
    readonly inrCreditStatus: FieldRef<"CryptoDeposit", 'InrCreditStatus'>
    readonly createdAt: FieldRef<"CryptoDeposit", 'DateTime'>
    readonly createdBy: FieldRef<"CryptoDeposit", 'Int'>
    readonly updatedAt: FieldRef<"CryptoDeposit", 'DateTime'>
    readonly updatedBy: FieldRef<"CryptoDeposit", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CryptoDeposit findUnique
   */
  export type CryptoDepositFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * Filter, which CryptoDeposit to fetch.
     */
    where: CryptoDepositWhereUniqueInput
  }


  /**
   * CryptoDeposit findUniqueOrThrow
   */
  export type CryptoDepositFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * Filter, which CryptoDeposit to fetch.
     */
    where: CryptoDepositWhereUniqueInput
  }


  /**
   * CryptoDeposit findFirst
   */
  export type CryptoDepositFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * Filter, which CryptoDeposit to fetch.
     */
    where?: CryptoDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoDeposits to fetch.
     */
    orderBy?: CryptoDepositOrderByWithRelationInput | CryptoDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoDeposits.
     */
    cursor?: CryptoDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoDeposits.
     */
    distinct?: CryptoDepositScalarFieldEnum | CryptoDepositScalarFieldEnum[]
  }


  /**
   * CryptoDeposit findFirstOrThrow
   */
  export type CryptoDepositFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * Filter, which CryptoDeposit to fetch.
     */
    where?: CryptoDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoDeposits to fetch.
     */
    orderBy?: CryptoDepositOrderByWithRelationInput | CryptoDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoDeposits.
     */
    cursor?: CryptoDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoDeposits.
     */
    distinct?: CryptoDepositScalarFieldEnum | CryptoDepositScalarFieldEnum[]
  }


  /**
   * CryptoDeposit findMany
   */
  export type CryptoDepositFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * Filter, which CryptoDeposits to fetch.
     */
    where?: CryptoDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoDeposits to fetch.
     */
    orderBy?: CryptoDepositOrderByWithRelationInput | CryptoDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoDeposits.
     */
    cursor?: CryptoDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoDeposits.
     */
    skip?: number
    distinct?: CryptoDepositScalarFieldEnum | CryptoDepositScalarFieldEnum[]
  }


  /**
   * CryptoDeposit create
   */
  export type CryptoDepositCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoDeposit.
     */
    data: XOR<CryptoDepositCreateInput, CryptoDepositUncheckedCreateInput>
  }


  /**
   * CryptoDeposit createMany
   */
  export type CryptoDepositCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoDeposits.
     */
    data: CryptoDepositCreateManyInput | CryptoDepositCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CryptoDeposit update
   */
  export type CryptoDepositUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoDeposit.
     */
    data: XOR<CryptoDepositUpdateInput, CryptoDepositUncheckedUpdateInput>
    /**
     * Choose, which CryptoDeposit to update.
     */
    where: CryptoDepositWhereUniqueInput
  }


  /**
   * CryptoDeposit updateMany
   */
  export type CryptoDepositUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoDeposits.
     */
    data: XOR<CryptoDepositUpdateManyMutationInput, CryptoDepositUncheckedUpdateManyInput>
    /**
     * Filter which CryptoDeposits to update
     */
    where?: CryptoDepositWhereInput
  }


  /**
   * CryptoDeposit upsert
   */
  export type CryptoDepositUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoDeposit to update in case it exists.
     */
    where: CryptoDepositWhereUniqueInput
    /**
     * In case the CryptoDeposit found by the `where` argument doesn't exist, create a new CryptoDeposit with this data.
     */
    create: XOR<CryptoDepositCreateInput, CryptoDepositUncheckedCreateInput>
    /**
     * In case the CryptoDeposit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoDepositUpdateInput, CryptoDepositUncheckedUpdateInput>
  }


  /**
   * CryptoDeposit delete
   */
  export type CryptoDepositDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    /**
     * Filter which CryptoDeposit to delete.
     */
    where: CryptoDepositWhereUniqueInput
  }


  /**
   * CryptoDeposit deleteMany
   */
  export type CryptoDepositDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoDeposits to delete
     */
    where?: CryptoDepositWhereInput
  }


  /**
   * CryptoDeposit.cryptoWallet
   */
  export type CryptoDeposit$cryptoWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    where?: CryptoWalletWhereInput
  }


  /**
   * CryptoDeposit.inrConvHistRel
   */
  export type CryptoDeposit$inrConvHistRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    where?: InrConversionHistoryWhereInput
    orderBy?: InrConversionHistoryOrderByWithRelationInput | InrConversionHistoryOrderByWithRelationInput[]
    cursor?: InrConversionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InrConversionHistoryScalarFieldEnum | InrConversionHistoryScalarFieldEnum[]
  }


  /**
   * CryptoDeposit without action
   */
  export type CryptoDepositDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
  }



  /**
   * Model InrConversionHistory
   */

  export type AggregateInrConversionHistory = {
    _count: InrConversionHistoryCountAggregateOutputType | null
    _avg: InrConversionHistoryAvgAggregateOutputType | null
    _sum: InrConversionHistorySumAggregateOutputType | null
    _min: InrConversionHistoryMinAggregateOutputType | null
    _max: InrConversionHistoryMaxAggregateOutputType | null
  }

  export type InrConversionHistoryAvgAggregateOutputType = {
    id: number | null
    cryptoDepositId: number | null
    accountId: number | null
    baseTokenQuantity: number | null
    inrValue: number | null
    inrValAfterDeduction: number | null
    gst: number | null
    txnFee: number | null
    tds: number | null
    coinConversionRate: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type InrConversionHistorySumAggregateOutputType = {
    id: number | null
    cryptoDepositId: number | null
    accountId: number | null
    baseTokenQuantity: number | null
    inrValue: number | null
    inrValAfterDeduction: number | null
    gst: number | null
    txnFee: number | null
    tds: number | null
    coinConversionRate: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type InrConversionHistoryMinAggregateOutputType = {
    id: number | null
    cryptoDepositId: number | null
    accountId: number | null
    baseToken: string | null
    baseTokenQuantity: number | null
    inrValue: number | null
    inrValAfterDeduction: number | null
    gst: number | null
    txnFee: number | null
    tds: number | null
    coinConversionRate: number | null
    receivingAddress: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type InrConversionHistoryMaxAggregateOutputType = {
    id: number | null
    cryptoDepositId: number | null
    accountId: number | null
    baseToken: string | null
    baseTokenQuantity: number | null
    inrValue: number | null
    inrValAfterDeduction: number | null
    gst: number | null
    txnFee: number | null
    tds: number | null
    coinConversionRate: number | null
    receivingAddress: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type InrConversionHistoryCountAggregateOutputType = {
    id: number
    cryptoDepositId: number
    accountId: number
    baseToken: number
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst: number
    txnFee: number
    tds: number
    coinConversionRate: number
    receivingAddress: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type InrConversionHistoryAvgAggregateInputType = {
    id?: true
    cryptoDepositId?: true
    accountId?: true
    baseTokenQuantity?: true
    inrValue?: true
    inrValAfterDeduction?: true
    gst?: true
    txnFee?: true
    tds?: true
    coinConversionRate?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InrConversionHistorySumAggregateInputType = {
    id?: true
    cryptoDepositId?: true
    accountId?: true
    baseTokenQuantity?: true
    inrValue?: true
    inrValAfterDeduction?: true
    gst?: true
    txnFee?: true
    tds?: true
    coinConversionRate?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InrConversionHistoryMinAggregateInputType = {
    id?: true
    cryptoDepositId?: true
    accountId?: true
    baseToken?: true
    baseTokenQuantity?: true
    inrValue?: true
    inrValAfterDeduction?: true
    gst?: true
    txnFee?: true
    tds?: true
    coinConversionRate?: true
    receivingAddress?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InrConversionHistoryMaxAggregateInputType = {
    id?: true
    cryptoDepositId?: true
    accountId?: true
    baseToken?: true
    baseTokenQuantity?: true
    inrValue?: true
    inrValAfterDeduction?: true
    gst?: true
    txnFee?: true
    tds?: true
    coinConversionRate?: true
    receivingAddress?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InrConversionHistoryCountAggregateInputType = {
    id?: true
    cryptoDepositId?: true
    accountId?: true
    baseToken?: true
    baseTokenQuantity?: true
    inrValue?: true
    inrValAfterDeduction?: true
    gst?: true
    txnFee?: true
    tds?: true
    coinConversionRate?: true
    receivingAddress?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type InrConversionHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InrConversionHistory to aggregate.
     */
    where?: InrConversionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrConversionHistories to fetch.
     */
    orderBy?: InrConversionHistoryOrderByWithRelationInput | InrConversionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InrConversionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrConversionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrConversionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InrConversionHistories
    **/
    _count?: true | InrConversionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InrConversionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InrConversionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InrConversionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InrConversionHistoryMaxAggregateInputType
  }

  export type GetInrConversionHistoryAggregateType<T extends InrConversionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInrConversionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInrConversionHistory[P]>
      : GetScalarType<T[P], AggregateInrConversionHistory[P]>
  }




  export type InrConversionHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InrConversionHistoryWhereInput
    orderBy?: InrConversionHistoryOrderByWithAggregationInput | InrConversionHistoryOrderByWithAggregationInput[]
    by: InrConversionHistoryScalarFieldEnum[] | InrConversionHistoryScalarFieldEnum
    having?: InrConversionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InrConversionHistoryCountAggregateInputType | true
    _avg?: InrConversionHistoryAvgAggregateInputType
    _sum?: InrConversionHistorySumAggregateInputType
    _min?: InrConversionHistoryMinAggregateInputType
    _max?: InrConversionHistoryMaxAggregateInputType
  }

  export type InrConversionHistoryGroupByOutputType = {
    id: number
    cryptoDepositId: number | null
    accountId: number
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst: number | null
    txnFee: number | null
    tds: number | null
    coinConversionRate: number | null
    receivingAddress: string | null
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: InrConversionHistoryCountAggregateOutputType | null
    _avg: InrConversionHistoryAvgAggregateOutputType | null
    _sum: InrConversionHistorySumAggregateOutputType | null
    _min: InrConversionHistoryMinAggregateOutputType | null
    _max: InrConversionHistoryMaxAggregateOutputType | null
  }

  type GetInrConversionHistoryGroupByPayload<T extends InrConversionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InrConversionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InrConversionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InrConversionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], InrConversionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type InrConversionHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cryptoDepositId?: boolean
    accountId?: boolean
    baseToken?: boolean
    baseTokenQuantity?: boolean
    inrValue?: boolean
    inrValAfterDeduction?: boolean
    gst?: boolean
    txnFee?: boolean
    tds?: boolean
    coinConversionRate?: boolean
    receivingAddress?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    cryptoDeposit?: boolean | InrConversionHistory$cryptoDepositArgs<ExtArgs>
    account?: boolean | UserAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inrConversionHistory"]>

  export type InrConversionHistorySelectScalar = {
    id?: boolean
    cryptoDepositId?: boolean
    accountId?: boolean
    baseToken?: boolean
    baseTokenQuantity?: boolean
    inrValue?: boolean
    inrValAfterDeduction?: boolean
    gst?: boolean
    txnFee?: boolean
    tds?: boolean
    coinConversionRate?: boolean
    receivingAddress?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type InrConversionHistoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    cryptoDeposit?: boolean | InrConversionHistory$cryptoDepositArgs<ExtArgs>
    account?: boolean | UserAccountDefaultArgs<ExtArgs>
  }


  export type $InrConversionHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "InrConversionHistory"
    objects: {
      cryptoDeposit: Prisma.$CryptoDepositPayload<ExtArgs> | null
      account: Prisma.$UserAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      cryptoDepositId: number | null
      accountId: number
      baseToken: string
      baseTokenQuantity: number
      inrValue: number
      inrValAfterDeduction: number
      gst: number | null
      txnFee: number | null
      tds: number | null
      coinConversionRate: number | null
      receivingAddress: string | null
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["inrConversionHistory"]>
    composites: {}
  }


  type InrConversionHistoryGetPayload<S extends boolean | null | undefined | InrConversionHistoryDefaultArgs> = $Result.GetResult<Prisma.$InrConversionHistoryPayload, S>

  type InrConversionHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InrConversionHistoryFindManyArgs, 'select' | 'include'> & {
      select?: InrConversionHistoryCountAggregateInputType | true
    }

  export interface InrConversionHistoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InrConversionHistory'], meta: { name: 'InrConversionHistory' } }
    /**
     * Find zero or one InrConversionHistory that matches the filter.
     * @param {InrConversionHistoryFindUniqueArgs} args - Arguments to find a InrConversionHistory
     * @example
     * // Get one InrConversionHistory
     * const inrConversionHistory = await prisma.inrConversionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InrConversionHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InrConversionHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__InrConversionHistoryClient<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InrConversionHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InrConversionHistoryFindUniqueOrThrowArgs} args - Arguments to find a InrConversionHistory
     * @example
     * // Get one InrConversionHistory
     * const inrConversionHistory = await prisma.inrConversionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InrConversionHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InrConversionHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InrConversionHistoryClient<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InrConversionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrConversionHistoryFindFirstArgs} args - Arguments to find a InrConversionHistory
     * @example
     * // Get one InrConversionHistory
     * const inrConversionHistory = await prisma.inrConversionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InrConversionHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InrConversionHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__InrConversionHistoryClient<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InrConversionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrConversionHistoryFindFirstOrThrowArgs} args - Arguments to find a InrConversionHistory
     * @example
     * // Get one InrConversionHistory
     * const inrConversionHistory = await prisma.inrConversionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InrConversionHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InrConversionHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InrConversionHistoryClient<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InrConversionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrConversionHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InrConversionHistories
     * const inrConversionHistories = await prisma.inrConversionHistory.findMany()
     * 
     * // Get first 10 InrConversionHistories
     * const inrConversionHistories = await prisma.inrConversionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inrConversionHistoryWithIdOnly = await prisma.inrConversionHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InrConversionHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrConversionHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InrConversionHistory.
     * @param {InrConversionHistoryCreateArgs} args - Arguments to create a InrConversionHistory.
     * @example
     * // Create one InrConversionHistory
     * const InrConversionHistory = await prisma.inrConversionHistory.create({
     *   data: {
     *     // ... data to create a InrConversionHistory
     *   }
     * })
     * 
    **/
    create<T extends InrConversionHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InrConversionHistoryCreateArgs<ExtArgs>>
    ): Prisma__InrConversionHistoryClient<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InrConversionHistories.
     *     @param {InrConversionHistoryCreateManyArgs} args - Arguments to create many InrConversionHistories.
     *     @example
     *     // Create many InrConversionHistories
     *     const inrConversionHistory = await prisma.inrConversionHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InrConversionHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrConversionHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InrConversionHistory.
     * @param {InrConversionHistoryDeleteArgs} args - Arguments to delete one InrConversionHistory.
     * @example
     * // Delete one InrConversionHistory
     * const InrConversionHistory = await prisma.inrConversionHistory.delete({
     *   where: {
     *     // ... filter to delete one InrConversionHistory
     *   }
     * })
     * 
    **/
    delete<T extends InrConversionHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InrConversionHistoryDeleteArgs<ExtArgs>>
    ): Prisma__InrConversionHistoryClient<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InrConversionHistory.
     * @param {InrConversionHistoryUpdateArgs} args - Arguments to update one InrConversionHistory.
     * @example
     * // Update one InrConversionHistory
     * const inrConversionHistory = await prisma.inrConversionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InrConversionHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InrConversionHistoryUpdateArgs<ExtArgs>>
    ): Prisma__InrConversionHistoryClient<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InrConversionHistories.
     * @param {InrConversionHistoryDeleteManyArgs} args - Arguments to filter InrConversionHistories to delete.
     * @example
     * // Delete a few InrConversionHistories
     * const { count } = await prisma.inrConversionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InrConversionHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrConversionHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InrConversionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrConversionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InrConversionHistories
     * const inrConversionHistory = await prisma.inrConversionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InrConversionHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InrConversionHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InrConversionHistory.
     * @param {InrConversionHistoryUpsertArgs} args - Arguments to update or create a InrConversionHistory.
     * @example
     * // Update or create a InrConversionHistory
     * const inrConversionHistory = await prisma.inrConversionHistory.upsert({
     *   create: {
     *     // ... data to create a InrConversionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InrConversionHistory we want to update
     *   }
     * })
    **/
    upsert<T extends InrConversionHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InrConversionHistoryUpsertArgs<ExtArgs>>
    ): Prisma__InrConversionHistoryClient<$Result.GetResult<Prisma.$InrConversionHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InrConversionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrConversionHistoryCountArgs} args - Arguments to filter InrConversionHistories to count.
     * @example
     * // Count the number of InrConversionHistories
     * const count = await prisma.inrConversionHistory.count({
     *   where: {
     *     // ... the filter for the InrConversionHistories we want to count
     *   }
     * })
    **/
    count<T extends InrConversionHistoryCountArgs>(
      args?: Subset<T, InrConversionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InrConversionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InrConversionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrConversionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InrConversionHistoryAggregateArgs>(args: Subset<T, InrConversionHistoryAggregateArgs>): Prisma.PrismaPromise<GetInrConversionHistoryAggregateType<T>>

    /**
     * Group by InrConversionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrConversionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InrConversionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InrConversionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: InrConversionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InrConversionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInrConversionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InrConversionHistory model
   */
  readonly fields: InrConversionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InrConversionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InrConversionHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cryptoDeposit<T extends InrConversionHistory$cryptoDepositArgs<ExtArgs> = {}>(args?: Subset<T, InrConversionHistory$cryptoDepositArgs<ExtArgs>>): Prisma__CryptoDepositClient<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    account<T extends UserAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAccountDefaultArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InrConversionHistory model
   */ 
  interface InrConversionHistoryFieldRefs {
    readonly id: FieldRef<"InrConversionHistory", 'Int'>
    readonly cryptoDepositId: FieldRef<"InrConversionHistory", 'Int'>
    readonly accountId: FieldRef<"InrConversionHistory", 'Int'>
    readonly baseToken: FieldRef<"InrConversionHistory", 'String'>
    readonly baseTokenQuantity: FieldRef<"InrConversionHistory", 'Float'>
    readonly inrValue: FieldRef<"InrConversionHistory", 'Float'>
    readonly inrValAfterDeduction: FieldRef<"InrConversionHistory", 'Float'>
    readonly gst: FieldRef<"InrConversionHistory", 'Float'>
    readonly txnFee: FieldRef<"InrConversionHistory", 'Float'>
    readonly tds: FieldRef<"InrConversionHistory", 'Float'>
    readonly coinConversionRate: FieldRef<"InrConversionHistory", 'Float'>
    readonly receivingAddress: FieldRef<"InrConversionHistory", 'String'>
    readonly createdAt: FieldRef<"InrConversionHistory", 'DateTime'>
    readonly createdBy: FieldRef<"InrConversionHistory", 'Int'>
    readonly updatedAt: FieldRef<"InrConversionHistory", 'DateTime'>
    readonly updatedBy: FieldRef<"InrConversionHistory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * InrConversionHistory findUnique
   */
  export type InrConversionHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InrConversionHistory to fetch.
     */
    where: InrConversionHistoryWhereUniqueInput
  }


  /**
   * InrConversionHistory findUniqueOrThrow
   */
  export type InrConversionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InrConversionHistory to fetch.
     */
    where: InrConversionHistoryWhereUniqueInput
  }


  /**
   * InrConversionHistory findFirst
   */
  export type InrConversionHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InrConversionHistory to fetch.
     */
    where?: InrConversionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrConversionHistories to fetch.
     */
    orderBy?: InrConversionHistoryOrderByWithRelationInput | InrConversionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InrConversionHistories.
     */
    cursor?: InrConversionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrConversionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrConversionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InrConversionHistories.
     */
    distinct?: InrConversionHistoryScalarFieldEnum | InrConversionHistoryScalarFieldEnum[]
  }


  /**
   * InrConversionHistory findFirstOrThrow
   */
  export type InrConversionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InrConversionHistory to fetch.
     */
    where?: InrConversionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrConversionHistories to fetch.
     */
    orderBy?: InrConversionHistoryOrderByWithRelationInput | InrConversionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InrConversionHistories.
     */
    cursor?: InrConversionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrConversionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrConversionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InrConversionHistories.
     */
    distinct?: InrConversionHistoryScalarFieldEnum | InrConversionHistoryScalarFieldEnum[]
  }


  /**
   * InrConversionHistory findMany
   */
  export type InrConversionHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InrConversionHistories to fetch.
     */
    where?: InrConversionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrConversionHistories to fetch.
     */
    orderBy?: InrConversionHistoryOrderByWithRelationInput | InrConversionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InrConversionHistories.
     */
    cursor?: InrConversionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrConversionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrConversionHistories.
     */
    skip?: number
    distinct?: InrConversionHistoryScalarFieldEnum | InrConversionHistoryScalarFieldEnum[]
  }


  /**
   * InrConversionHistory create
   */
  export type InrConversionHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a InrConversionHistory.
     */
    data: XOR<InrConversionHistoryCreateInput, InrConversionHistoryUncheckedCreateInput>
  }


  /**
   * InrConversionHistory createMany
   */
  export type InrConversionHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InrConversionHistories.
     */
    data: InrConversionHistoryCreateManyInput | InrConversionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InrConversionHistory update
   */
  export type InrConversionHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a InrConversionHistory.
     */
    data: XOR<InrConversionHistoryUpdateInput, InrConversionHistoryUncheckedUpdateInput>
    /**
     * Choose, which InrConversionHistory to update.
     */
    where: InrConversionHistoryWhereUniqueInput
  }


  /**
   * InrConversionHistory updateMany
   */
  export type InrConversionHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InrConversionHistories.
     */
    data: XOR<InrConversionHistoryUpdateManyMutationInput, InrConversionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which InrConversionHistories to update
     */
    where?: InrConversionHistoryWhereInput
  }


  /**
   * InrConversionHistory upsert
   */
  export type InrConversionHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the InrConversionHistory to update in case it exists.
     */
    where: InrConversionHistoryWhereUniqueInput
    /**
     * In case the InrConversionHistory found by the `where` argument doesn't exist, create a new InrConversionHistory with this data.
     */
    create: XOR<InrConversionHistoryCreateInput, InrConversionHistoryUncheckedCreateInput>
    /**
     * In case the InrConversionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InrConversionHistoryUpdateInput, InrConversionHistoryUncheckedUpdateInput>
  }


  /**
   * InrConversionHistory delete
   */
  export type InrConversionHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
    /**
     * Filter which InrConversionHistory to delete.
     */
    where: InrConversionHistoryWhereUniqueInput
  }


  /**
   * InrConversionHistory deleteMany
   */
  export type InrConversionHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InrConversionHistories to delete
     */
    where?: InrConversionHistoryWhereInput
  }


  /**
   * InrConversionHistory.cryptoDeposit
   */
  export type InrConversionHistory$cryptoDepositArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    where?: CryptoDepositWhereInput
  }


  /**
   * InrConversionHistory without action
   */
  export type InrConversionHistoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrConversionHistory
     */
    select?: InrConversionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrConversionHistoryInclude<ExtArgs> | null
  }



  /**
   * Model BankFeed
   */

  export type AggregateBankFeed = {
    _count: BankFeedCountAggregateOutputType | null
    _avg: BankFeedAvgAggregateOutputType | null
    _sum: BankFeedSumAggregateOutputType | null
    _min: BankFeedMinAggregateOutputType | null
    _max: BankFeedMaxAggregateOutputType | null
  }

  export type BankFeedAvgAggregateOutputType = {
    id: number | null
    paymentId: number | null
    serialNumber: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type BankFeedSumAggregateOutputType = {
    id: number | null
    paymentId: number | null
    serialNumber: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type BankFeedMinAggregateOutputType = {
    id: number | null
    paymentId: number | null
    serialNumber: number | null
    amount: string | null
    fee: string | null
    bankName: string | null
    bankRefId: string | null
    processStatus: $Enums.ProcessStatus | null
    userRemarks: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type BankFeedMaxAggregateOutputType = {
    id: number | null
    paymentId: number | null
    serialNumber: number | null
    amount: string | null
    fee: string | null
    bankName: string | null
    bankRefId: string | null
    processStatus: $Enums.ProcessStatus | null
    userRemarks: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type BankFeedCountAggregateOutputType = {
    id: number
    paymentId: number
    serialNumber: number
    amount: number
    fee: number
    bankName: number
    bankRefId: number
    processStatus: number
    userRemarks: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type BankFeedAvgAggregateInputType = {
    id?: true
    paymentId?: true
    serialNumber?: true
    createdBy?: true
    updatedBy?: true
  }

  export type BankFeedSumAggregateInputType = {
    id?: true
    paymentId?: true
    serialNumber?: true
    createdBy?: true
    updatedBy?: true
  }

  export type BankFeedMinAggregateInputType = {
    id?: true
    paymentId?: true
    serialNumber?: true
    amount?: true
    fee?: true
    bankName?: true
    bankRefId?: true
    processStatus?: true
    userRemarks?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type BankFeedMaxAggregateInputType = {
    id?: true
    paymentId?: true
    serialNumber?: true
    amount?: true
    fee?: true
    bankName?: true
    bankRefId?: true
    processStatus?: true
    userRemarks?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type BankFeedCountAggregateInputType = {
    id?: true
    paymentId?: true
    serialNumber?: true
    amount?: true
    fee?: true
    bankName?: true
    bankRefId?: true
    processStatus?: true
    userRemarks?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type BankFeedAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankFeed to aggregate.
     */
    where?: BankFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankFeeds to fetch.
     */
    orderBy?: BankFeedOrderByWithRelationInput | BankFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankFeeds
    **/
    _count?: true | BankFeedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankFeedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankFeedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankFeedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankFeedMaxAggregateInputType
  }

  export type GetBankFeedAggregateType<T extends BankFeedAggregateArgs> = {
        [P in keyof T & keyof AggregateBankFeed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankFeed[P]>
      : GetScalarType<T[P], AggregateBankFeed[P]>
  }




  export type BankFeedGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BankFeedWhereInput
    orderBy?: BankFeedOrderByWithAggregationInput | BankFeedOrderByWithAggregationInput[]
    by: BankFeedScalarFieldEnum[] | BankFeedScalarFieldEnum
    having?: BankFeedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankFeedCountAggregateInputType | true
    _avg?: BankFeedAvgAggregateInputType
    _sum?: BankFeedSumAggregateInputType
    _min?: BankFeedMinAggregateInputType
    _max?: BankFeedMaxAggregateInputType
  }

  export type BankFeedGroupByOutputType = {
    id: number
    paymentId: number | null
    serialNumber: number
    amount: string
    fee: string
    bankName: string
    bankRefId: string
    processStatus: $Enums.ProcessStatus
    userRemarks: string | null
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: BankFeedCountAggregateOutputType | null
    _avg: BankFeedAvgAggregateOutputType | null
    _sum: BankFeedSumAggregateOutputType | null
    _min: BankFeedMinAggregateOutputType | null
    _max: BankFeedMaxAggregateOutputType | null
  }

  type GetBankFeedGroupByPayload<T extends BankFeedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankFeedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankFeedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankFeedGroupByOutputType[P]>
            : GetScalarType<T[P], BankFeedGroupByOutputType[P]>
        }
      >
    >


  export type BankFeedSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    serialNumber?: boolean
    amount?: boolean
    fee?: boolean
    bankName?: boolean
    bankRefId?: boolean
    processStatus?: boolean
    userRemarks?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    fiatPayment?: boolean | BankFeed$fiatPaymentArgs<ExtArgs>
  }, ExtArgs["result"]["bankFeed"]>

  export type BankFeedSelectScalar = {
    id?: boolean
    paymentId?: boolean
    serialNumber?: boolean
    amount?: boolean
    fee?: boolean
    bankName?: boolean
    bankRefId?: boolean
    processStatus?: boolean
    userRemarks?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type BankFeedInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    fiatPayment?: boolean | BankFeed$fiatPaymentArgs<ExtArgs>
  }


  export type $BankFeedPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "BankFeed"
    objects: {
      fiatPayment: Prisma.$FiatPaymentsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      paymentId: number | null
      serialNumber: number
      amount: string
      fee: string
      bankName: string
      bankRefId: string
      processStatus: $Enums.ProcessStatus
      userRemarks: string | null
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["bankFeed"]>
    composites: {}
  }


  type BankFeedGetPayload<S extends boolean | null | undefined | BankFeedDefaultArgs> = $Result.GetResult<Prisma.$BankFeedPayload, S>

  type BankFeedCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BankFeedFindManyArgs, 'select' | 'include'> & {
      select?: BankFeedCountAggregateInputType | true
    }

  export interface BankFeedDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankFeed'], meta: { name: 'BankFeed' } }
    /**
     * Find zero or one BankFeed that matches the filter.
     * @param {BankFeedFindUniqueArgs} args - Arguments to find a BankFeed
     * @example
     * // Get one BankFeed
     * const bankFeed = await prisma.bankFeed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankFeedFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BankFeedFindUniqueArgs<ExtArgs>>
    ): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BankFeed that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BankFeedFindUniqueOrThrowArgs} args - Arguments to find a BankFeed
     * @example
     * // Get one BankFeed
     * const bankFeed = await prisma.bankFeed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankFeedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFeedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BankFeed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFeedFindFirstArgs} args - Arguments to find a BankFeed
     * @example
     * // Get one BankFeed
     * const bankFeed = await prisma.bankFeed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankFeedFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFeedFindFirstArgs<ExtArgs>>
    ): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BankFeed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFeedFindFirstOrThrowArgs} args - Arguments to find a BankFeed
     * @example
     * // Get one BankFeed
     * const bankFeed = await prisma.bankFeed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankFeedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFeedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BankFeeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFeedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankFeeds
     * const bankFeeds = await prisma.bankFeed.findMany()
     * 
     * // Get first 10 BankFeeds
     * const bankFeeds = await prisma.bankFeed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankFeedWithIdOnly = await prisma.bankFeed.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BankFeedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFeedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BankFeed.
     * @param {BankFeedCreateArgs} args - Arguments to create a BankFeed.
     * @example
     * // Create one BankFeed
     * const BankFeed = await prisma.bankFeed.create({
     *   data: {
     *     // ... data to create a BankFeed
     *   }
     * })
     * 
    **/
    create<T extends BankFeedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BankFeedCreateArgs<ExtArgs>>
    ): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BankFeeds.
     *     @param {BankFeedCreateManyArgs} args - Arguments to create many BankFeeds.
     *     @example
     *     // Create many BankFeeds
     *     const bankFeed = await prisma.bankFeed.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BankFeedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFeedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BankFeed.
     * @param {BankFeedDeleteArgs} args - Arguments to delete one BankFeed.
     * @example
     * // Delete one BankFeed
     * const BankFeed = await prisma.bankFeed.delete({
     *   where: {
     *     // ... filter to delete one BankFeed
     *   }
     * })
     * 
    **/
    delete<T extends BankFeedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BankFeedDeleteArgs<ExtArgs>>
    ): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BankFeed.
     * @param {BankFeedUpdateArgs} args - Arguments to update one BankFeed.
     * @example
     * // Update one BankFeed
     * const bankFeed = await prisma.bankFeed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankFeedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BankFeedUpdateArgs<ExtArgs>>
    ): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BankFeeds.
     * @param {BankFeedDeleteManyArgs} args - Arguments to filter BankFeeds to delete.
     * @example
     * // Delete a few BankFeeds
     * const { count } = await prisma.bankFeed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankFeedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFeedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankFeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFeedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankFeeds
     * const bankFeed = await prisma.bankFeed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankFeedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BankFeedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankFeed.
     * @param {BankFeedUpsertArgs} args - Arguments to update or create a BankFeed.
     * @example
     * // Update or create a BankFeed
     * const bankFeed = await prisma.bankFeed.upsert({
     *   create: {
     *     // ... data to create a BankFeed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankFeed we want to update
     *   }
     * })
    **/
    upsert<T extends BankFeedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BankFeedUpsertArgs<ExtArgs>>
    ): Prisma__BankFeedClient<$Result.GetResult<Prisma.$BankFeedPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BankFeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFeedCountArgs} args - Arguments to filter BankFeeds to count.
     * @example
     * // Count the number of BankFeeds
     * const count = await prisma.bankFeed.count({
     *   where: {
     *     // ... the filter for the BankFeeds we want to count
     *   }
     * })
    **/
    count<T extends BankFeedCountArgs>(
      args?: Subset<T, BankFeedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankFeedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankFeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFeedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankFeedAggregateArgs>(args: Subset<T, BankFeedAggregateArgs>): Prisma.PrismaPromise<GetBankFeedAggregateType<T>>

    /**
     * Group by BankFeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFeedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankFeedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankFeedGroupByArgs['orderBy'] }
        : { orderBy?: BankFeedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankFeedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankFeedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankFeed model
   */
  readonly fields: BankFeedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankFeed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankFeedClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fiatPayment<T extends BankFeed$fiatPaymentArgs<ExtArgs> = {}>(args?: Subset<T, BankFeed$fiatPaymentArgs<ExtArgs>>): Prisma__FiatPaymentsClient<$Result.GetResult<Prisma.$FiatPaymentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BankFeed model
   */ 
  interface BankFeedFieldRefs {
    readonly id: FieldRef<"BankFeed", 'Int'>
    readonly paymentId: FieldRef<"BankFeed", 'Int'>
    readonly serialNumber: FieldRef<"BankFeed", 'Int'>
    readonly amount: FieldRef<"BankFeed", 'String'>
    readonly fee: FieldRef<"BankFeed", 'String'>
    readonly bankName: FieldRef<"BankFeed", 'String'>
    readonly bankRefId: FieldRef<"BankFeed", 'String'>
    readonly processStatus: FieldRef<"BankFeed", 'ProcessStatus'>
    readonly userRemarks: FieldRef<"BankFeed", 'String'>
    readonly createdAt: FieldRef<"BankFeed", 'DateTime'>
    readonly createdBy: FieldRef<"BankFeed", 'Int'>
    readonly updatedAt: FieldRef<"BankFeed", 'DateTime'>
    readonly updatedBy: FieldRef<"BankFeed", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BankFeed findUnique
   */
  export type BankFeedFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * Filter, which BankFeed to fetch.
     */
    where: BankFeedWhereUniqueInput
  }


  /**
   * BankFeed findUniqueOrThrow
   */
  export type BankFeedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * Filter, which BankFeed to fetch.
     */
    where: BankFeedWhereUniqueInput
  }


  /**
   * BankFeed findFirst
   */
  export type BankFeedFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * Filter, which BankFeed to fetch.
     */
    where?: BankFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankFeeds to fetch.
     */
    orderBy?: BankFeedOrderByWithRelationInput | BankFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankFeeds.
     */
    cursor?: BankFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankFeeds.
     */
    distinct?: BankFeedScalarFieldEnum | BankFeedScalarFieldEnum[]
  }


  /**
   * BankFeed findFirstOrThrow
   */
  export type BankFeedFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * Filter, which BankFeed to fetch.
     */
    where?: BankFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankFeeds to fetch.
     */
    orderBy?: BankFeedOrderByWithRelationInput | BankFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankFeeds.
     */
    cursor?: BankFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankFeeds.
     */
    distinct?: BankFeedScalarFieldEnum | BankFeedScalarFieldEnum[]
  }


  /**
   * BankFeed findMany
   */
  export type BankFeedFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * Filter, which BankFeeds to fetch.
     */
    where?: BankFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankFeeds to fetch.
     */
    orderBy?: BankFeedOrderByWithRelationInput | BankFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankFeeds.
     */
    cursor?: BankFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankFeeds.
     */
    skip?: number
    distinct?: BankFeedScalarFieldEnum | BankFeedScalarFieldEnum[]
  }


  /**
   * BankFeed create
   */
  export type BankFeedCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * The data needed to create a BankFeed.
     */
    data: XOR<BankFeedCreateInput, BankFeedUncheckedCreateInput>
  }


  /**
   * BankFeed createMany
   */
  export type BankFeedCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankFeeds.
     */
    data: BankFeedCreateManyInput | BankFeedCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BankFeed update
   */
  export type BankFeedUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * The data needed to update a BankFeed.
     */
    data: XOR<BankFeedUpdateInput, BankFeedUncheckedUpdateInput>
    /**
     * Choose, which BankFeed to update.
     */
    where: BankFeedWhereUniqueInput
  }


  /**
   * BankFeed updateMany
   */
  export type BankFeedUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankFeeds.
     */
    data: XOR<BankFeedUpdateManyMutationInput, BankFeedUncheckedUpdateManyInput>
    /**
     * Filter which BankFeeds to update
     */
    where?: BankFeedWhereInput
  }


  /**
   * BankFeed upsert
   */
  export type BankFeedUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * The filter to search for the BankFeed to update in case it exists.
     */
    where: BankFeedWhereUniqueInput
    /**
     * In case the BankFeed found by the `where` argument doesn't exist, create a new BankFeed with this data.
     */
    create: XOR<BankFeedCreateInput, BankFeedUncheckedCreateInput>
    /**
     * In case the BankFeed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankFeedUpdateInput, BankFeedUncheckedUpdateInput>
  }


  /**
   * BankFeed delete
   */
  export type BankFeedDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
    /**
     * Filter which BankFeed to delete.
     */
    where: BankFeedWhereUniqueInput
  }


  /**
   * BankFeed deleteMany
   */
  export type BankFeedDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankFeeds to delete
     */
    where?: BankFeedWhereInput
  }


  /**
   * BankFeed.fiatPayment
   */
  export type BankFeed$fiatPaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiatPayments
     */
    select?: FiatPaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiatPaymentsInclude<ExtArgs> | null
    where?: FiatPaymentsWhereInput
  }


  /**
   * BankFeed without action
   */
  export type BankFeedDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankFeed
     */
    select?: BankFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankFeedInclude<ExtArgs> | null
  }



  /**
   * Model InrLedger
   */

  export type AggregateInrLedger = {
    _count: InrLedgerCountAggregateOutputType | null
    _avg: InrLedgerAvgAggregateOutputType | null
    _sum: InrLedgerSumAggregateOutputType | null
    _min: InrLedgerMinAggregateOutputType | null
    _max: InrLedgerMaxAggregateOutputType | null
  }

  export type InrLedgerAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    change: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type InrLedgerSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    change: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type InrLedgerMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    change: number | null
    operation: $Enums.InrOperation | null
    timestamp: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type InrLedgerMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    change: number | null
    operation: $Enums.InrOperation | null
    timestamp: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type InrLedgerCountAggregateOutputType = {
    id: number
    accountId: number
    change: number
    operation: number
    timestamp: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type InrLedgerAvgAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InrLedgerSumAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InrLedgerMinAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InrLedgerMaxAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InrLedgerCountAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type InrLedgerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InrLedger to aggregate.
     */
    where?: InrLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrLedgers to fetch.
     */
    orderBy?: InrLedgerOrderByWithRelationInput | InrLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InrLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InrLedgers
    **/
    _count?: true | InrLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InrLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InrLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InrLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InrLedgerMaxAggregateInputType
  }

  export type GetInrLedgerAggregateType<T extends InrLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateInrLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInrLedger[P]>
      : GetScalarType<T[P], AggregateInrLedger[P]>
  }




  export type InrLedgerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InrLedgerWhereInput
    orderBy?: InrLedgerOrderByWithAggregationInput | InrLedgerOrderByWithAggregationInput[]
    by: InrLedgerScalarFieldEnum[] | InrLedgerScalarFieldEnum
    having?: InrLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InrLedgerCountAggregateInputType | true
    _avg?: InrLedgerAvgAggregateInputType
    _sum?: InrLedgerSumAggregateInputType
    _min?: InrLedgerMinAggregateInputType
    _max?: InrLedgerMaxAggregateInputType
  }

  export type InrLedgerGroupByOutputType = {
    id: number
    accountId: number
    change: number
    operation: $Enums.InrOperation
    timestamp: Date
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: InrLedgerCountAggregateOutputType | null
    _avg: InrLedgerAvgAggregateOutputType | null
    _sum: InrLedgerSumAggregateOutputType | null
    _min: InrLedgerMinAggregateOutputType | null
    _max: InrLedgerMaxAggregateOutputType | null
  }

  type GetInrLedgerGroupByPayload<T extends InrLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InrLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InrLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InrLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], InrLedgerGroupByOutputType[P]>
        }
      >
    >


  export type InrLedgerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    change?: boolean
    operation?: boolean
    timestamp?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    account?: boolean | InrLedger$accountArgs<ExtArgs>
  }, ExtArgs["result"]["inrLedger"]>

  export type InrLedgerSelectScalar = {
    id?: boolean
    accountId?: boolean
    change?: boolean
    operation?: boolean
    timestamp?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type InrLedgerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    account?: boolean | InrLedger$accountArgs<ExtArgs>
  }


  export type $InrLedgerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "InrLedger"
    objects: {
      account: Prisma.$UserAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      accountId: number
      change: number
      operation: $Enums.InrOperation
      timestamp: Date
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["inrLedger"]>
    composites: {}
  }


  type InrLedgerGetPayload<S extends boolean | null | undefined | InrLedgerDefaultArgs> = $Result.GetResult<Prisma.$InrLedgerPayload, S>

  type InrLedgerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InrLedgerFindManyArgs, 'select' | 'include'> & {
      select?: InrLedgerCountAggregateInputType | true
    }

  export interface InrLedgerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InrLedger'], meta: { name: 'InrLedger' } }
    /**
     * Find zero or one InrLedger that matches the filter.
     * @param {InrLedgerFindUniqueArgs} args - Arguments to find a InrLedger
     * @example
     * // Get one InrLedger
     * const inrLedger = await prisma.inrLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InrLedgerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InrLedgerFindUniqueArgs<ExtArgs>>
    ): Prisma__InrLedgerClient<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InrLedger that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InrLedgerFindUniqueOrThrowArgs} args - Arguments to find a InrLedger
     * @example
     * // Get one InrLedger
     * const inrLedger = await prisma.inrLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InrLedgerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InrLedgerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InrLedgerClient<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InrLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrLedgerFindFirstArgs} args - Arguments to find a InrLedger
     * @example
     * // Get one InrLedger
     * const inrLedger = await prisma.inrLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InrLedgerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InrLedgerFindFirstArgs<ExtArgs>>
    ): Prisma__InrLedgerClient<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InrLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrLedgerFindFirstOrThrowArgs} args - Arguments to find a InrLedger
     * @example
     * // Get one InrLedger
     * const inrLedger = await prisma.inrLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InrLedgerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InrLedgerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InrLedgerClient<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InrLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrLedgerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InrLedgers
     * const inrLedgers = await prisma.inrLedger.findMany()
     * 
     * // Get first 10 InrLedgers
     * const inrLedgers = await prisma.inrLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inrLedgerWithIdOnly = await prisma.inrLedger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InrLedgerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrLedgerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InrLedger.
     * @param {InrLedgerCreateArgs} args - Arguments to create a InrLedger.
     * @example
     * // Create one InrLedger
     * const InrLedger = await prisma.inrLedger.create({
     *   data: {
     *     // ... data to create a InrLedger
     *   }
     * })
     * 
    **/
    create<T extends InrLedgerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InrLedgerCreateArgs<ExtArgs>>
    ): Prisma__InrLedgerClient<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InrLedgers.
     *     @param {InrLedgerCreateManyArgs} args - Arguments to create many InrLedgers.
     *     @example
     *     // Create many InrLedgers
     *     const inrLedger = await prisma.inrLedger.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InrLedgerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrLedgerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InrLedger.
     * @param {InrLedgerDeleteArgs} args - Arguments to delete one InrLedger.
     * @example
     * // Delete one InrLedger
     * const InrLedger = await prisma.inrLedger.delete({
     *   where: {
     *     // ... filter to delete one InrLedger
     *   }
     * })
     * 
    **/
    delete<T extends InrLedgerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InrLedgerDeleteArgs<ExtArgs>>
    ): Prisma__InrLedgerClient<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InrLedger.
     * @param {InrLedgerUpdateArgs} args - Arguments to update one InrLedger.
     * @example
     * // Update one InrLedger
     * const inrLedger = await prisma.inrLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InrLedgerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InrLedgerUpdateArgs<ExtArgs>>
    ): Prisma__InrLedgerClient<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InrLedgers.
     * @param {InrLedgerDeleteManyArgs} args - Arguments to filter InrLedgers to delete.
     * @example
     * // Delete a few InrLedgers
     * const { count } = await prisma.inrLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InrLedgerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrLedgerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InrLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InrLedgers
     * const inrLedger = await prisma.inrLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InrLedgerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InrLedgerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InrLedger.
     * @param {InrLedgerUpsertArgs} args - Arguments to update or create a InrLedger.
     * @example
     * // Update or create a InrLedger
     * const inrLedger = await prisma.inrLedger.upsert({
     *   create: {
     *     // ... data to create a InrLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InrLedger we want to update
     *   }
     * })
    **/
    upsert<T extends InrLedgerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InrLedgerUpsertArgs<ExtArgs>>
    ): Prisma__InrLedgerClient<$Result.GetResult<Prisma.$InrLedgerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InrLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrLedgerCountArgs} args - Arguments to filter InrLedgers to count.
     * @example
     * // Count the number of InrLedgers
     * const count = await prisma.inrLedger.count({
     *   where: {
     *     // ... the filter for the InrLedgers we want to count
     *   }
     * })
    **/
    count<T extends InrLedgerCountArgs>(
      args?: Subset<T, InrLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InrLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InrLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InrLedgerAggregateArgs>(args: Subset<T, InrLedgerAggregateArgs>): Prisma.PrismaPromise<GetInrLedgerAggregateType<T>>

    /**
     * Group by InrLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InrLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InrLedgerGroupByArgs['orderBy'] }
        : { orderBy?: InrLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InrLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInrLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InrLedger model
   */
  readonly fields: InrLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InrLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InrLedgerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends InrLedger$accountArgs<ExtArgs> = {}>(args?: Subset<T, InrLedger$accountArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InrLedger model
   */ 
  interface InrLedgerFieldRefs {
    readonly id: FieldRef<"InrLedger", 'Int'>
    readonly accountId: FieldRef<"InrLedger", 'Int'>
    readonly change: FieldRef<"InrLedger", 'Float'>
    readonly operation: FieldRef<"InrLedger", 'InrOperation'>
    readonly timestamp: FieldRef<"InrLedger", 'DateTime'>
    readonly createdAt: FieldRef<"InrLedger", 'DateTime'>
    readonly createdBy: FieldRef<"InrLedger", 'Int'>
    readonly updatedAt: FieldRef<"InrLedger", 'DateTime'>
    readonly updatedBy: FieldRef<"InrLedger", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * InrLedger findUnique
   */
  export type InrLedgerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InrLedger to fetch.
     */
    where: InrLedgerWhereUniqueInput
  }


  /**
   * InrLedger findUniqueOrThrow
   */
  export type InrLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InrLedger to fetch.
     */
    where: InrLedgerWhereUniqueInput
  }


  /**
   * InrLedger findFirst
   */
  export type InrLedgerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InrLedger to fetch.
     */
    where?: InrLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrLedgers to fetch.
     */
    orderBy?: InrLedgerOrderByWithRelationInput | InrLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InrLedgers.
     */
    cursor?: InrLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InrLedgers.
     */
    distinct?: InrLedgerScalarFieldEnum | InrLedgerScalarFieldEnum[]
  }


  /**
   * InrLedger findFirstOrThrow
   */
  export type InrLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InrLedger to fetch.
     */
    where?: InrLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrLedgers to fetch.
     */
    orderBy?: InrLedgerOrderByWithRelationInput | InrLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InrLedgers.
     */
    cursor?: InrLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InrLedgers.
     */
    distinct?: InrLedgerScalarFieldEnum | InrLedgerScalarFieldEnum[]
  }


  /**
   * InrLedger findMany
   */
  export type InrLedgerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InrLedgers to fetch.
     */
    where?: InrLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrLedgers to fetch.
     */
    orderBy?: InrLedgerOrderByWithRelationInput | InrLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InrLedgers.
     */
    cursor?: InrLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrLedgers.
     */
    skip?: number
    distinct?: InrLedgerScalarFieldEnum | InrLedgerScalarFieldEnum[]
  }


  /**
   * InrLedger create
   */
  export type InrLedgerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a InrLedger.
     */
    data: XOR<InrLedgerCreateInput, InrLedgerUncheckedCreateInput>
  }


  /**
   * InrLedger createMany
   */
  export type InrLedgerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InrLedgers.
     */
    data: InrLedgerCreateManyInput | InrLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InrLedger update
   */
  export type InrLedgerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a InrLedger.
     */
    data: XOR<InrLedgerUpdateInput, InrLedgerUncheckedUpdateInput>
    /**
     * Choose, which InrLedger to update.
     */
    where: InrLedgerWhereUniqueInput
  }


  /**
   * InrLedger updateMany
   */
  export type InrLedgerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InrLedgers.
     */
    data: XOR<InrLedgerUpdateManyMutationInput, InrLedgerUncheckedUpdateManyInput>
    /**
     * Filter which InrLedgers to update
     */
    where?: InrLedgerWhereInput
  }


  /**
   * InrLedger upsert
   */
  export type InrLedgerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the InrLedger to update in case it exists.
     */
    where: InrLedgerWhereUniqueInput
    /**
     * In case the InrLedger found by the `where` argument doesn't exist, create a new InrLedger with this data.
     */
    create: XOR<InrLedgerCreateInput, InrLedgerUncheckedCreateInput>
    /**
     * In case the InrLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InrLedgerUpdateInput, InrLedgerUncheckedUpdateInput>
  }


  /**
   * InrLedger delete
   */
  export type InrLedgerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
    /**
     * Filter which InrLedger to delete.
     */
    where: InrLedgerWhereUniqueInput
  }


  /**
   * InrLedger deleteMany
   */
  export type InrLedgerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InrLedgers to delete
     */
    where?: InrLedgerWhereInput
  }


  /**
   * InrLedger.account
   */
  export type InrLedger$accountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
  }


  /**
   * InrLedger without action
   */
  export type InrLedgerDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrLedger
     */
    select?: InrLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrLedgerInclude<ExtArgs> | null
  }



  /**
   * Model CryptoLedger
   */

  export type AggregateCryptoLedger = {
    _count: CryptoLedgerCountAggregateOutputType | null
    _avg: CryptoLedgerAvgAggregateOutputType | null
    _sum: CryptoLedgerSumAggregateOutputType | null
    _min: CryptoLedgerMinAggregateOutputType | null
    _max: CryptoLedgerMaxAggregateOutputType | null
  }

  export type CryptoLedgerAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    change: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CryptoLedgerSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    change: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CryptoLedgerMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    coin: string | null
    change: number | null
    operation: $Enums.CryptoOperation | null
    timestamp: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CryptoLedgerMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    coin: string | null
    change: number | null
    operation: $Enums.CryptoOperation | null
    timestamp: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CryptoLedgerCountAggregateOutputType = {
    id: number
    accountId: number
    coin: number
    change: number
    operation: number
    timestamp: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type CryptoLedgerAvgAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CryptoLedgerSumAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CryptoLedgerMinAggregateInputType = {
    id?: true
    accountId?: true
    coin?: true
    change?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CryptoLedgerMaxAggregateInputType = {
    id?: true
    accountId?: true
    coin?: true
    change?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CryptoLedgerCountAggregateInputType = {
    id?: true
    accountId?: true
    coin?: true
    change?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type CryptoLedgerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoLedger to aggregate.
     */
    where?: CryptoLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoLedgers to fetch.
     */
    orderBy?: CryptoLedgerOrderByWithRelationInput | CryptoLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoLedgers
    **/
    _count?: true | CryptoLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoLedgerMaxAggregateInputType
  }

  export type GetCryptoLedgerAggregateType<T extends CryptoLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoLedger[P]>
      : GetScalarType<T[P], AggregateCryptoLedger[P]>
  }




  export type CryptoLedgerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CryptoLedgerWhereInput
    orderBy?: CryptoLedgerOrderByWithAggregationInput | CryptoLedgerOrderByWithAggregationInput[]
    by: CryptoLedgerScalarFieldEnum[] | CryptoLedgerScalarFieldEnum
    having?: CryptoLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoLedgerCountAggregateInputType | true
    _avg?: CryptoLedgerAvgAggregateInputType
    _sum?: CryptoLedgerSumAggregateInputType
    _min?: CryptoLedgerMinAggregateInputType
    _max?: CryptoLedgerMaxAggregateInputType
  }

  export type CryptoLedgerGroupByOutputType = {
    id: number
    accountId: number
    coin: string
    change: number
    operation: $Enums.CryptoOperation
    timestamp: Date
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: CryptoLedgerCountAggregateOutputType | null
    _avg: CryptoLedgerAvgAggregateOutputType | null
    _sum: CryptoLedgerSumAggregateOutputType | null
    _min: CryptoLedgerMinAggregateOutputType | null
    _max: CryptoLedgerMaxAggregateOutputType | null
  }

  type GetCryptoLedgerGroupByPayload<T extends CryptoLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoLedgerGroupByOutputType[P]>
        }
      >
    >


  export type CryptoLedgerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    coin?: boolean
    change?: boolean
    operation?: boolean
    timestamp?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    account?: boolean | CryptoLedger$accountArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoLedger"]>

  export type CryptoLedgerSelectScalar = {
    id?: boolean
    accountId?: boolean
    coin?: boolean
    change?: boolean
    operation?: boolean
    timestamp?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type CryptoLedgerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    account?: boolean | CryptoLedger$accountArgs<ExtArgs>
  }


  export type $CryptoLedgerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CryptoLedger"
    objects: {
      account: Prisma.$UserAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      accountId: number
      coin: string
      change: number
      operation: $Enums.CryptoOperation
      timestamp: Date
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["cryptoLedger"]>
    composites: {}
  }


  type CryptoLedgerGetPayload<S extends boolean | null | undefined | CryptoLedgerDefaultArgs> = $Result.GetResult<Prisma.$CryptoLedgerPayload, S>

  type CryptoLedgerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CryptoLedgerFindManyArgs, 'select' | 'include'> & {
      select?: CryptoLedgerCountAggregateInputType | true
    }

  export interface CryptoLedgerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoLedger'], meta: { name: 'CryptoLedger' } }
    /**
     * Find zero or one CryptoLedger that matches the filter.
     * @param {CryptoLedgerFindUniqueArgs} args - Arguments to find a CryptoLedger
     * @example
     * // Get one CryptoLedger
     * const cryptoLedger = await prisma.cryptoLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CryptoLedgerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoLedgerFindUniqueArgs<ExtArgs>>
    ): Prisma__CryptoLedgerClient<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CryptoLedger that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CryptoLedgerFindUniqueOrThrowArgs} args - Arguments to find a CryptoLedger
     * @example
     * // Get one CryptoLedger
     * const cryptoLedger = await prisma.cryptoLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CryptoLedgerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoLedgerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CryptoLedgerClient<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CryptoLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLedgerFindFirstArgs} args - Arguments to find a CryptoLedger
     * @example
     * // Get one CryptoLedger
     * const cryptoLedger = await prisma.cryptoLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CryptoLedgerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoLedgerFindFirstArgs<ExtArgs>>
    ): Prisma__CryptoLedgerClient<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CryptoLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLedgerFindFirstOrThrowArgs} args - Arguments to find a CryptoLedger
     * @example
     * // Get one CryptoLedger
     * const cryptoLedger = await prisma.cryptoLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CryptoLedgerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoLedgerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CryptoLedgerClient<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CryptoLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLedgerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoLedgers
     * const cryptoLedgers = await prisma.cryptoLedger.findMany()
     * 
     * // Get first 10 CryptoLedgers
     * const cryptoLedgers = await prisma.cryptoLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoLedgerWithIdOnly = await prisma.cryptoLedger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CryptoLedgerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoLedgerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CryptoLedger.
     * @param {CryptoLedgerCreateArgs} args - Arguments to create a CryptoLedger.
     * @example
     * // Create one CryptoLedger
     * const CryptoLedger = await prisma.cryptoLedger.create({
     *   data: {
     *     // ... data to create a CryptoLedger
     *   }
     * })
     * 
    **/
    create<T extends CryptoLedgerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoLedgerCreateArgs<ExtArgs>>
    ): Prisma__CryptoLedgerClient<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CryptoLedgers.
     *     @param {CryptoLedgerCreateManyArgs} args - Arguments to create many CryptoLedgers.
     *     @example
     *     // Create many CryptoLedgers
     *     const cryptoLedger = await prisma.cryptoLedger.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CryptoLedgerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoLedgerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CryptoLedger.
     * @param {CryptoLedgerDeleteArgs} args - Arguments to delete one CryptoLedger.
     * @example
     * // Delete one CryptoLedger
     * const CryptoLedger = await prisma.cryptoLedger.delete({
     *   where: {
     *     // ... filter to delete one CryptoLedger
     *   }
     * })
     * 
    **/
    delete<T extends CryptoLedgerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoLedgerDeleteArgs<ExtArgs>>
    ): Prisma__CryptoLedgerClient<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CryptoLedger.
     * @param {CryptoLedgerUpdateArgs} args - Arguments to update one CryptoLedger.
     * @example
     * // Update one CryptoLedger
     * const cryptoLedger = await prisma.cryptoLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CryptoLedgerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoLedgerUpdateArgs<ExtArgs>>
    ): Prisma__CryptoLedgerClient<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CryptoLedgers.
     * @param {CryptoLedgerDeleteManyArgs} args - Arguments to filter CryptoLedgers to delete.
     * @example
     * // Delete a few CryptoLedgers
     * const { count } = await prisma.cryptoLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CryptoLedgerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoLedgerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoLedgers
     * const cryptoLedger = await prisma.cryptoLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CryptoLedgerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoLedgerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoLedger.
     * @param {CryptoLedgerUpsertArgs} args - Arguments to update or create a CryptoLedger.
     * @example
     * // Update or create a CryptoLedger
     * const cryptoLedger = await prisma.cryptoLedger.upsert({
     *   create: {
     *     // ... data to create a CryptoLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoLedger we want to update
     *   }
     * })
    **/
    upsert<T extends CryptoLedgerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoLedgerUpsertArgs<ExtArgs>>
    ): Prisma__CryptoLedgerClient<$Result.GetResult<Prisma.$CryptoLedgerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CryptoLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLedgerCountArgs} args - Arguments to filter CryptoLedgers to count.
     * @example
     * // Count the number of CryptoLedgers
     * const count = await prisma.cryptoLedger.count({
     *   where: {
     *     // ... the filter for the CryptoLedgers we want to count
     *   }
     * })
    **/
    count<T extends CryptoLedgerCountArgs>(
      args?: Subset<T, CryptoLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoLedgerAggregateArgs>(args: Subset<T, CryptoLedgerAggregateArgs>): Prisma.PrismaPromise<GetCryptoLedgerAggregateType<T>>

    /**
     * Group by CryptoLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoLedgerGroupByArgs['orderBy'] }
        : { orderBy?: CryptoLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoLedger model
   */
  readonly fields: CryptoLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoLedgerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends CryptoLedger$accountArgs<ExtArgs> = {}>(args?: Subset<T, CryptoLedger$accountArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CryptoLedger model
   */ 
  interface CryptoLedgerFieldRefs {
    readonly id: FieldRef<"CryptoLedger", 'Int'>
    readonly accountId: FieldRef<"CryptoLedger", 'Int'>
    readonly coin: FieldRef<"CryptoLedger", 'String'>
    readonly change: FieldRef<"CryptoLedger", 'Float'>
    readonly operation: FieldRef<"CryptoLedger", 'CryptoOperation'>
    readonly timestamp: FieldRef<"CryptoLedger", 'DateTime'>
    readonly createdAt: FieldRef<"CryptoLedger", 'DateTime'>
    readonly createdBy: FieldRef<"CryptoLedger", 'Int'>
    readonly updatedAt: FieldRef<"CryptoLedger", 'DateTime'>
    readonly updatedBy: FieldRef<"CryptoLedger", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CryptoLedger findUnique
   */
  export type CryptoLedgerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLedger to fetch.
     */
    where: CryptoLedgerWhereUniqueInput
  }


  /**
   * CryptoLedger findUniqueOrThrow
   */
  export type CryptoLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLedger to fetch.
     */
    where: CryptoLedgerWhereUniqueInput
  }


  /**
   * CryptoLedger findFirst
   */
  export type CryptoLedgerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLedger to fetch.
     */
    where?: CryptoLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoLedgers to fetch.
     */
    orderBy?: CryptoLedgerOrderByWithRelationInput | CryptoLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoLedgers.
     */
    cursor?: CryptoLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoLedgers.
     */
    distinct?: CryptoLedgerScalarFieldEnum | CryptoLedgerScalarFieldEnum[]
  }


  /**
   * CryptoLedger findFirstOrThrow
   */
  export type CryptoLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLedger to fetch.
     */
    where?: CryptoLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoLedgers to fetch.
     */
    orderBy?: CryptoLedgerOrderByWithRelationInput | CryptoLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoLedgers.
     */
    cursor?: CryptoLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoLedgers.
     */
    distinct?: CryptoLedgerScalarFieldEnum | CryptoLedgerScalarFieldEnum[]
  }


  /**
   * CryptoLedger findMany
   */
  export type CryptoLedgerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLedgers to fetch.
     */
    where?: CryptoLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoLedgers to fetch.
     */
    orderBy?: CryptoLedgerOrderByWithRelationInput | CryptoLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoLedgers.
     */
    cursor?: CryptoLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoLedgers.
     */
    skip?: number
    distinct?: CryptoLedgerScalarFieldEnum | CryptoLedgerScalarFieldEnum[]
  }


  /**
   * CryptoLedger create
   */
  export type CryptoLedgerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoLedger.
     */
    data: XOR<CryptoLedgerCreateInput, CryptoLedgerUncheckedCreateInput>
  }


  /**
   * CryptoLedger createMany
   */
  export type CryptoLedgerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoLedgers.
     */
    data: CryptoLedgerCreateManyInput | CryptoLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CryptoLedger update
   */
  export type CryptoLedgerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoLedger.
     */
    data: XOR<CryptoLedgerUpdateInput, CryptoLedgerUncheckedUpdateInput>
    /**
     * Choose, which CryptoLedger to update.
     */
    where: CryptoLedgerWhereUniqueInput
  }


  /**
   * CryptoLedger updateMany
   */
  export type CryptoLedgerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoLedgers.
     */
    data: XOR<CryptoLedgerUpdateManyMutationInput, CryptoLedgerUncheckedUpdateManyInput>
    /**
     * Filter which CryptoLedgers to update
     */
    where?: CryptoLedgerWhereInput
  }


  /**
   * CryptoLedger upsert
   */
  export type CryptoLedgerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoLedger to update in case it exists.
     */
    where: CryptoLedgerWhereUniqueInput
    /**
     * In case the CryptoLedger found by the `where` argument doesn't exist, create a new CryptoLedger with this data.
     */
    create: XOR<CryptoLedgerCreateInput, CryptoLedgerUncheckedCreateInput>
    /**
     * In case the CryptoLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoLedgerUpdateInput, CryptoLedgerUncheckedUpdateInput>
  }


  /**
   * CryptoLedger delete
   */
  export type CryptoLedgerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
    /**
     * Filter which CryptoLedger to delete.
     */
    where: CryptoLedgerWhereUniqueInput
  }


  /**
   * CryptoLedger deleteMany
   */
  export type CryptoLedgerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoLedgers to delete
     */
    where?: CryptoLedgerWhereInput
  }


  /**
   * CryptoLedger.account
   */
  export type CryptoLedger$accountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
  }


  /**
   * CryptoLedger without action
   */
  export type CryptoLedgerDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLedger
     */
    select?: CryptoLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoLedgerInclude<ExtArgs> | null
  }



  /**
   * Model TradeLedger
   */

  export type AggregateTradeLedger = {
    _count: TradeLedgerCountAggregateOutputType | null
    _avg: TradeLedgerAvgAggregateOutputType | null
    _sum: TradeLedgerSumAggregateOutputType | null
    _min: TradeLedgerMinAggregateOutputType | null
    _max: TradeLedgerMaxAggregateOutputType | null
  }

  export type TradeLedgerAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type TradeLedgerSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type TradeLedgerMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    change: string | null
    tradeId: string | null
    positionType: $Enums.PositionType | null
    operation: $Enums.TradeOperation | null
    timestamp: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type TradeLedgerMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    change: string | null
    tradeId: string | null
    positionType: $Enums.PositionType | null
    operation: $Enums.TradeOperation | null
    timestamp: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type TradeLedgerCountAggregateOutputType = {
    id: number
    accountId: number
    change: number
    tradeId: number
    positionType: number
    operation: number
    timestamp: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type TradeLedgerAvgAggregateInputType = {
    id?: true
    accountId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type TradeLedgerSumAggregateInputType = {
    id?: true
    accountId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type TradeLedgerMinAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    tradeId?: true
    positionType?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TradeLedgerMaxAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    tradeId?: true
    positionType?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TradeLedgerCountAggregateInputType = {
    id?: true
    accountId?: true
    change?: true
    tradeId?: true
    positionType?: true
    operation?: true
    timestamp?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type TradeLedgerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeLedger to aggregate.
     */
    where?: TradeLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeLedgers to fetch.
     */
    orderBy?: TradeLedgerOrderByWithRelationInput | TradeLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeLedgers
    **/
    _count?: true | TradeLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeLedgerMaxAggregateInputType
  }

  export type GetTradeLedgerAggregateType<T extends TradeLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeLedger[P]>
      : GetScalarType<T[P], AggregateTradeLedger[P]>
  }




  export type TradeLedgerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TradeLedgerWhereInput
    orderBy?: TradeLedgerOrderByWithAggregationInput | TradeLedgerOrderByWithAggregationInput[]
    by: TradeLedgerScalarFieldEnum[] | TradeLedgerScalarFieldEnum
    having?: TradeLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeLedgerCountAggregateInputType | true
    _avg?: TradeLedgerAvgAggregateInputType
    _sum?: TradeLedgerSumAggregateInputType
    _min?: TradeLedgerMinAggregateInputType
    _max?: TradeLedgerMaxAggregateInputType
  }

  export type TradeLedgerGroupByOutputType = {
    id: number
    accountId: number
    change: string
    tradeId: string
    positionType: $Enums.PositionType
    operation: $Enums.TradeOperation
    timestamp: Date
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: TradeLedgerCountAggregateOutputType | null
    _avg: TradeLedgerAvgAggregateOutputType | null
    _sum: TradeLedgerSumAggregateOutputType | null
    _min: TradeLedgerMinAggregateOutputType | null
    _max: TradeLedgerMaxAggregateOutputType | null
  }

  type GetTradeLedgerGroupByPayload<T extends TradeLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], TradeLedgerGroupByOutputType[P]>
        }
      >
    >


  export type TradeLedgerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    change?: boolean
    tradeId?: boolean
    positionType?: boolean
    operation?: boolean
    timestamp?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    account?: boolean | TradeLedger$accountArgs<ExtArgs>
  }, ExtArgs["result"]["tradeLedger"]>

  export type TradeLedgerSelectScalar = {
    id?: boolean
    accountId?: boolean
    change?: boolean
    tradeId?: boolean
    positionType?: boolean
    operation?: boolean
    timestamp?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type TradeLedgerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    account?: boolean | TradeLedger$accountArgs<ExtArgs>
  }


  export type $TradeLedgerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "TradeLedger"
    objects: {
      account: Prisma.$UserAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      accountId: number
      change: string
      tradeId: string
      positionType: $Enums.PositionType
      operation: $Enums.TradeOperation
      timestamp: Date
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["tradeLedger"]>
    composites: {}
  }


  type TradeLedgerGetPayload<S extends boolean | null | undefined | TradeLedgerDefaultArgs> = $Result.GetResult<Prisma.$TradeLedgerPayload, S>

  type TradeLedgerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TradeLedgerFindManyArgs, 'select' | 'include'> & {
      select?: TradeLedgerCountAggregateInputType | true
    }

  export interface TradeLedgerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeLedger'], meta: { name: 'TradeLedger' } }
    /**
     * Find zero or one TradeLedger that matches the filter.
     * @param {TradeLedgerFindUniqueArgs} args - Arguments to find a TradeLedger
     * @example
     * // Get one TradeLedger
     * const tradeLedger = await prisma.tradeLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TradeLedgerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TradeLedgerFindUniqueArgs<ExtArgs>>
    ): Prisma__TradeLedgerClient<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TradeLedger that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TradeLedgerFindUniqueOrThrowArgs} args - Arguments to find a TradeLedger
     * @example
     * // Get one TradeLedger
     * const tradeLedger = await prisma.tradeLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TradeLedgerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TradeLedgerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TradeLedgerClient<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TradeLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLedgerFindFirstArgs} args - Arguments to find a TradeLedger
     * @example
     * // Get one TradeLedger
     * const tradeLedger = await prisma.tradeLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TradeLedgerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TradeLedgerFindFirstArgs<ExtArgs>>
    ): Prisma__TradeLedgerClient<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TradeLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLedgerFindFirstOrThrowArgs} args - Arguments to find a TradeLedger
     * @example
     * // Get one TradeLedger
     * const tradeLedger = await prisma.tradeLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TradeLedgerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TradeLedgerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TradeLedgerClient<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TradeLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLedgerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeLedgers
     * const tradeLedgers = await prisma.tradeLedger.findMany()
     * 
     * // Get first 10 TradeLedgers
     * const tradeLedgers = await prisma.tradeLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeLedgerWithIdOnly = await prisma.tradeLedger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TradeLedgerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TradeLedgerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TradeLedger.
     * @param {TradeLedgerCreateArgs} args - Arguments to create a TradeLedger.
     * @example
     * // Create one TradeLedger
     * const TradeLedger = await prisma.tradeLedger.create({
     *   data: {
     *     // ... data to create a TradeLedger
     *   }
     * })
     * 
    **/
    create<T extends TradeLedgerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TradeLedgerCreateArgs<ExtArgs>>
    ): Prisma__TradeLedgerClient<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TradeLedgers.
     *     @param {TradeLedgerCreateManyArgs} args - Arguments to create many TradeLedgers.
     *     @example
     *     // Create many TradeLedgers
     *     const tradeLedger = await prisma.tradeLedger.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TradeLedgerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TradeLedgerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TradeLedger.
     * @param {TradeLedgerDeleteArgs} args - Arguments to delete one TradeLedger.
     * @example
     * // Delete one TradeLedger
     * const TradeLedger = await prisma.tradeLedger.delete({
     *   where: {
     *     // ... filter to delete one TradeLedger
     *   }
     * })
     * 
    **/
    delete<T extends TradeLedgerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TradeLedgerDeleteArgs<ExtArgs>>
    ): Prisma__TradeLedgerClient<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TradeLedger.
     * @param {TradeLedgerUpdateArgs} args - Arguments to update one TradeLedger.
     * @example
     * // Update one TradeLedger
     * const tradeLedger = await prisma.tradeLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TradeLedgerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TradeLedgerUpdateArgs<ExtArgs>>
    ): Prisma__TradeLedgerClient<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TradeLedgers.
     * @param {TradeLedgerDeleteManyArgs} args - Arguments to filter TradeLedgers to delete.
     * @example
     * // Delete a few TradeLedgers
     * const { count } = await prisma.tradeLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TradeLedgerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TradeLedgerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeLedgers
     * const tradeLedger = await prisma.tradeLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TradeLedgerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TradeLedgerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TradeLedger.
     * @param {TradeLedgerUpsertArgs} args - Arguments to update or create a TradeLedger.
     * @example
     * // Update or create a TradeLedger
     * const tradeLedger = await prisma.tradeLedger.upsert({
     *   create: {
     *     // ... data to create a TradeLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeLedger we want to update
     *   }
     * })
    **/
    upsert<T extends TradeLedgerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TradeLedgerUpsertArgs<ExtArgs>>
    ): Prisma__TradeLedgerClient<$Result.GetResult<Prisma.$TradeLedgerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TradeLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLedgerCountArgs} args - Arguments to filter TradeLedgers to count.
     * @example
     * // Count the number of TradeLedgers
     * const count = await prisma.tradeLedger.count({
     *   where: {
     *     // ... the filter for the TradeLedgers we want to count
     *   }
     * })
    **/
    count<T extends TradeLedgerCountArgs>(
      args?: Subset<T, TradeLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeLedgerAggregateArgs>(args: Subset<T, TradeLedgerAggregateArgs>): Prisma.PrismaPromise<GetTradeLedgerAggregateType<T>>

    /**
     * Group by TradeLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeLedgerGroupByArgs['orderBy'] }
        : { orderBy?: TradeLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeLedger model
   */
  readonly fields: TradeLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeLedgerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends TradeLedger$accountArgs<ExtArgs> = {}>(args?: Subset<T, TradeLedger$accountArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TradeLedger model
   */ 
  interface TradeLedgerFieldRefs {
    readonly id: FieldRef<"TradeLedger", 'Int'>
    readonly accountId: FieldRef<"TradeLedger", 'Int'>
    readonly change: FieldRef<"TradeLedger", 'String'>
    readonly tradeId: FieldRef<"TradeLedger", 'String'>
    readonly positionType: FieldRef<"TradeLedger", 'PositionType'>
    readonly operation: FieldRef<"TradeLedger", 'TradeOperation'>
    readonly timestamp: FieldRef<"TradeLedger", 'DateTime'>
    readonly createdAt: FieldRef<"TradeLedger", 'DateTime'>
    readonly createdBy: FieldRef<"TradeLedger", 'Int'>
    readonly updatedAt: FieldRef<"TradeLedger", 'DateTime'>
    readonly updatedBy: FieldRef<"TradeLedger", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TradeLedger findUnique
   */
  export type TradeLedgerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * Filter, which TradeLedger to fetch.
     */
    where: TradeLedgerWhereUniqueInput
  }


  /**
   * TradeLedger findUniqueOrThrow
   */
  export type TradeLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * Filter, which TradeLedger to fetch.
     */
    where: TradeLedgerWhereUniqueInput
  }


  /**
   * TradeLedger findFirst
   */
  export type TradeLedgerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * Filter, which TradeLedger to fetch.
     */
    where?: TradeLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeLedgers to fetch.
     */
    orderBy?: TradeLedgerOrderByWithRelationInput | TradeLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeLedgers.
     */
    cursor?: TradeLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeLedgers.
     */
    distinct?: TradeLedgerScalarFieldEnum | TradeLedgerScalarFieldEnum[]
  }


  /**
   * TradeLedger findFirstOrThrow
   */
  export type TradeLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * Filter, which TradeLedger to fetch.
     */
    where?: TradeLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeLedgers to fetch.
     */
    orderBy?: TradeLedgerOrderByWithRelationInput | TradeLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeLedgers.
     */
    cursor?: TradeLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeLedgers.
     */
    distinct?: TradeLedgerScalarFieldEnum | TradeLedgerScalarFieldEnum[]
  }


  /**
   * TradeLedger findMany
   */
  export type TradeLedgerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * Filter, which TradeLedgers to fetch.
     */
    where?: TradeLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeLedgers to fetch.
     */
    orderBy?: TradeLedgerOrderByWithRelationInput | TradeLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeLedgers.
     */
    cursor?: TradeLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeLedgers.
     */
    skip?: number
    distinct?: TradeLedgerScalarFieldEnum | TradeLedgerScalarFieldEnum[]
  }


  /**
   * TradeLedger create
   */
  export type TradeLedgerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a TradeLedger.
     */
    data: XOR<TradeLedgerCreateInput, TradeLedgerUncheckedCreateInput>
  }


  /**
   * TradeLedger createMany
   */
  export type TradeLedgerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeLedgers.
     */
    data: TradeLedgerCreateManyInput | TradeLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TradeLedger update
   */
  export type TradeLedgerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a TradeLedger.
     */
    data: XOR<TradeLedgerUpdateInput, TradeLedgerUncheckedUpdateInput>
    /**
     * Choose, which TradeLedger to update.
     */
    where: TradeLedgerWhereUniqueInput
  }


  /**
   * TradeLedger updateMany
   */
  export type TradeLedgerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeLedgers.
     */
    data: XOR<TradeLedgerUpdateManyMutationInput, TradeLedgerUncheckedUpdateManyInput>
    /**
     * Filter which TradeLedgers to update
     */
    where?: TradeLedgerWhereInput
  }


  /**
   * TradeLedger upsert
   */
  export type TradeLedgerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the TradeLedger to update in case it exists.
     */
    where: TradeLedgerWhereUniqueInput
    /**
     * In case the TradeLedger found by the `where` argument doesn't exist, create a new TradeLedger with this data.
     */
    create: XOR<TradeLedgerCreateInput, TradeLedgerUncheckedCreateInput>
    /**
     * In case the TradeLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeLedgerUpdateInput, TradeLedgerUncheckedUpdateInput>
  }


  /**
   * TradeLedger delete
   */
  export type TradeLedgerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
    /**
     * Filter which TradeLedger to delete.
     */
    where: TradeLedgerWhereUniqueInput
  }


  /**
   * TradeLedger deleteMany
   */
  export type TradeLedgerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeLedgers to delete
     */
    where?: TradeLedgerWhereInput
  }


  /**
   * TradeLedger.account
   */
  export type TradeLedger$accountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
  }


  /**
   * TradeLedger without action
   */
  export type TradeLedgerDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLedger
     */
    select?: TradeLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TradeLedgerInclude<ExtArgs> | null
  }



  /**
   * Model SystemConfigForDashboard
   */

  export type AggregateSystemConfigForDashboard = {
    _count: SystemConfigForDashboardCountAggregateOutputType | null
    _avg: SystemConfigForDashboardAvgAggregateOutputType | null
    _sum: SystemConfigForDashboardSumAggregateOutputType | null
    _min: SystemConfigForDashboardMinAggregateOutputType | null
    _max: SystemConfigForDashboardMaxAggregateOutputType | null
  }

  export type SystemConfigForDashboardAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type SystemConfigForDashboardSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type SystemConfigForDashboardMinAggregateOutputType = {
    id: number | null
    parameterGroup: $Enums.ParameterGroup | null
    parameterName: string | null
    parameterType: $Enums.ParamType | null
    isRanged: boolean | null
    parameterValue: string | null
    symbol: string | null
    rangeStart: string | null
    rangeEnd: string | null
    roleBasedAccess: boolean | null
    role: $Enums.Role | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type SystemConfigForDashboardMaxAggregateOutputType = {
    id: number | null
    parameterGroup: $Enums.ParameterGroup | null
    parameterName: string | null
    parameterType: $Enums.ParamType | null
    isRanged: boolean | null
    parameterValue: string | null
    symbol: string | null
    rangeStart: string | null
    rangeEnd: string | null
    roleBasedAccess: boolean | null
    role: $Enums.Role | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type SystemConfigForDashboardCountAggregateOutputType = {
    id: number
    parameterGroup: number
    parameterName: number
    parameterType: number
    isRanged: number
    parameterValue: number
    symbol: number
    rangeStart: number
    rangeEnd: number
    roleBasedAccess: number
    role: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SystemConfigForDashboardAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SystemConfigForDashboardSumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SystemConfigForDashboardMinAggregateInputType = {
    id?: true
    parameterGroup?: true
    parameterName?: true
    parameterType?: true
    isRanged?: true
    parameterValue?: true
    symbol?: true
    rangeStart?: true
    rangeEnd?: true
    roleBasedAccess?: true
    role?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemConfigForDashboardMaxAggregateInputType = {
    id?: true
    parameterGroup?: true
    parameterName?: true
    parameterType?: true
    isRanged?: true
    parameterValue?: true
    symbol?: true
    rangeStart?: true
    rangeEnd?: true
    roleBasedAccess?: true
    role?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemConfigForDashboardCountAggregateInputType = {
    id?: true
    parameterGroup?: true
    parameterName?: true
    parameterType?: true
    isRanged?: true
    parameterValue?: true
    symbol?: true
    rangeStart?: true
    rangeEnd?: true
    roleBasedAccess?: true
    role?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SystemConfigForDashboardAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigForDashboard to aggregate.
     */
    where?: SystemConfigForDashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigForDashboards to fetch.
     */
    orderBy?: SystemConfigForDashboardOrderByWithRelationInput | SystemConfigForDashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigForDashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigForDashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigForDashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigForDashboards
    **/
    _count?: true | SystemConfigForDashboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemConfigForDashboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemConfigForDashboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigForDashboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigForDashboardMaxAggregateInputType
  }

  export type GetSystemConfigForDashboardAggregateType<T extends SystemConfigForDashboardAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfigForDashboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfigForDashboard[P]>
      : GetScalarType<T[P], AggregateSystemConfigForDashboard[P]>
  }




  export type SystemConfigForDashboardGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SystemConfigForDashboardWhereInput
    orderBy?: SystemConfigForDashboardOrderByWithAggregationInput | SystemConfigForDashboardOrderByWithAggregationInput[]
    by: SystemConfigForDashboardScalarFieldEnum[] | SystemConfigForDashboardScalarFieldEnum
    having?: SystemConfigForDashboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigForDashboardCountAggregateInputType | true
    _avg?: SystemConfigForDashboardAvgAggregateInputType
    _sum?: SystemConfigForDashboardSumAggregateInputType
    _min?: SystemConfigForDashboardMinAggregateInputType
    _max?: SystemConfigForDashboardMaxAggregateInputType
  }

  export type SystemConfigForDashboardGroupByOutputType = {
    id: number
    parameterGroup: $Enums.ParameterGroup
    parameterName: string
    parameterType: $Enums.ParamType
    isRanged: boolean
    parameterValue: string | null
    symbol: string | null
    rangeStart: string | null
    rangeEnd: string | null
    roleBasedAccess: boolean
    role: $Enums.Role
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: SystemConfigForDashboardCountAggregateOutputType | null
    _avg: SystemConfigForDashboardAvgAggregateOutputType | null
    _sum: SystemConfigForDashboardSumAggregateOutputType | null
    _min: SystemConfigForDashboardMinAggregateOutputType | null
    _max: SystemConfigForDashboardMaxAggregateOutputType | null
  }

  type GetSystemConfigForDashboardGroupByPayload<T extends SystemConfigForDashboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigForDashboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigForDashboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigForDashboardGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigForDashboardGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigForDashboardSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterGroup?: boolean
    parameterName?: boolean
    parameterType?: boolean
    isRanged?: boolean
    parameterValue?: boolean
    symbol?: boolean
    rangeStart?: boolean
    rangeEnd?: boolean
    roleBasedAccess?: boolean
    role?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemConfigForDashboard"]>

  export type SystemConfigForDashboardSelectScalar = {
    id?: boolean
    parameterGroup?: boolean
    parameterName?: boolean
    parameterType?: boolean
    isRanged?: boolean
    parameterValue?: boolean
    symbol?: boolean
    rangeStart?: boolean
    rangeEnd?: boolean
    roleBasedAccess?: boolean
    role?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $SystemConfigForDashboardPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "SystemConfigForDashboard"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      parameterGroup: $Enums.ParameterGroup
      parameterName: string
      parameterType: $Enums.ParamType
      isRanged: boolean
      parameterValue: string | null
      symbol: string | null
      rangeStart: string | null
      rangeEnd: string | null
      roleBasedAccess: boolean
      role: $Enums.Role
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["systemConfigForDashboard"]>
    composites: {}
  }


  type SystemConfigForDashboardGetPayload<S extends boolean | null | undefined | SystemConfigForDashboardDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigForDashboardPayload, S>

  type SystemConfigForDashboardCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SystemConfigForDashboardFindManyArgs, 'select' | 'include'> & {
      select?: SystemConfigForDashboardCountAggregateInputType | true
    }

  export interface SystemConfigForDashboardDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfigForDashboard'], meta: { name: 'SystemConfigForDashboard' } }
    /**
     * Find zero or one SystemConfigForDashboard that matches the filter.
     * @param {SystemConfigForDashboardFindUniqueArgs} args - Arguments to find a SystemConfigForDashboard
     * @example
     * // Get one SystemConfigForDashboard
     * const systemConfigForDashboard = await prisma.systemConfigForDashboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemConfigForDashboardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigForDashboardFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemConfigForDashboardClient<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SystemConfigForDashboard that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SystemConfigForDashboardFindUniqueOrThrowArgs} args - Arguments to find a SystemConfigForDashboard
     * @example
     * // Get one SystemConfigForDashboard
     * const systemConfigForDashboard = await prisma.systemConfigForDashboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SystemConfigForDashboardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigForDashboardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemConfigForDashboardClient<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SystemConfigForDashboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigForDashboardFindFirstArgs} args - Arguments to find a SystemConfigForDashboard
     * @example
     * // Get one SystemConfigForDashboard
     * const systemConfigForDashboard = await prisma.systemConfigForDashboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemConfigForDashboardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigForDashboardFindFirstArgs<ExtArgs>>
    ): Prisma__SystemConfigForDashboardClient<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SystemConfigForDashboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigForDashboardFindFirstOrThrowArgs} args - Arguments to find a SystemConfigForDashboard
     * @example
     * // Get one SystemConfigForDashboard
     * const systemConfigForDashboard = await prisma.systemConfigForDashboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SystemConfigForDashboardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigForDashboardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemConfigForDashboardClient<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SystemConfigForDashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigForDashboardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigForDashboards
     * const systemConfigForDashboards = await prisma.systemConfigForDashboard.findMany()
     * 
     * // Get first 10 SystemConfigForDashboards
     * const systemConfigForDashboards = await prisma.systemConfigForDashboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigForDashboardWithIdOnly = await prisma.systemConfigForDashboard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SystemConfigForDashboardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigForDashboardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SystemConfigForDashboard.
     * @param {SystemConfigForDashboardCreateArgs} args - Arguments to create a SystemConfigForDashboard.
     * @example
     * // Create one SystemConfigForDashboard
     * const SystemConfigForDashboard = await prisma.systemConfigForDashboard.create({
     *   data: {
     *     // ... data to create a SystemConfigForDashboard
     *   }
     * })
     * 
    **/
    create<T extends SystemConfigForDashboardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigForDashboardCreateArgs<ExtArgs>>
    ): Prisma__SystemConfigForDashboardClient<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SystemConfigForDashboards.
     *     @param {SystemConfigForDashboardCreateManyArgs} args - Arguments to create many SystemConfigForDashboards.
     *     @example
     *     // Create many SystemConfigForDashboards
     *     const systemConfigForDashboard = await prisma.systemConfigForDashboard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SystemConfigForDashboardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigForDashboardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemConfigForDashboard.
     * @param {SystemConfigForDashboardDeleteArgs} args - Arguments to delete one SystemConfigForDashboard.
     * @example
     * // Delete one SystemConfigForDashboard
     * const SystemConfigForDashboard = await prisma.systemConfigForDashboard.delete({
     *   where: {
     *     // ... filter to delete one SystemConfigForDashboard
     *   }
     * })
     * 
    **/
    delete<T extends SystemConfigForDashboardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigForDashboardDeleteArgs<ExtArgs>>
    ): Prisma__SystemConfigForDashboardClient<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SystemConfigForDashboard.
     * @param {SystemConfigForDashboardUpdateArgs} args - Arguments to update one SystemConfigForDashboard.
     * @example
     * // Update one SystemConfigForDashboard
     * const systemConfigForDashboard = await prisma.systemConfigForDashboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemConfigForDashboardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigForDashboardUpdateArgs<ExtArgs>>
    ): Prisma__SystemConfigForDashboardClient<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigForDashboards.
     * @param {SystemConfigForDashboardDeleteManyArgs} args - Arguments to filter SystemConfigForDashboards to delete.
     * @example
     * // Delete a few SystemConfigForDashboards
     * const { count } = await prisma.systemConfigForDashboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemConfigForDashboardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigForDashboardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigForDashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigForDashboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigForDashboards
     * const systemConfigForDashboard = await prisma.systemConfigForDashboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemConfigForDashboardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigForDashboardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfigForDashboard.
     * @param {SystemConfigForDashboardUpsertArgs} args - Arguments to update or create a SystemConfigForDashboard.
     * @example
     * // Update or create a SystemConfigForDashboard
     * const systemConfigForDashboard = await prisma.systemConfigForDashboard.upsert({
     *   create: {
     *     // ... data to create a SystemConfigForDashboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfigForDashboard we want to update
     *   }
     * })
    **/
    upsert<T extends SystemConfigForDashboardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigForDashboardUpsertArgs<ExtArgs>>
    ): Prisma__SystemConfigForDashboardClient<$Result.GetResult<Prisma.$SystemConfigForDashboardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SystemConfigForDashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigForDashboardCountArgs} args - Arguments to filter SystemConfigForDashboards to count.
     * @example
     * // Count the number of SystemConfigForDashboards
     * const count = await prisma.systemConfigForDashboard.count({
     *   where: {
     *     // ... the filter for the SystemConfigForDashboards we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigForDashboardCountArgs>(
      args?: Subset<T, SystemConfigForDashboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigForDashboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfigForDashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigForDashboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigForDashboardAggregateArgs>(args: Subset<T, SystemConfigForDashboardAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigForDashboardAggregateType<T>>

    /**
     * Group by SystemConfigForDashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigForDashboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigForDashboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigForDashboardGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigForDashboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigForDashboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigForDashboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfigForDashboard model
   */
  readonly fields: SystemConfigForDashboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfigForDashboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigForDashboardClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SystemConfigForDashboard model
   */ 
  interface SystemConfigForDashboardFieldRefs {
    readonly id: FieldRef<"SystemConfigForDashboard", 'Int'>
    readonly parameterGroup: FieldRef<"SystemConfigForDashboard", 'ParameterGroup'>
    readonly parameterName: FieldRef<"SystemConfigForDashboard", 'String'>
    readonly parameterType: FieldRef<"SystemConfigForDashboard", 'ParamType'>
    readonly isRanged: FieldRef<"SystemConfigForDashboard", 'Boolean'>
    readonly parameterValue: FieldRef<"SystemConfigForDashboard", 'String'>
    readonly symbol: FieldRef<"SystemConfigForDashboard", 'String'>
    readonly rangeStart: FieldRef<"SystemConfigForDashboard", 'String'>
    readonly rangeEnd: FieldRef<"SystemConfigForDashboard", 'String'>
    readonly roleBasedAccess: FieldRef<"SystemConfigForDashboard", 'Boolean'>
    readonly role: FieldRef<"SystemConfigForDashboard", 'Role'>
    readonly createdAt: FieldRef<"SystemConfigForDashboard", 'DateTime'>
    readonly createdBy: FieldRef<"SystemConfigForDashboard", 'Int'>
    readonly updatedAt: FieldRef<"SystemConfigForDashboard", 'DateTime'>
    readonly updatedBy: FieldRef<"SystemConfigForDashboard", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SystemConfigForDashboard findUnique
   */
  export type SystemConfigForDashboardFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigForDashboard to fetch.
     */
    where: SystemConfigForDashboardWhereUniqueInput
  }


  /**
   * SystemConfigForDashboard findUniqueOrThrow
   */
  export type SystemConfigForDashboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigForDashboard to fetch.
     */
    where: SystemConfigForDashboardWhereUniqueInput
  }


  /**
   * SystemConfigForDashboard findFirst
   */
  export type SystemConfigForDashboardFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigForDashboard to fetch.
     */
    where?: SystemConfigForDashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigForDashboards to fetch.
     */
    orderBy?: SystemConfigForDashboardOrderByWithRelationInput | SystemConfigForDashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigForDashboards.
     */
    cursor?: SystemConfigForDashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigForDashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigForDashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigForDashboards.
     */
    distinct?: SystemConfigForDashboardScalarFieldEnum | SystemConfigForDashboardScalarFieldEnum[]
  }


  /**
   * SystemConfigForDashboard findFirstOrThrow
   */
  export type SystemConfigForDashboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigForDashboard to fetch.
     */
    where?: SystemConfigForDashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigForDashboards to fetch.
     */
    orderBy?: SystemConfigForDashboardOrderByWithRelationInput | SystemConfigForDashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigForDashboards.
     */
    cursor?: SystemConfigForDashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigForDashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigForDashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigForDashboards.
     */
    distinct?: SystemConfigForDashboardScalarFieldEnum | SystemConfigForDashboardScalarFieldEnum[]
  }


  /**
   * SystemConfigForDashboard findMany
   */
  export type SystemConfigForDashboardFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigForDashboards to fetch.
     */
    where?: SystemConfigForDashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigForDashboards to fetch.
     */
    orderBy?: SystemConfigForDashboardOrderByWithRelationInput | SystemConfigForDashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigForDashboards.
     */
    cursor?: SystemConfigForDashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigForDashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigForDashboards.
     */
    skip?: number
    distinct?: SystemConfigForDashboardScalarFieldEnum | SystemConfigForDashboardScalarFieldEnum[]
  }


  /**
   * SystemConfigForDashboard create
   */
  export type SystemConfigForDashboardCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfigForDashboard.
     */
    data: XOR<SystemConfigForDashboardCreateInput, SystemConfigForDashboardUncheckedCreateInput>
  }


  /**
   * SystemConfigForDashboard createMany
   */
  export type SystemConfigForDashboardCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigForDashboards.
     */
    data: SystemConfigForDashboardCreateManyInput | SystemConfigForDashboardCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SystemConfigForDashboard update
   */
  export type SystemConfigForDashboardUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfigForDashboard.
     */
    data: XOR<SystemConfigForDashboardUpdateInput, SystemConfigForDashboardUncheckedUpdateInput>
    /**
     * Choose, which SystemConfigForDashboard to update.
     */
    where: SystemConfigForDashboardWhereUniqueInput
  }


  /**
   * SystemConfigForDashboard updateMany
   */
  export type SystemConfigForDashboardUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigForDashboards.
     */
    data: XOR<SystemConfigForDashboardUpdateManyMutationInput, SystemConfigForDashboardUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigForDashboards to update
     */
    where?: SystemConfigForDashboardWhereInput
  }


  /**
   * SystemConfigForDashboard upsert
   */
  export type SystemConfigForDashboardUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfigForDashboard to update in case it exists.
     */
    where: SystemConfigForDashboardWhereUniqueInput
    /**
     * In case the SystemConfigForDashboard found by the `where` argument doesn't exist, create a new SystemConfigForDashboard with this data.
     */
    create: XOR<SystemConfigForDashboardCreateInput, SystemConfigForDashboardUncheckedCreateInput>
    /**
     * In case the SystemConfigForDashboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigForDashboardUpdateInput, SystemConfigForDashboardUncheckedUpdateInput>
  }


  /**
   * SystemConfigForDashboard delete
   */
  export type SystemConfigForDashboardDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
    /**
     * Filter which SystemConfigForDashboard to delete.
     */
    where: SystemConfigForDashboardWhereUniqueInput
  }


  /**
   * SystemConfigForDashboard deleteMany
   */
  export type SystemConfigForDashboardDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigForDashboards to delete
     */
    where?: SystemConfigForDashboardWhereInput
  }


  /**
   * SystemConfigForDashboard without action
   */
  export type SystemConfigForDashboardDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigForDashboard
     */
    select?: SystemConfigForDashboardSelect<ExtArgs> | null
  }



  /**
   * Model SystemConfigChangeLog
   */

  export type AggregateSystemConfigChangeLog = {
    _count: SystemConfigChangeLogCountAggregateOutputType | null
    _avg: SystemConfigChangeLogAvgAggregateOutputType | null
    _sum: SystemConfigChangeLogSumAggregateOutputType | null
    _min: SystemConfigChangeLogMinAggregateOutputType | null
    _max: SystemConfigChangeLogMaxAggregateOutputType | null
  }

  export type SystemConfigChangeLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type SystemConfigChangeLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type SystemConfigChangeLogMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    userId: number | null
    parameterName: string | null
    parameterValue: string | null
    isRanged: boolean | null
    rangeStart: string | null
    rangeEnd: string | null
    userType: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type SystemConfigChangeLogMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    userId: number | null
    parameterName: string | null
    parameterValue: string | null
    isRanged: boolean | null
    rangeStart: string | null
    rangeEnd: string | null
    userType: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type SystemConfigChangeLogCountAggregateOutputType = {
    id: number
    timestamp: number
    userId: number
    parameterName: number
    parameterValue: number
    isRanged: number
    rangeStart: number
    rangeEnd: number
    userType: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SystemConfigChangeLogAvgAggregateInputType = {
    id?: true
    userId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SystemConfigChangeLogSumAggregateInputType = {
    id?: true
    userId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SystemConfigChangeLogMinAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    parameterName?: true
    parameterValue?: true
    isRanged?: true
    rangeStart?: true
    rangeEnd?: true
    userType?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemConfigChangeLogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    parameterName?: true
    parameterValue?: true
    isRanged?: true
    rangeStart?: true
    rangeEnd?: true
    userType?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemConfigChangeLogCountAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    parameterName?: true
    parameterValue?: true
    isRanged?: true
    rangeStart?: true
    rangeEnd?: true
    userType?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SystemConfigChangeLogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigChangeLog to aggregate.
     */
    where?: SystemConfigChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigChangeLogs to fetch.
     */
    orderBy?: SystemConfigChangeLogOrderByWithRelationInput | SystemConfigChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigChangeLogs
    **/
    _count?: true | SystemConfigChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemConfigChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemConfigChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigChangeLogMaxAggregateInputType
  }

  export type GetSystemConfigChangeLogAggregateType<T extends SystemConfigChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfigChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfigChangeLog[P]>
      : GetScalarType<T[P], AggregateSystemConfigChangeLog[P]>
  }




  export type SystemConfigChangeLogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SystemConfigChangeLogWhereInput
    orderBy?: SystemConfigChangeLogOrderByWithAggregationInput | SystemConfigChangeLogOrderByWithAggregationInput[]
    by: SystemConfigChangeLogScalarFieldEnum[] | SystemConfigChangeLogScalarFieldEnum
    having?: SystemConfigChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigChangeLogCountAggregateInputType | true
    _avg?: SystemConfigChangeLogAvgAggregateInputType
    _sum?: SystemConfigChangeLogSumAggregateInputType
    _min?: SystemConfigChangeLogMinAggregateInputType
    _max?: SystemConfigChangeLogMaxAggregateInputType
  }

  export type SystemConfigChangeLogGroupByOutputType = {
    id: number
    timestamp: Date
    userId: number
    parameterName: string
    parameterValue: string | null
    isRanged: boolean
    rangeStart: string | null
    rangeEnd: string | null
    userType: string
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: SystemConfigChangeLogCountAggregateOutputType | null
    _avg: SystemConfigChangeLogAvgAggregateOutputType | null
    _sum: SystemConfigChangeLogSumAggregateOutputType | null
    _min: SystemConfigChangeLogMinAggregateOutputType | null
    _max: SystemConfigChangeLogMaxAggregateOutputType | null
  }

  type GetSystemConfigChangeLogGroupByPayload<T extends SystemConfigChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigChangeLogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    userId?: boolean
    parameterName?: boolean
    parameterValue?: boolean
    isRanged?: boolean
    rangeStart?: boolean
    rangeEnd?: boolean
    userType?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemConfigChangeLog"]>

  export type SystemConfigChangeLogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    userId?: boolean
    parameterName?: boolean
    parameterValue?: boolean
    isRanged?: boolean
    rangeStart?: boolean
    rangeEnd?: boolean
    userType?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $SystemConfigChangeLogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "SystemConfigChangeLog"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      timestamp: Date
      userId: number
      parameterName: string
      parameterValue: string | null
      isRanged: boolean
      rangeStart: string | null
      rangeEnd: string | null
      userType: string
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["systemConfigChangeLog"]>
    composites: {}
  }


  type SystemConfigChangeLogGetPayload<S extends boolean | null | undefined | SystemConfigChangeLogDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigChangeLogPayload, S>

  type SystemConfigChangeLogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SystemConfigChangeLogFindManyArgs, 'select' | 'include'> & {
      select?: SystemConfigChangeLogCountAggregateInputType | true
    }

  export interface SystemConfigChangeLogDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfigChangeLog'], meta: { name: 'SystemConfigChangeLog' } }
    /**
     * Find zero or one SystemConfigChangeLog that matches the filter.
     * @param {SystemConfigChangeLogFindUniqueArgs} args - Arguments to find a SystemConfigChangeLog
     * @example
     * // Get one SystemConfigChangeLog
     * const systemConfigChangeLog = await prisma.systemConfigChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemConfigChangeLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigChangeLogFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemConfigChangeLogClient<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SystemConfigChangeLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SystemConfigChangeLogFindUniqueOrThrowArgs} args - Arguments to find a SystemConfigChangeLog
     * @example
     * // Get one SystemConfigChangeLog
     * const systemConfigChangeLog = await prisma.systemConfigChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SystemConfigChangeLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigChangeLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemConfigChangeLogClient<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SystemConfigChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigChangeLogFindFirstArgs} args - Arguments to find a SystemConfigChangeLog
     * @example
     * // Get one SystemConfigChangeLog
     * const systemConfigChangeLog = await prisma.systemConfigChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemConfigChangeLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigChangeLogFindFirstArgs<ExtArgs>>
    ): Prisma__SystemConfigChangeLogClient<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SystemConfigChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigChangeLogFindFirstOrThrowArgs} args - Arguments to find a SystemConfigChangeLog
     * @example
     * // Get one SystemConfigChangeLog
     * const systemConfigChangeLog = await prisma.systemConfigChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SystemConfigChangeLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigChangeLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemConfigChangeLogClient<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SystemConfigChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigChangeLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigChangeLogs
     * const systemConfigChangeLogs = await prisma.systemConfigChangeLog.findMany()
     * 
     * // Get first 10 SystemConfigChangeLogs
     * const systemConfigChangeLogs = await prisma.systemConfigChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigChangeLogWithIdOnly = await prisma.systemConfigChangeLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SystemConfigChangeLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigChangeLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SystemConfigChangeLog.
     * @param {SystemConfigChangeLogCreateArgs} args - Arguments to create a SystemConfigChangeLog.
     * @example
     * // Create one SystemConfigChangeLog
     * const SystemConfigChangeLog = await prisma.systemConfigChangeLog.create({
     *   data: {
     *     // ... data to create a SystemConfigChangeLog
     *   }
     * })
     * 
    **/
    create<T extends SystemConfigChangeLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigChangeLogCreateArgs<ExtArgs>>
    ): Prisma__SystemConfigChangeLogClient<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SystemConfigChangeLogs.
     *     @param {SystemConfigChangeLogCreateManyArgs} args - Arguments to create many SystemConfigChangeLogs.
     *     @example
     *     // Create many SystemConfigChangeLogs
     *     const systemConfigChangeLog = await prisma.systemConfigChangeLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SystemConfigChangeLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigChangeLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemConfigChangeLog.
     * @param {SystemConfigChangeLogDeleteArgs} args - Arguments to delete one SystemConfigChangeLog.
     * @example
     * // Delete one SystemConfigChangeLog
     * const SystemConfigChangeLog = await prisma.systemConfigChangeLog.delete({
     *   where: {
     *     // ... filter to delete one SystemConfigChangeLog
     *   }
     * })
     * 
    **/
    delete<T extends SystemConfigChangeLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigChangeLogDeleteArgs<ExtArgs>>
    ): Prisma__SystemConfigChangeLogClient<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SystemConfigChangeLog.
     * @param {SystemConfigChangeLogUpdateArgs} args - Arguments to update one SystemConfigChangeLog.
     * @example
     * // Update one SystemConfigChangeLog
     * const systemConfigChangeLog = await prisma.systemConfigChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemConfigChangeLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigChangeLogUpdateArgs<ExtArgs>>
    ): Prisma__SystemConfigChangeLogClient<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigChangeLogs.
     * @param {SystemConfigChangeLogDeleteManyArgs} args - Arguments to filter SystemConfigChangeLogs to delete.
     * @example
     * // Delete a few SystemConfigChangeLogs
     * const { count } = await prisma.systemConfigChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemConfigChangeLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SystemConfigChangeLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigChangeLogs
     * const systemConfigChangeLog = await prisma.systemConfigChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemConfigChangeLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigChangeLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfigChangeLog.
     * @param {SystemConfigChangeLogUpsertArgs} args - Arguments to update or create a SystemConfigChangeLog.
     * @example
     * // Update or create a SystemConfigChangeLog
     * const systemConfigChangeLog = await prisma.systemConfigChangeLog.upsert({
     *   create: {
     *     // ... data to create a SystemConfigChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfigChangeLog we want to update
     *   }
     * })
    **/
    upsert<T extends SystemConfigChangeLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SystemConfigChangeLogUpsertArgs<ExtArgs>>
    ): Prisma__SystemConfigChangeLogClient<$Result.GetResult<Prisma.$SystemConfigChangeLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SystemConfigChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigChangeLogCountArgs} args - Arguments to filter SystemConfigChangeLogs to count.
     * @example
     * // Count the number of SystemConfigChangeLogs
     * const count = await prisma.systemConfigChangeLog.count({
     *   where: {
     *     // ... the filter for the SystemConfigChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigChangeLogCountArgs>(
      args?: Subset<T, SystemConfigChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfigChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigChangeLogAggregateArgs>(args: Subset<T, SystemConfigChangeLogAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigChangeLogAggregateType<T>>

    /**
     * Group by SystemConfigChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfigChangeLog model
   */
  readonly fields: SystemConfigChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfigChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigChangeLogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SystemConfigChangeLog model
   */ 
  interface SystemConfigChangeLogFieldRefs {
    readonly id: FieldRef<"SystemConfigChangeLog", 'Int'>
    readonly timestamp: FieldRef<"SystemConfigChangeLog", 'DateTime'>
    readonly userId: FieldRef<"SystemConfigChangeLog", 'Int'>
    readonly parameterName: FieldRef<"SystemConfigChangeLog", 'String'>
    readonly parameterValue: FieldRef<"SystemConfigChangeLog", 'String'>
    readonly isRanged: FieldRef<"SystemConfigChangeLog", 'Boolean'>
    readonly rangeStart: FieldRef<"SystemConfigChangeLog", 'String'>
    readonly rangeEnd: FieldRef<"SystemConfigChangeLog", 'String'>
    readonly userType: FieldRef<"SystemConfigChangeLog", 'String'>
    readonly createdAt: FieldRef<"SystemConfigChangeLog", 'DateTime'>
    readonly createdBy: FieldRef<"SystemConfigChangeLog", 'Int'>
    readonly updatedAt: FieldRef<"SystemConfigChangeLog", 'DateTime'>
    readonly updatedBy: FieldRef<"SystemConfigChangeLog", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SystemConfigChangeLog findUnique
   */
  export type SystemConfigChangeLogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigChangeLog to fetch.
     */
    where: SystemConfigChangeLogWhereUniqueInput
  }


  /**
   * SystemConfigChangeLog findUniqueOrThrow
   */
  export type SystemConfigChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigChangeLog to fetch.
     */
    where: SystemConfigChangeLogWhereUniqueInput
  }


  /**
   * SystemConfigChangeLog findFirst
   */
  export type SystemConfigChangeLogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigChangeLog to fetch.
     */
    where?: SystemConfigChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigChangeLogs to fetch.
     */
    orderBy?: SystemConfigChangeLogOrderByWithRelationInput | SystemConfigChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigChangeLogs.
     */
    cursor?: SystemConfigChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigChangeLogs.
     */
    distinct?: SystemConfigChangeLogScalarFieldEnum | SystemConfigChangeLogScalarFieldEnum[]
  }


  /**
   * SystemConfigChangeLog findFirstOrThrow
   */
  export type SystemConfigChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigChangeLog to fetch.
     */
    where?: SystemConfigChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigChangeLogs to fetch.
     */
    orderBy?: SystemConfigChangeLogOrderByWithRelationInput | SystemConfigChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigChangeLogs.
     */
    cursor?: SystemConfigChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigChangeLogs.
     */
    distinct?: SystemConfigChangeLogScalarFieldEnum | SystemConfigChangeLogScalarFieldEnum[]
  }


  /**
   * SystemConfigChangeLog findMany
   */
  export type SystemConfigChangeLogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigChangeLogs to fetch.
     */
    where?: SystemConfigChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigChangeLogs to fetch.
     */
    orderBy?: SystemConfigChangeLogOrderByWithRelationInput | SystemConfigChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigChangeLogs.
     */
    cursor?: SystemConfigChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigChangeLogs.
     */
    skip?: number
    distinct?: SystemConfigChangeLogScalarFieldEnum | SystemConfigChangeLogScalarFieldEnum[]
  }


  /**
   * SystemConfigChangeLog create
   */
  export type SystemConfigChangeLogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfigChangeLog.
     */
    data: XOR<SystemConfigChangeLogCreateInput, SystemConfigChangeLogUncheckedCreateInput>
  }


  /**
   * SystemConfigChangeLog createMany
   */
  export type SystemConfigChangeLogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigChangeLogs.
     */
    data: SystemConfigChangeLogCreateManyInput | SystemConfigChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SystemConfigChangeLog update
   */
  export type SystemConfigChangeLogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfigChangeLog.
     */
    data: XOR<SystemConfigChangeLogUpdateInput, SystemConfigChangeLogUncheckedUpdateInput>
    /**
     * Choose, which SystemConfigChangeLog to update.
     */
    where: SystemConfigChangeLogWhereUniqueInput
  }


  /**
   * SystemConfigChangeLog updateMany
   */
  export type SystemConfigChangeLogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigChangeLogs.
     */
    data: XOR<SystemConfigChangeLogUpdateManyMutationInput, SystemConfigChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigChangeLogs to update
     */
    where?: SystemConfigChangeLogWhereInput
  }


  /**
   * SystemConfigChangeLog upsert
   */
  export type SystemConfigChangeLogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfigChangeLog to update in case it exists.
     */
    where: SystemConfigChangeLogWhereUniqueInput
    /**
     * In case the SystemConfigChangeLog found by the `where` argument doesn't exist, create a new SystemConfigChangeLog with this data.
     */
    create: XOR<SystemConfigChangeLogCreateInput, SystemConfigChangeLogUncheckedCreateInput>
    /**
     * In case the SystemConfigChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigChangeLogUpdateInput, SystemConfigChangeLogUncheckedUpdateInput>
  }


  /**
   * SystemConfigChangeLog delete
   */
  export type SystemConfigChangeLogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
    /**
     * Filter which SystemConfigChangeLog to delete.
     */
    where: SystemConfigChangeLogWhereUniqueInput
  }


  /**
   * SystemConfigChangeLog deleteMany
   */
  export type SystemConfigChangeLogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigChangeLogs to delete
     */
    where?: SystemConfigChangeLogWhereInput
  }


  /**
   * SystemConfigChangeLog without action
   */
  export type SystemConfigChangeLogDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfigChangeLog
     */
    select?: SystemConfigChangeLogSelect<ExtArgs> | null
  }



  /**
   * Model InrWallet
   */

  export type AggregateInrWallet = {
    _count: InrWalletCountAggregateOutputType | null
    _avg: InrWalletAvgAggregateOutputType | null
    _sum: InrWalletSumAggregateOutputType | null
    _min: InrWalletMinAggregateOutputType | null
    _max: InrWalletMaxAggregateOutputType | null
  }

  export type InrWalletAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    walletBalance: number | null
    amountAvailable: number | null
    amountLocked: number | null
    unrealizedPnl: number | null
    last24hourChange: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type InrWalletSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    walletBalance: number | null
    amountAvailable: number | null
    amountLocked: number | null
    unrealizedPnl: number | null
    last24hourChange: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type InrWalletMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    walletBalance: number | null
    amountAvailable: number | null
    amountLocked: number | null
    unrealizedPnl: number | null
    last24hourChange: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type InrWalletMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    walletBalance: number | null
    amountAvailable: number | null
    amountLocked: number | null
    unrealizedPnl: number | null
    last24hourChange: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type InrWalletCountAggregateOutputType = {
    id: number
    accountId: number
    walletBalance: number
    amountAvailable: number
    amountLocked: number
    unrealizedPnl: number
    last24hourChange: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type InrWalletAvgAggregateInputType = {
    id?: true
    accountId?: true
    walletBalance?: true
    amountAvailable?: true
    amountLocked?: true
    unrealizedPnl?: true
    last24hourChange?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InrWalletSumAggregateInputType = {
    id?: true
    accountId?: true
    walletBalance?: true
    amountAvailable?: true
    amountLocked?: true
    unrealizedPnl?: true
    last24hourChange?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InrWalletMinAggregateInputType = {
    id?: true
    accountId?: true
    walletBalance?: true
    amountAvailable?: true
    amountLocked?: true
    unrealizedPnl?: true
    last24hourChange?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InrWalletMaxAggregateInputType = {
    id?: true
    accountId?: true
    walletBalance?: true
    amountAvailable?: true
    amountLocked?: true
    unrealizedPnl?: true
    last24hourChange?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InrWalletCountAggregateInputType = {
    id?: true
    accountId?: true
    walletBalance?: true
    amountAvailable?: true
    amountLocked?: true
    unrealizedPnl?: true
    last24hourChange?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type InrWalletAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InrWallet to aggregate.
     */
    where?: InrWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrWallets to fetch.
     */
    orderBy?: InrWalletOrderByWithRelationInput | InrWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InrWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InrWallets
    **/
    _count?: true | InrWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InrWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InrWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InrWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InrWalletMaxAggregateInputType
  }

  export type GetInrWalletAggregateType<T extends InrWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateInrWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInrWallet[P]>
      : GetScalarType<T[P], AggregateInrWallet[P]>
  }




  export type InrWalletGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InrWalletWhereInput
    orderBy?: InrWalletOrderByWithAggregationInput | InrWalletOrderByWithAggregationInput[]
    by: InrWalletScalarFieldEnum[] | InrWalletScalarFieldEnum
    having?: InrWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InrWalletCountAggregateInputType | true
    _avg?: InrWalletAvgAggregateInputType
    _sum?: InrWalletSumAggregateInputType
    _min?: InrWalletMinAggregateInputType
    _max?: InrWalletMaxAggregateInputType
  }

  export type InrWalletGroupByOutputType = {
    id: number
    accountId: number
    walletBalance: number
    amountAvailable: number
    amountLocked: number
    unrealizedPnl: number
    last24hourChange: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: InrWalletCountAggregateOutputType | null
    _avg: InrWalletAvgAggregateOutputType | null
    _sum: InrWalletSumAggregateOutputType | null
    _min: InrWalletMinAggregateOutputType | null
    _max: InrWalletMaxAggregateOutputType | null
  }

  type GetInrWalletGroupByPayload<T extends InrWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InrWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InrWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InrWalletGroupByOutputType[P]>
            : GetScalarType<T[P], InrWalletGroupByOutputType[P]>
        }
      >
    >


  export type InrWalletSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    walletBalance?: boolean
    amountAvailable?: boolean
    amountLocked?: boolean
    unrealizedPnl?: boolean
    last24hourChange?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    Account?: boolean | InrWallet$AccountArgs<ExtArgs>
  }, ExtArgs["result"]["inrWallet"]>

  export type InrWalletSelectScalar = {
    id?: boolean
    accountId?: boolean
    walletBalance?: boolean
    amountAvailable?: boolean
    amountLocked?: boolean
    unrealizedPnl?: boolean
    last24hourChange?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type InrWalletInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Account?: boolean | InrWallet$AccountArgs<ExtArgs>
  }


  export type $InrWalletPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "InrWallet"
    objects: {
      Account: Prisma.$UserAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      accountId: number
      walletBalance: number
      amountAvailable: number
      amountLocked: number
      unrealizedPnl: number
      last24hourChange: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["inrWallet"]>
    composites: {}
  }


  type InrWalletGetPayload<S extends boolean | null | undefined | InrWalletDefaultArgs> = $Result.GetResult<Prisma.$InrWalletPayload, S>

  type InrWalletCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InrWalletFindManyArgs, 'select' | 'include'> & {
      select?: InrWalletCountAggregateInputType | true
    }

  export interface InrWalletDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InrWallet'], meta: { name: 'InrWallet' } }
    /**
     * Find zero or one InrWallet that matches the filter.
     * @param {InrWalletFindUniqueArgs} args - Arguments to find a InrWallet
     * @example
     * // Get one InrWallet
     * const inrWallet = await prisma.inrWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InrWalletFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InrWalletFindUniqueArgs<ExtArgs>>
    ): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InrWallet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InrWalletFindUniqueOrThrowArgs} args - Arguments to find a InrWallet
     * @example
     * // Get one InrWallet
     * const inrWallet = await prisma.inrWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InrWalletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InrWalletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InrWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrWalletFindFirstArgs} args - Arguments to find a InrWallet
     * @example
     * // Get one InrWallet
     * const inrWallet = await prisma.inrWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InrWalletFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InrWalletFindFirstArgs<ExtArgs>>
    ): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InrWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrWalletFindFirstOrThrowArgs} args - Arguments to find a InrWallet
     * @example
     * // Get one InrWallet
     * const inrWallet = await prisma.inrWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InrWalletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InrWalletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InrWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrWalletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InrWallets
     * const inrWallets = await prisma.inrWallet.findMany()
     * 
     * // Get first 10 InrWallets
     * const inrWallets = await prisma.inrWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inrWalletWithIdOnly = await prisma.inrWallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InrWalletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrWalletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InrWallet.
     * @param {InrWalletCreateArgs} args - Arguments to create a InrWallet.
     * @example
     * // Create one InrWallet
     * const InrWallet = await prisma.inrWallet.create({
     *   data: {
     *     // ... data to create a InrWallet
     *   }
     * })
     * 
    **/
    create<T extends InrWalletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InrWalletCreateArgs<ExtArgs>>
    ): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InrWallets.
     *     @param {InrWalletCreateManyArgs} args - Arguments to create many InrWallets.
     *     @example
     *     // Create many InrWallets
     *     const inrWallet = await prisma.inrWallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InrWalletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrWalletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InrWallet.
     * @param {InrWalletDeleteArgs} args - Arguments to delete one InrWallet.
     * @example
     * // Delete one InrWallet
     * const InrWallet = await prisma.inrWallet.delete({
     *   where: {
     *     // ... filter to delete one InrWallet
     *   }
     * })
     * 
    **/
    delete<T extends InrWalletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InrWalletDeleteArgs<ExtArgs>>
    ): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InrWallet.
     * @param {InrWalletUpdateArgs} args - Arguments to update one InrWallet.
     * @example
     * // Update one InrWallet
     * const inrWallet = await prisma.inrWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InrWalletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InrWalletUpdateArgs<ExtArgs>>
    ): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InrWallets.
     * @param {InrWalletDeleteManyArgs} args - Arguments to filter InrWallets to delete.
     * @example
     * // Delete a few InrWallets
     * const { count } = await prisma.inrWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InrWalletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InrWalletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InrWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InrWallets
     * const inrWallet = await prisma.inrWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InrWalletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InrWalletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InrWallet.
     * @param {InrWalletUpsertArgs} args - Arguments to update or create a InrWallet.
     * @example
     * // Update or create a InrWallet
     * const inrWallet = await prisma.inrWallet.upsert({
     *   create: {
     *     // ... data to create a InrWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InrWallet we want to update
     *   }
     * })
    **/
    upsert<T extends InrWalletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InrWalletUpsertArgs<ExtArgs>>
    ): Prisma__InrWalletClient<$Result.GetResult<Prisma.$InrWalletPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InrWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrWalletCountArgs} args - Arguments to filter InrWallets to count.
     * @example
     * // Count the number of InrWallets
     * const count = await prisma.inrWallet.count({
     *   where: {
     *     // ... the filter for the InrWallets we want to count
     *   }
     * })
    **/
    count<T extends InrWalletCountArgs>(
      args?: Subset<T, InrWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InrWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InrWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InrWalletAggregateArgs>(args: Subset<T, InrWalletAggregateArgs>): Prisma.PrismaPromise<GetInrWalletAggregateType<T>>

    /**
     * Group by InrWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InrWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InrWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InrWalletGroupByArgs['orderBy'] }
        : { orderBy?: InrWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InrWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInrWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InrWallet model
   */
  readonly fields: InrWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InrWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InrWalletClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Account<T extends InrWallet$AccountArgs<ExtArgs> = {}>(args?: Subset<T, InrWallet$AccountArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InrWallet model
   */ 
  interface InrWalletFieldRefs {
    readonly id: FieldRef<"InrWallet", 'Int'>
    readonly accountId: FieldRef<"InrWallet", 'Int'>
    readonly walletBalance: FieldRef<"InrWallet", 'Float'>
    readonly amountAvailable: FieldRef<"InrWallet", 'Float'>
    readonly amountLocked: FieldRef<"InrWallet", 'Float'>
    readonly unrealizedPnl: FieldRef<"InrWallet", 'Float'>
    readonly last24hourChange: FieldRef<"InrWallet", 'Float'>
    readonly createdAt: FieldRef<"InrWallet", 'DateTime'>
    readonly createdBy: FieldRef<"InrWallet", 'Int'>
    readonly updatedAt: FieldRef<"InrWallet", 'DateTime'>
    readonly updatedBy: FieldRef<"InrWallet", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * InrWallet findUnique
   */
  export type InrWalletFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * Filter, which InrWallet to fetch.
     */
    where: InrWalletWhereUniqueInput
  }


  /**
   * InrWallet findUniqueOrThrow
   */
  export type InrWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * Filter, which InrWallet to fetch.
     */
    where: InrWalletWhereUniqueInput
  }


  /**
   * InrWallet findFirst
   */
  export type InrWalletFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * Filter, which InrWallet to fetch.
     */
    where?: InrWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrWallets to fetch.
     */
    orderBy?: InrWalletOrderByWithRelationInput | InrWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InrWallets.
     */
    cursor?: InrWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InrWallets.
     */
    distinct?: InrWalletScalarFieldEnum | InrWalletScalarFieldEnum[]
  }


  /**
   * InrWallet findFirstOrThrow
   */
  export type InrWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * Filter, which InrWallet to fetch.
     */
    where?: InrWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrWallets to fetch.
     */
    orderBy?: InrWalletOrderByWithRelationInput | InrWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InrWallets.
     */
    cursor?: InrWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InrWallets.
     */
    distinct?: InrWalletScalarFieldEnum | InrWalletScalarFieldEnum[]
  }


  /**
   * InrWallet findMany
   */
  export type InrWalletFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * Filter, which InrWallets to fetch.
     */
    where?: InrWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InrWallets to fetch.
     */
    orderBy?: InrWalletOrderByWithRelationInput | InrWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InrWallets.
     */
    cursor?: InrWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InrWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InrWallets.
     */
    skip?: number
    distinct?: InrWalletScalarFieldEnum | InrWalletScalarFieldEnum[]
  }


  /**
   * InrWallet create
   */
  export type InrWalletCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a InrWallet.
     */
    data: XOR<InrWalletCreateInput, InrWalletUncheckedCreateInput>
  }


  /**
   * InrWallet createMany
   */
  export type InrWalletCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InrWallets.
     */
    data: InrWalletCreateManyInput | InrWalletCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InrWallet update
   */
  export type InrWalletUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a InrWallet.
     */
    data: XOR<InrWalletUpdateInput, InrWalletUncheckedUpdateInput>
    /**
     * Choose, which InrWallet to update.
     */
    where: InrWalletWhereUniqueInput
  }


  /**
   * InrWallet updateMany
   */
  export type InrWalletUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InrWallets.
     */
    data: XOR<InrWalletUpdateManyMutationInput, InrWalletUncheckedUpdateManyInput>
    /**
     * Filter which InrWallets to update
     */
    where?: InrWalletWhereInput
  }


  /**
   * InrWallet upsert
   */
  export type InrWalletUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the InrWallet to update in case it exists.
     */
    where: InrWalletWhereUniqueInput
    /**
     * In case the InrWallet found by the `where` argument doesn't exist, create a new InrWallet with this data.
     */
    create: XOR<InrWalletCreateInput, InrWalletUncheckedCreateInput>
    /**
     * In case the InrWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InrWalletUpdateInput, InrWalletUncheckedUpdateInput>
  }


  /**
   * InrWallet delete
   */
  export type InrWalletDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
    /**
     * Filter which InrWallet to delete.
     */
    where: InrWalletWhereUniqueInput
  }


  /**
   * InrWallet deleteMany
   */
  export type InrWalletDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InrWallets to delete
     */
    where?: InrWalletWhereInput
  }


  /**
   * InrWallet.Account
   */
  export type InrWallet$AccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
  }


  /**
   * InrWallet without action
   */
  export type InrWalletDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InrWallet
     */
    select?: InrWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InrWalletInclude<ExtArgs> | null
  }



  /**
   * Model ParentWallet
   */

  export type AggregateParentWallet = {
    _count: ParentWalletCountAggregateOutputType | null
    _avg: ParentWalletAvgAggregateOutputType | null
    _sum: ParentWalletSumAggregateOutputType | null
    _min: ParentWalletMinAggregateOutputType | null
    _max: ParentWalletMaxAggregateOutputType | null
  }

  export type ParentWalletAvgAggregateOutputType = {
    id: number | null
    walletId: number | null
    lastUsedIndex: number | null
  }

  export type ParentWalletSumAggregateOutputType = {
    id: number | null
    walletId: number | null
    lastUsedIndex: number | null
  }

  export type ParentWalletMinAggregateOutputType = {
    id: number | null
    walletId: number | null
    walletAddress: string | null
    chain: string | null
    coin: string | null
    parentChain: string | null
    type: string | null
    subType: $Enums.ParentWalletType | null
    lastUsedIndex: number | null
    displayName: string | null
    toBeDisplayed: boolean | null
    parentChainIconUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentWalletMaxAggregateOutputType = {
    id: number | null
    walletId: number | null
    walletAddress: string | null
    chain: string | null
    coin: string | null
    parentChain: string | null
    type: string | null
    subType: $Enums.ParentWalletType | null
    lastUsedIndex: number | null
    displayName: string | null
    toBeDisplayed: boolean | null
    parentChainIconUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentWalletCountAggregateOutputType = {
    id: number
    walletId: number
    walletAddress: number
    chain: number
    coin: number
    parentChain: number
    type: number
    subType: number
    lastUsedIndex: number
    displayName: number
    toBeDisplayed: number
    parentChainIconUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentWalletAvgAggregateInputType = {
    id?: true
    walletId?: true
    lastUsedIndex?: true
  }

  export type ParentWalletSumAggregateInputType = {
    id?: true
    walletId?: true
    lastUsedIndex?: true
  }

  export type ParentWalletMinAggregateInputType = {
    id?: true
    walletId?: true
    walletAddress?: true
    chain?: true
    coin?: true
    parentChain?: true
    type?: true
    subType?: true
    lastUsedIndex?: true
    displayName?: true
    toBeDisplayed?: true
    parentChainIconUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentWalletMaxAggregateInputType = {
    id?: true
    walletId?: true
    walletAddress?: true
    chain?: true
    coin?: true
    parentChain?: true
    type?: true
    subType?: true
    lastUsedIndex?: true
    displayName?: true
    toBeDisplayed?: true
    parentChainIconUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentWalletCountAggregateInputType = {
    id?: true
    walletId?: true
    walletAddress?: true
    chain?: true
    coin?: true
    parentChain?: true
    type?: true
    subType?: true
    lastUsedIndex?: true
    displayName?: true
    toBeDisplayed?: true
    parentChainIconUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentWalletAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentWallet to aggregate.
     */
    where?: ParentWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentWallets to fetch.
     */
    orderBy?: ParentWalletOrderByWithRelationInput | ParentWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParentWallets
    **/
    _count?: true | ParentWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentWalletMaxAggregateInputType
  }

  export type GetParentWalletAggregateType<T extends ParentWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateParentWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParentWallet[P]>
      : GetScalarType<T[P], AggregateParentWallet[P]>
  }




  export type ParentWalletGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ParentWalletWhereInput
    orderBy?: ParentWalletOrderByWithAggregationInput | ParentWalletOrderByWithAggregationInput[]
    by: ParentWalletScalarFieldEnum[] | ParentWalletScalarFieldEnum
    having?: ParentWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentWalletCountAggregateInputType | true
    _avg?: ParentWalletAvgAggregateInputType
    _sum?: ParentWalletSumAggregateInputType
    _min?: ParentWalletMinAggregateInputType
    _max?: ParentWalletMaxAggregateInputType
  }

  export type ParentWalletGroupByOutputType = {
    id: number
    walletId: number
    walletAddress: string
    chain: string
    coin: string
    parentChain: string
    type: string
    subType: $Enums.ParentWalletType
    lastUsedIndex: number
    displayName: string | null
    toBeDisplayed: boolean
    parentChainIconUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ParentWalletCountAggregateOutputType | null
    _avg: ParentWalletAvgAggregateOutputType | null
    _sum: ParentWalletSumAggregateOutputType | null
    _min: ParentWalletMinAggregateOutputType | null
    _max: ParentWalletMaxAggregateOutputType | null
  }

  type GetParentWalletGroupByPayload<T extends ParentWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentWalletGroupByOutputType[P]>
            : GetScalarType<T[P], ParentWalletGroupByOutputType[P]>
        }
      >
    >


  export type ParentWalletSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    walletAddress?: boolean
    chain?: boolean
    coin?: boolean
    parentChain?: boolean
    type?: boolean
    subType?: boolean
    lastUsedIndex?: boolean
    displayName?: boolean
    toBeDisplayed?: boolean
    parentChainIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    childCryptoWallet?: boolean | ParentWallet$childCryptoWalletArgs<ExtArgs>
    parentWallet?: boolean | ParentWallet$parentWalletArgs<ExtArgs>
    _count?: boolean | ParentWalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentWallet"]>

  export type ParentWalletSelectScalar = {
    id?: boolean
    walletId?: boolean
    walletAddress?: boolean
    chain?: boolean
    coin?: boolean
    parentChain?: boolean
    type?: boolean
    subType?: boolean
    lastUsedIndex?: boolean
    displayName?: boolean
    toBeDisplayed?: boolean
    parentChainIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentWalletInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    childCryptoWallet?: boolean | ParentWallet$childCryptoWalletArgs<ExtArgs>
    parentWallet?: boolean | ParentWallet$parentWalletArgs<ExtArgs>
    _count?: boolean | ParentWalletCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ParentWalletPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ParentWallet"
    objects: {
      childCryptoWallet: Prisma.$CryptoWalletPayload<ExtArgs>[]
      parentWallet: Prisma.$StableCoinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      walletId: number
      walletAddress: string
      chain: string
      coin: string
      parentChain: string
      type: string
      subType: $Enums.ParentWalletType
      lastUsedIndex: number
      displayName: string | null
      toBeDisplayed: boolean
      parentChainIconUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parentWallet"]>
    composites: {}
  }


  type ParentWalletGetPayload<S extends boolean | null | undefined | ParentWalletDefaultArgs> = $Result.GetResult<Prisma.$ParentWalletPayload, S>

  type ParentWalletCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ParentWalletFindManyArgs, 'select' | 'include'> & {
      select?: ParentWalletCountAggregateInputType | true
    }

  export interface ParentWalletDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParentWallet'], meta: { name: 'ParentWallet' } }
    /**
     * Find zero or one ParentWallet that matches the filter.
     * @param {ParentWalletFindUniqueArgs} args - Arguments to find a ParentWallet
     * @example
     * // Get one ParentWallet
     * const parentWallet = await prisma.parentWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParentWalletFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ParentWalletFindUniqueArgs<ExtArgs>>
    ): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ParentWallet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ParentWalletFindUniqueOrThrowArgs} args - Arguments to find a ParentWallet
     * @example
     * // Get one ParentWallet
     * const parentWallet = await prisma.parentWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ParentWalletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentWalletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ParentWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentWalletFindFirstArgs} args - Arguments to find a ParentWallet
     * @example
     * // Get one ParentWallet
     * const parentWallet = await prisma.parentWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParentWalletFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentWalletFindFirstArgs<ExtArgs>>
    ): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ParentWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentWalletFindFirstOrThrowArgs} args - Arguments to find a ParentWallet
     * @example
     * // Get one ParentWallet
     * const parentWallet = await prisma.parentWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ParentWalletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentWalletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ParentWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentWalletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParentWallets
     * const parentWallets = await prisma.parentWallet.findMany()
     * 
     * // Get first 10 ParentWallets
     * const parentWallets = await prisma.parentWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWalletWithIdOnly = await prisma.parentWallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParentWalletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentWalletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ParentWallet.
     * @param {ParentWalletCreateArgs} args - Arguments to create a ParentWallet.
     * @example
     * // Create one ParentWallet
     * const ParentWallet = await prisma.parentWallet.create({
     *   data: {
     *     // ... data to create a ParentWallet
     *   }
     * })
     * 
    **/
    create<T extends ParentWalletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ParentWalletCreateArgs<ExtArgs>>
    ): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ParentWallets.
     *     @param {ParentWalletCreateManyArgs} args - Arguments to create many ParentWallets.
     *     @example
     *     // Create many ParentWallets
     *     const parentWallet = await prisma.parentWallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParentWalletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentWalletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ParentWallet.
     * @param {ParentWalletDeleteArgs} args - Arguments to delete one ParentWallet.
     * @example
     * // Delete one ParentWallet
     * const ParentWallet = await prisma.parentWallet.delete({
     *   where: {
     *     // ... filter to delete one ParentWallet
     *   }
     * })
     * 
    **/
    delete<T extends ParentWalletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ParentWalletDeleteArgs<ExtArgs>>
    ): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ParentWallet.
     * @param {ParentWalletUpdateArgs} args - Arguments to update one ParentWallet.
     * @example
     * // Update one ParentWallet
     * const parentWallet = await prisma.parentWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParentWalletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ParentWalletUpdateArgs<ExtArgs>>
    ): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ParentWallets.
     * @param {ParentWalletDeleteManyArgs} args - Arguments to filter ParentWallets to delete.
     * @example
     * // Delete a few ParentWallets
     * const { count } = await prisma.parentWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParentWalletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentWalletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParentWallets
     * const parentWallet = await prisma.parentWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParentWalletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ParentWalletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParentWallet.
     * @param {ParentWalletUpsertArgs} args - Arguments to update or create a ParentWallet.
     * @example
     * // Update or create a ParentWallet
     * const parentWallet = await prisma.parentWallet.upsert({
     *   create: {
     *     // ... data to create a ParentWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParentWallet we want to update
     *   }
     * })
    **/
    upsert<T extends ParentWalletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ParentWalletUpsertArgs<ExtArgs>>
    ): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ParentWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentWalletCountArgs} args - Arguments to filter ParentWallets to count.
     * @example
     * // Count the number of ParentWallets
     * const count = await prisma.parentWallet.count({
     *   where: {
     *     // ... the filter for the ParentWallets we want to count
     *   }
     * })
    **/
    count<T extends ParentWalletCountArgs>(
      args?: Subset<T, ParentWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParentWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentWalletAggregateArgs>(args: Subset<T, ParentWalletAggregateArgs>): Prisma.PrismaPromise<GetParentWalletAggregateType<T>>

    /**
     * Group by ParentWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentWalletGroupByArgs['orderBy'] }
        : { orderBy?: ParentWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParentWallet model
   */
  readonly fields: ParentWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParentWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentWalletClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    childCryptoWallet<T extends ParentWallet$childCryptoWalletArgs<ExtArgs> = {}>(args?: Subset<T, ParentWallet$childCryptoWalletArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'findMany'> | Null>;

    parentWallet<T extends ParentWallet$parentWalletArgs<ExtArgs> = {}>(args?: Subset<T, ParentWallet$parentWalletArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ParentWallet model
   */ 
  interface ParentWalletFieldRefs {
    readonly id: FieldRef<"ParentWallet", 'Int'>
    readonly walletId: FieldRef<"ParentWallet", 'Int'>
    readonly walletAddress: FieldRef<"ParentWallet", 'String'>
    readonly chain: FieldRef<"ParentWallet", 'String'>
    readonly coin: FieldRef<"ParentWallet", 'String'>
    readonly parentChain: FieldRef<"ParentWallet", 'String'>
    readonly type: FieldRef<"ParentWallet", 'String'>
    readonly subType: FieldRef<"ParentWallet", 'ParentWalletType'>
    readonly lastUsedIndex: FieldRef<"ParentWallet", 'Int'>
    readonly displayName: FieldRef<"ParentWallet", 'String'>
    readonly toBeDisplayed: FieldRef<"ParentWallet", 'Boolean'>
    readonly parentChainIconUrl: FieldRef<"ParentWallet", 'String'>
    readonly createdAt: FieldRef<"ParentWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"ParentWallet", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ParentWallet findUnique
   */
  export type ParentWalletFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * Filter, which ParentWallet to fetch.
     */
    where: ParentWalletWhereUniqueInput
  }


  /**
   * ParentWallet findUniqueOrThrow
   */
  export type ParentWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * Filter, which ParentWallet to fetch.
     */
    where: ParentWalletWhereUniqueInput
  }


  /**
   * ParentWallet findFirst
   */
  export type ParentWalletFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * Filter, which ParentWallet to fetch.
     */
    where?: ParentWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentWallets to fetch.
     */
    orderBy?: ParentWalletOrderByWithRelationInput | ParentWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentWallets.
     */
    cursor?: ParentWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentWallets.
     */
    distinct?: ParentWalletScalarFieldEnum | ParentWalletScalarFieldEnum[]
  }


  /**
   * ParentWallet findFirstOrThrow
   */
  export type ParentWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * Filter, which ParentWallet to fetch.
     */
    where?: ParentWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentWallets to fetch.
     */
    orderBy?: ParentWalletOrderByWithRelationInput | ParentWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentWallets.
     */
    cursor?: ParentWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentWallets.
     */
    distinct?: ParentWalletScalarFieldEnum | ParentWalletScalarFieldEnum[]
  }


  /**
   * ParentWallet findMany
   */
  export type ParentWalletFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * Filter, which ParentWallets to fetch.
     */
    where?: ParentWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentWallets to fetch.
     */
    orderBy?: ParentWalletOrderByWithRelationInput | ParentWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParentWallets.
     */
    cursor?: ParentWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentWallets.
     */
    skip?: number
    distinct?: ParentWalletScalarFieldEnum | ParentWalletScalarFieldEnum[]
  }


  /**
   * ParentWallet create
   */
  export type ParentWalletCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a ParentWallet.
     */
    data: XOR<ParentWalletCreateInput, ParentWalletUncheckedCreateInput>
  }


  /**
   * ParentWallet createMany
   */
  export type ParentWalletCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParentWallets.
     */
    data: ParentWalletCreateManyInput | ParentWalletCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ParentWallet update
   */
  export type ParentWalletUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a ParentWallet.
     */
    data: XOR<ParentWalletUpdateInput, ParentWalletUncheckedUpdateInput>
    /**
     * Choose, which ParentWallet to update.
     */
    where: ParentWalletWhereUniqueInput
  }


  /**
   * ParentWallet updateMany
   */
  export type ParentWalletUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParentWallets.
     */
    data: XOR<ParentWalletUpdateManyMutationInput, ParentWalletUncheckedUpdateManyInput>
    /**
     * Filter which ParentWallets to update
     */
    where?: ParentWalletWhereInput
  }


  /**
   * ParentWallet upsert
   */
  export type ParentWalletUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the ParentWallet to update in case it exists.
     */
    where: ParentWalletWhereUniqueInput
    /**
     * In case the ParentWallet found by the `where` argument doesn't exist, create a new ParentWallet with this data.
     */
    create: XOR<ParentWalletCreateInput, ParentWalletUncheckedCreateInput>
    /**
     * In case the ParentWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentWalletUpdateInput, ParentWalletUncheckedUpdateInput>
  }


  /**
   * ParentWallet delete
   */
  export type ParentWalletDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
    /**
     * Filter which ParentWallet to delete.
     */
    where: ParentWalletWhereUniqueInput
  }


  /**
   * ParentWallet deleteMany
   */
  export type ParentWalletDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentWallets to delete
     */
    where?: ParentWalletWhereInput
  }


  /**
   * ParentWallet.childCryptoWallet
   */
  export type ParentWallet$childCryptoWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    where?: CryptoWalletWhereInput
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    cursor?: CryptoWalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }


  /**
   * ParentWallet.parentWallet
   */
  export type ParentWallet$parentWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    where?: StableCoinWhereInput
    orderBy?: StableCoinOrderByWithRelationInput | StableCoinOrderByWithRelationInput[]
    cursor?: StableCoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StableCoinScalarFieldEnum | StableCoinScalarFieldEnum[]
  }


  /**
   * ParentWallet without action
   */
  export type ParentWalletDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentWallet
     */
    select?: ParentWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentWalletInclude<ExtArgs> | null
  }



  /**
   * Model StableCoin
   */

  export type AggregateStableCoin = {
    _count: StableCoinCountAggregateOutputType | null
    _avg: StableCoinAvgAggregateOutputType | null
    _sum: StableCoinSumAggregateOutputType | null
    _min: StableCoinMinAggregateOutputType | null
    _max: StableCoinMaxAggregateOutputType | null
  }

  export type StableCoinAvgAggregateOutputType = {
    id: number | null
    parentWalletId: number | null
  }

  export type StableCoinSumAggregateOutputType = {
    id: number | null
    parentWalletId: number | null
  }

  export type StableCoinMinAggregateOutputType = {
    id: number | null
    parentWalletId: number | null
    token: string | null
    parentChain: string | null
    tokenIconUrl: string | null
  }

  export type StableCoinMaxAggregateOutputType = {
    id: number | null
    parentWalletId: number | null
    token: string | null
    parentChain: string | null
    tokenIconUrl: string | null
  }

  export type StableCoinCountAggregateOutputType = {
    id: number
    parentWalletId: number
    token: number
    parentChain: number
    tokenIconUrl: number
    _all: number
  }


  export type StableCoinAvgAggregateInputType = {
    id?: true
    parentWalletId?: true
  }

  export type StableCoinSumAggregateInputType = {
    id?: true
    parentWalletId?: true
  }

  export type StableCoinMinAggregateInputType = {
    id?: true
    parentWalletId?: true
    token?: true
    parentChain?: true
    tokenIconUrl?: true
  }

  export type StableCoinMaxAggregateInputType = {
    id?: true
    parentWalletId?: true
    token?: true
    parentChain?: true
    tokenIconUrl?: true
  }

  export type StableCoinCountAggregateInputType = {
    id?: true
    parentWalletId?: true
    token?: true
    parentChain?: true
    tokenIconUrl?: true
    _all?: true
  }

  export type StableCoinAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StableCoin to aggregate.
     */
    where?: StableCoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StableCoins to fetch.
     */
    orderBy?: StableCoinOrderByWithRelationInput | StableCoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StableCoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StableCoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StableCoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StableCoins
    **/
    _count?: true | StableCoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StableCoinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StableCoinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StableCoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StableCoinMaxAggregateInputType
  }

  export type GetStableCoinAggregateType<T extends StableCoinAggregateArgs> = {
        [P in keyof T & keyof AggregateStableCoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStableCoin[P]>
      : GetScalarType<T[P], AggregateStableCoin[P]>
  }




  export type StableCoinGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StableCoinWhereInput
    orderBy?: StableCoinOrderByWithAggregationInput | StableCoinOrderByWithAggregationInput[]
    by: StableCoinScalarFieldEnum[] | StableCoinScalarFieldEnum
    having?: StableCoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StableCoinCountAggregateInputType | true
    _avg?: StableCoinAvgAggregateInputType
    _sum?: StableCoinSumAggregateInputType
    _min?: StableCoinMinAggregateInputType
    _max?: StableCoinMaxAggregateInputType
  }

  export type StableCoinGroupByOutputType = {
    id: number
    parentWalletId: number
    token: string
    parentChain: string
    tokenIconUrl: string | null
    _count: StableCoinCountAggregateOutputType | null
    _avg: StableCoinAvgAggregateOutputType | null
    _sum: StableCoinSumAggregateOutputType | null
    _min: StableCoinMinAggregateOutputType | null
    _max: StableCoinMaxAggregateOutputType | null
  }

  type GetStableCoinGroupByPayload<T extends StableCoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StableCoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StableCoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StableCoinGroupByOutputType[P]>
            : GetScalarType<T[P], StableCoinGroupByOutputType[P]>
        }
      >
    >


  export type StableCoinSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentWalletId?: boolean
    token?: boolean
    parentChain?: boolean
    tokenIconUrl?: boolean
    parentWallet?: boolean | ParentWalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stableCoin"]>

  export type StableCoinSelectScalar = {
    id?: boolean
    parentWalletId?: boolean
    token?: boolean
    parentChain?: boolean
    tokenIconUrl?: boolean
  }

  export type StableCoinInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    parentWallet?: boolean | ParentWalletDefaultArgs<ExtArgs>
  }


  export type $StableCoinPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StableCoin"
    objects: {
      parentWallet: Prisma.$ParentWalletPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      parentWalletId: number
      token: string
      parentChain: string
      tokenIconUrl: string | null
    }, ExtArgs["result"]["stableCoin"]>
    composites: {}
  }


  type StableCoinGetPayload<S extends boolean | null | undefined | StableCoinDefaultArgs> = $Result.GetResult<Prisma.$StableCoinPayload, S>

  type StableCoinCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StableCoinFindManyArgs, 'select' | 'include'> & {
      select?: StableCoinCountAggregateInputType | true
    }

  export interface StableCoinDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StableCoin'], meta: { name: 'StableCoin' } }
    /**
     * Find zero or one StableCoin that matches the filter.
     * @param {StableCoinFindUniqueArgs} args - Arguments to find a StableCoin
     * @example
     * // Get one StableCoin
     * const stableCoin = await prisma.stableCoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StableCoinFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StableCoinFindUniqueArgs<ExtArgs>>
    ): Prisma__StableCoinClient<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StableCoin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StableCoinFindUniqueOrThrowArgs} args - Arguments to find a StableCoin
     * @example
     * // Get one StableCoin
     * const stableCoin = await prisma.stableCoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StableCoinFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StableCoinFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StableCoinClient<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StableCoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StableCoinFindFirstArgs} args - Arguments to find a StableCoin
     * @example
     * // Get one StableCoin
     * const stableCoin = await prisma.stableCoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StableCoinFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StableCoinFindFirstArgs<ExtArgs>>
    ): Prisma__StableCoinClient<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StableCoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StableCoinFindFirstOrThrowArgs} args - Arguments to find a StableCoin
     * @example
     * // Get one StableCoin
     * const stableCoin = await prisma.stableCoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StableCoinFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StableCoinFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StableCoinClient<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StableCoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StableCoinFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StableCoins
     * const stableCoins = await prisma.stableCoin.findMany()
     * 
     * // Get first 10 StableCoins
     * const stableCoins = await prisma.stableCoin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stableCoinWithIdOnly = await prisma.stableCoin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StableCoinFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StableCoinFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StableCoin.
     * @param {StableCoinCreateArgs} args - Arguments to create a StableCoin.
     * @example
     * // Create one StableCoin
     * const StableCoin = await prisma.stableCoin.create({
     *   data: {
     *     // ... data to create a StableCoin
     *   }
     * })
     * 
    **/
    create<T extends StableCoinCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StableCoinCreateArgs<ExtArgs>>
    ): Prisma__StableCoinClient<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StableCoins.
     *     @param {StableCoinCreateManyArgs} args - Arguments to create many StableCoins.
     *     @example
     *     // Create many StableCoins
     *     const stableCoin = await prisma.stableCoin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StableCoinCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StableCoinCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StableCoin.
     * @param {StableCoinDeleteArgs} args - Arguments to delete one StableCoin.
     * @example
     * // Delete one StableCoin
     * const StableCoin = await prisma.stableCoin.delete({
     *   where: {
     *     // ... filter to delete one StableCoin
     *   }
     * })
     * 
    **/
    delete<T extends StableCoinDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StableCoinDeleteArgs<ExtArgs>>
    ): Prisma__StableCoinClient<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StableCoin.
     * @param {StableCoinUpdateArgs} args - Arguments to update one StableCoin.
     * @example
     * // Update one StableCoin
     * const stableCoin = await prisma.stableCoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StableCoinUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StableCoinUpdateArgs<ExtArgs>>
    ): Prisma__StableCoinClient<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StableCoins.
     * @param {StableCoinDeleteManyArgs} args - Arguments to filter StableCoins to delete.
     * @example
     * // Delete a few StableCoins
     * const { count } = await prisma.stableCoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StableCoinDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StableCoinDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StableCoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StableCoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StableCoins
     * const stableCoin = await prisma.stableCoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StableCoinUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StableCoinUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StableCoin.
     * @param {StableCoinUpsertArgs} args - Arguments to update or create a StableCoin.
     * @example
     * // Update or create a StableCoin
     * const stableCoin = await prisma.stableCoin.upsert({
     *   create: {
     *     // ... data to create a StableCoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StableCoin we want to update
     *   }
     * })
    **/
    upsert<T extends StableCoinUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StableCoinUpsertArgs<ExtArgs>>
    ): Prisma__StableCoinClient<$Result.GetResult<Prisma.$StableCoinPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StableCoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StableCoinCountArgs} args - Arguments to filter StableCoins to count.
     * @example
     * // Count the number of StableCoins
     * const count = await prisma.stableCoin.count({
     *   where: {
     *     // ... the filter for the StableCoins we want to count
     *   }
     * })
    **/
    count<T extends StableCoinCountArgs>(
      args?: Subset<T, StableCoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StableCoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StableCoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StableCoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StableCoinAggregateArgs>(args: Subset<T, StableCoinAggregateArgs>): Prisma.PrismaPromise<GetStableCoinAggregateType<T>>

    /**
     * Group by StableCoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StableCoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StableCoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StableCoinGroupByArgs['orderBy'] }
        : { orderBy?: StableCoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StableCoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStableCoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StableCoin model
   */
  readonly fields: StableCoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StableCoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StableCoinClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parentWallet<T extends ParentWalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentWalletDefaultArgs<ExtArgs>>): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StableCoin model
   */ 
  interface StableCoinFieldRefs {
    readonly id: FieldRef<"StableCoin", 'Int'>
    readonly parentWalletId: FieldRef<"StableCoin", 'Int'>
    readonly token: FieldRef<"StableCoin", 'String'>
    readonly parentChain: FieldRef<"StableCoin", 'String'>
    readonly tokenIconUrl: FieldRef<"StableCoin", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StableCoin findUnique
   */
  export type StableCoinFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * Filter, which StableCoin to fetch.
     */
    where: StableCoinWhereUniqueInput
  }


  /**
   * StableCoin findUniqueOrThrow
   */
  export type StableCoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * Filter, which StableCoin to fetch.
     */
    where: StableCoinWhereUniqueInput
  }


  /**
   * StableCoin findFirst
   */
  export type StableCoinFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * Filter, which StableCoin to fetch.
     */
    where?: StableCoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StableCoins to fetch.
     */
    orderBy?: StableCoinOrderByWithRelationInput | StableCoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StableCoins.
     */
    cursor?: StableCoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StableCoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StableCoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StableCoins.
     */
    distinct?: StableCoinScalarFieldEnum | StableCoinScalarFieldEnum[]
  }


  /**
   * StableCoin findFirstOrThrow
   */
  export type StableCoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * Filter, which StableCoin to fetch.
     */
    where?: StableCoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StableCoins to fetch.
     */
    orderBy?: StableCoinOrderByWithRelationInput | StableCoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StableCoins.
     */
    cursor?: StableCoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StableCoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StableCoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StableCoins.
     */
    distinct?: StableCoinScalarFieldEnum | StableCoinScalarFieldEnum[]
  }


  /**
   * StableCoin findMany
   */
  export type StableCoinFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * Filter, which StableCoins to fetch.
     */
    where?: StableCoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StableCoins to fetch.
     */
    orderBy?: StableCoinOrderByWithRelationInput | StableCoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StableCoins.
     */
    cursor?: StableCoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StableCoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StableCoins.
     */
    skip?: number
    distinct?: StableCoinScalarFieldEnum | StableCoinScalarFieldEnum[]
  }


  /**
   * StableCoin create
   */
  export type StableCoinCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * The data needed to create a StableCoin.
     */
    data: XOR<StableCoinCreateInput, StableCoinUncheckedCreateInput>
  }


  /**
   * StableCoin createMany
   */
  export type StableCoinCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StableCoins.
     */
    data: StableCoinCreateManyInput | StableCoinCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StableCoin update
   */
  export type StableCoinUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * The data needed to update a StableCoin.
     */
    data: XOR<StableCoinUpdateInput, StableCoinUncheckedUpdateInput>
    /**
     * Choose, which StableCoin to update.
     */
    where: StableCoinWhereUniqueInput
  }


  /**
   * StableCoin updateMany
   */
  export type StableCoinUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StableCoins.
     */
    data: XOR<StableCoinUpdateManyMutationInput, StableCoinUncheckedUpdateManyInput>
    /**
     * Filter which StableCoins to update
     */
    where?: StableCoinWhereInput
  }


  /**
   * StableCoin upsert
   */
  export type StableCoinUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * The filter to search for the StableCoin to update in case it exists.
     */
    where: StableCoinWhereUniqueInput
    /**
     * In case the StableCoin found by the `where` argument doesn't exist, create a new StableCoin with this data.
     */
    create: XOR<StableCoinCreateInput, StableCoinUncheckedCreateInput>
    /**
     * In case the StableCoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StableCoinUpdateInput, StableCoinUncheckedUpdateInput>
  }


  /**
   * StableCoin delete
   */
  export type StableCoinDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
    /**
     * Filter which StableCoin to delete.
     */
    where: StableCoinWhereUniqueInput
  }


  /**
   * StableCoin deleteMany
   */
  export type StableCoinDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StableCoins to delete
     */
    where?: StableCoinWhereInput
  }


  /**
   * StableCoin without action
   */
  export type StableCoinDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StableCoin
     */
    select?: StableCoinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StableCoinInclude<ExtArgs> | null
  }



  /**
   * Model CryptoWallet
   */

  export type AggregateCryptoWallet = {
    _count: CryptoWalletCountAggregateOutputType | null
    _avg: CryptoWalletAvgAggregateOutputType | null
    _sum: CryptoWalletSumAggregateOutputType | null
    _min: CryptoWalletMinAggregateOutputType | null
    _max: CryptoWalletMaxAggregateOutputType | null
  }

  export type CryptoWalletAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    parentWalletId: number | null
    liminalParentId: number | null
    balance: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CryptoWalletSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    parentWalletId: number | null
    liminalParentId: number | null
    balance: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CryptoWalletMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    parentWalletId: number | null
    liminalRefId: string | null
    liminalParentId: number | null
    liminalCoin: string | null
    liminalChain: string | null
    publicAddress: string | null
    balance: number | null
    lastConversion: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CryptoWalletMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    parentWalletId: number | null
    liminalRefId: string | null
    liminalParentId: number | null
    liminalCoin: string | null
    liminalChain: string | null
    publicAddress: string | null
    balance: number | null
    lastConversion: Date | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CryptoWalletCountAggregateOutputType = {
    id: number
    accountId: number
    parentWalletId: number
    liminalRefId: number
    liminalParentId: number
    liminalCoin: number
    liminalChain: number
    publicAddress: number
    balance: number
    lastConversion: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type CryptoWalletAvgAggregateInputType = {
    id?: true
    accountId?: true
    parentWalletId?: true
    liminalParentId?: true
    balance?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CryptoWalletSumAggregateInputType = {
    id?: true
    accountId?: true
    parentWalletId?: true
    liminalParentId?: true
    balance?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CryptoWalletMinAggregateInputType = {
    id?: true
    accountId?: true
    parentWalletId?: true
    liminalRefId?: true
    liminalParentId?: true
    liminalCoin?: true
    liminalChain?: true
    publicAddress?: true
    balance?: true
    lastConversion?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CryptoWalletMaxAggregateInputType = {
    id?: true
    accountId?: true
    parentWalletId?: true
    liminalRefId?: true
    liminalParentId?: true
    liminalCoin?: true
    liminalChain?: true
    publicAddress?: true
    balance?: true
    lastConversion?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CryptoWalletCountAggregateInputType = {
    id?: true
    accountId?: true
    parentWalletId?: true
    liminalRefId?: true
    liminalParentId?: true
    liminalCoin?: true
    liminalChain?: true
    publicAddress?: true
    balance?: true
    lastConversion?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type CryptoWalletAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoWallet to aggregate.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoWallets
    **/
    _count?: true | CryptoWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoWalletMaxAggregateInputType
  }

  export type GetCryptoWalletAggregateType<T extends CryptoWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoWallet[P]>
      : GetScalarType<T[P], AggregateCryptoWallet[P]>
  }




  export type CryptoWalletGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CryptoWalletWhereInput
    orderBy?: CryptoWalletOrderByWithAggregationInput | CryptoWalletOrderByWithAggregationInput[]
    by: CryptoWalletScalarFieldEnum[] | CryptoWalletScalarFieldEnum
    having?: CryptoWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoWalletCountAggregateInputType | true
    _avg?: CryptoWalletAvgAggregateInputType
    _sum?: CryptoWalletSumAggregateInputType
    _min?: CryptoWalletMinAggregateInputType
    _max?: CryptoWalletMaxAggregateInputType
  }

  export type CryptoWalletGroupByOutputType = {
    id: number
    accountId: number | null
    parentWalletId: number
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance: number
    lastConversion: Date | null
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: CryptoWalletCountAggregateOutputType | null
    _avg: CryptoWalletAvgAggregateOutputType | null
    _sum: CryptoWalletSumAggregateOutputType | null
    _min: CryptoWalletMinAggregateOutputType | null
    _max: CryptoWalletMaxAggregateOutputType | null
  }

  type GetCryptoWalletGroupByPayload<T extends CryptoWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoWalletGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoWalletGroupByOutputType[P]>
        }
      >
    >


  export type CryptoWalletSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    parentWalletId?: boolean
    liminalRefId?: boolean
    liminalParentId?: boolean
    liminalCoin?: boolean
    liminalChain?: boolean
    publicAddress?: boolean
    balance?: boolean
    lastConversion?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    account?: boolean | CryptoWallet$accountArgs<ExtArgs>
    parentWallet?: boolean | ParentWalletDefaultArgs<ExtArgs>
    cryptoDeposit?: boolean | CryptoWallet$cryptoDepositArgs<ExtArgs>
    _count?: boolean | CryptoWalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectScalar = {
    id?: boolean
    accountId?: boolean
    parentWalletId?: boolean
    liminalRefId?: boolean
    liminalParentId?: boolean
    liminalCoin?: boolean
    liminalChain?: boolean
    publicAddress?: boolean
    balance?: boolean
    lastConversion?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type CryptoWalletInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    account?: boolean | CryptoWallet$accountArgs<ExtArgs>
    parentWallet?: boolean | ParentWalletDefaultArgs<ExtArgs>
    cryptoDeposit?: boolean | CryptoWallet$cryptoDepositArgs<ExtArgs>
    _count?: boolean | CryptoWalletCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CryptoWalletPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CryptoWallet"
    objects: {
      account: Prisma.$UserAccountPayload<ExtArgs> | null
      parentWallet: Prisma.$ParentWalletPayload<ExtArgs>
      cryptoDeposit: Prisma.$CryptoDepositPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      accountId: number | null
      parentWalletId: number
      liminalRefId: string
      liminalParentId: number
      liminalCoin: string
      liminalChain: string
      publicAddress: string
      balance: number
      lastConversion: Date | null
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["cryptoWallet"]>
    composites: {}
  }


  type CryptoWalletGetPayload<S extends boolean | null | undefined | CryptoWalletDefaultArgs> = $Result.GetResult<Prisma.$CryptoWalletPayload, S>

  type CryptoWalletCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CryptoWalletFindManyArgs, 'select' | 'include'> & {
      select?: CryptoWalletCountAggregateInputType | true
    }

  export interface CryptoWalletDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoWallet'], meta: { name: 'CryptoWallet' } }
    /**
     * Find zero or one CryptoWallet that matches the filter.
     * @param {CryptoWalletFindUniqueArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CryptoWalletFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoWalletFindUniqueArgs<ExtArgs>>
    ): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CryptoWallet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CryptoWalletFindUniqueOrThrowArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CryptoWalletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoWalletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CryptoWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindFirstArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CryptoWalletFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoWalletFindFirstArgs<ExtArgs>>
    ): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CryptoWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindFirstOrThrowArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CryptoWalletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoWalletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CryptoWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoWallets
     * const cryptoWallets = await prisma.cryptoWallet.findMany()
     * 
     * // Get first 10 CryptoWallets
     * const cryptoWallets = await prisma.cryptoWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CryptoWalletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoWalletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CryptoWallet.
     * @param {CryptoWalletCreateArgs} args - Arguments to create a CryptoWallet.
     * @example
     * // Create one CryptoWallet
     * const CryptoWallet = await prisma.cryptoWallet.create({
     *   data: {
     *     // ... data to create a CryptoWallet
     *   }
     * })
     * 
    **/
    create<T extends CryptoWalletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoWalletCreateArgs<ExtArgs>>
    ): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CryptoWallets.
     *     @param {CryptoWalletCreateManyArgs} args - Arguments to create many CryptoWallets.
     *     @example
     *     // Create many CryptoWallets
     *     const cryptoWallet = await prisma.cryptoWallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CryptoWalletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoWalletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CryptoWallet.
     * @param {CryptoWalletDeleteArgs} args - Arguments to delete one CryptoWallet.
     * @example
     * // Delete one CryptoWallet
     * const CryptoWallet = await prisma.cryptoWallet.delete({
     *   where: {
     *     // ... filter to delete one CryptoWallet
     *   }
     * })
     * 
    **/
    delete<T extends CryptoWalletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoWalletDeleteArgs<ExtArgs>>
    ): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CryptoWallet.
     * @param {CryptoWalletUpdateArgs} args - Arguments to update one CryptoWallet.
     * @example
     * // Update one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CryptoWalletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoWalletUpdateArgs<ExtArgs>>
    ): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CryptoWallets.
     * @param {CryptoWalletDeleteManyArgs} args - Arguments to filter CryptoWallets to delete.
     * @example
     * // Delete a few CryptoWallets
     * const { count } = await prisma.cryptoWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CryptoWalletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CryptoWalletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CryptoWalletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoWalletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoWallet.
     * @param {CryptoWalletUpsertArgs} args - Arguments to update or create a CryptoWallet.
     * @example
     * // Update or create a CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.upsert({
     *   create: {
     *     // ... data to create a CryptoWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoWallet we want to update
     *   }
     * })
    **/
    upsert<T extends CryptoWalletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CryptoWalletUpsertArgs<ExtArgs>>
    ): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CryptoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletCountArgs} args - Arguments to filter CryptoWallets to count.
     * @example
     * // Count the number of CryptoWallets
     * const count = await prisma.cryptoWallet.count({
     *   where: {
     *     // ... the filter for the CryptoWallets we want to count
     *   }
     * })
    **/
    count<T extends CryptoWalletCountArgs>(
      args?: Subset<T, CryptoWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoWalletAggregateArgs>(args: Subset<T, CryptoWalletAggregateArgs>): Prisma.PrismaPromise<GetCryptoWalletAggregateType<T>>

    /**
     * Group by CryptoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoWalletGroupByArgs['orderBy'] }
        : { orderBy?: CryptoWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoWallet model
   */
  readonly fields: CryptoWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoWalletClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends CryptoWallet$accountArgs<ExtArgs> = {}>(args?: Subset<T, CryptoWallet$accountArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    parentWallet<T extends ParentWalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentWalletDefaultArgs<ExtArgs>>): Prisma__ParentWalletClient<$Result.GetResult<Prisma.$ParentWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cryptoDeposit<T extends CryptoWallet$cryptoDepositArgs<ExtArgs> = {}>(args?: Subset<T, CryptoWallet$cryptoDepositArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoDepositPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CryptoWallet model
   */ 
  interface CryptoWalletFieldRefs {
    readonly id: FieldRef<"CryptoWallet", 'Int'>
    readonly accountId: FieldRef<"CryptoWallet", 'Int'>
    readonly parentWalletId: FieldRef<"CryptoWallet", 'Int'>
    readonly liminalRefId: FieldRef<"CryptoWallet", 'String'>
    readonly liminalParentId: FieldRef<"CryptoWallet", 'Int'>
    readonly liminalCoin: FieldRef<"CryptoWallet", 'String'>
    readonly liminalChain: FieldRef<"CryptoWallet", 'String'>
    readonly publicAddress: FieldRef<"CryptoWallet", 'String'>
    readonly balance: FieldRef<"CryptoWallet", 'Float'>
    readonly lastConversion: FieldRef<"CryptoWallet", 'DateTime'>
    readonly createdAt: FieldRef<"CryptoWallet", 'DateTime'>
    readonly createdBy: FieldRef<"CryptoWallet", 'Int'>
    readonly updatedAt: FieldRef<"CryptoWallet", 'DateTime'>
    readonly updatedBy: FieldRef<"CryptoWallet", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CryptoWallet findUnique
   */
  export type CryptoWalletFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where: CryptoWalletWhereUniqueInput
  }


  /**
   * CryptoWallet findUniqueOrThrow
   */
  export type CryptoWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where: CryptoWalletWhereUniqueInput
  }


  /**
   * CryptoWallet findFirst
   */
  export type CryptoWalletFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoWallets.
     */
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }


  /**
   * CryptoWallet findFirstOrThrow
   */
  export type CryptoWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoWallets.
     */
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }


  /**
   * CryptoWallet findMany
   */
  export type CryptoWalletFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallets to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }


  /**
   * CryptoWallet create
   */
  export type CryptoWalletCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoWallet.
     */
    data: XOR<CryptoWalletCreateInput, CryptoWalletUncheckedCreateInput>
  }


  /**
   * CryptoWallet createMany
   */
  export type CryptoWalletCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoWallets.
     */
    data: CryptoWalletCreateManyInput | CryptoWalletCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CryptoWallet update
   */
  export type CryptoWalletUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoWallet.
     */
    data: XOR<CryptoWalletUpdateInput, CryptoWalletUncheckedUpdateInput>
    /**
     * Choose, which CryptoWallet to update.
     */
    where: CryptoWalletWhereUniqueInput
  }


  /**
   * CryptoWallet updateMany
   */
  export type CryptoWalletUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoWallets.
     */
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyInput>
    /**
     * Filter which CryptoWallets to update
     */
    where?: CryptoWalletWhereInput
  }


  /**
   * CryptoWallet upsert
   */
  export type CryptoWalletUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoWallet to update in case it exists.
     */
    where: CryptoWalletWhereUniqueInput
    /**
     * In case the CryptoWallet found by the `where` argument doesn't exist, create a new CryptoWallet with this data.
     */
    create: XOR<CryptoWalletCreateInput, CryptoWalletUncheckedCreateInput>
    /**
     * In case the CryptoWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoWalletUpdateInput, CryptoWalletUncheckedUpdateInput>
  }


  /**
   * CryptoWallet delete
   */
  export type CryptoWalletDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter which CryptoWallet to delete.
     */
    where: CryptoWalletWhereUniqueInput
  }


  /**
   * CryptoWallet deleteMany
   */
  export type CryptoWalletDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoWallets to delete
     */
    where?: CryptoWalletWhereInput
  }


  /**
   * CryptoWallet.account
   */
  export type CryptoWallet$accountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
  }


  /**
   * CryptoWallet.cryptoDeposit
   */
  export type CryptoWallet$cryptoDepositArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoDeposit
     */
    select?: CryptoDepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoDepositInclude<ExtArgs> | null
    where?: CryptoDepositWhereInput
    orderBy?: CryptoDepositOrderByWithRelationInput | CryptoDepositOrderByWithRelationInput[]
    cursor?: CryptoDepositWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoDepositScalarFieldEnum | CryptoDepositScalarFieldEnum[]
  }


  /**
   * CryptoWallet without action
   */
  export type CryptoWalletDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CryptoWalletInclude<ExtArgs> | null
  }



  /**
   * Model PerpetualContracts
   */

  export type AggregatePerpetualContracts = {
    _count: PerpetualContractsCountAggregateOutputType | null
    _avg: PerpetualContractsAvgAggregateOutputType | null
    _sum: PerpetualContractsSumAggregateOutputType | null
    _min: PerpetualContractsMinAggregateOutputType | null
    _max: PerpetualContractsMaxAggregateOutputType | null
  }

  export type PerpetualContractsAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type PerpetualContractsSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type PerpetualContractsMinAggregateOutputType = {
    id: number | null
    contractSymbol: string | null
    displayName: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type PerpetualContractsMaxAggregateOutputType = {
    id: number | null
    contractSymbol: string | null
    displayName: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type PerpetualContractsCountAggregateOutputType = {
    id: number
    contractSymbol: number
    displayName: number
    systemConfig: number
    exchangeConfig: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type PerpetualContractsAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PerpetualContractsSumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PerpetualContractsMinAggregateInputType = {
    id?: true
    contractSymbol?: true
    displayName?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PerpetualContractsMaxAggregateInputType = {
    id?: true
    contractSymbol?: true
    displayName?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PerpetualContractsCountAggregateInputType = {
    id?: true
    contractSymbol?: true
    displayName?: true
    systemConfig?: true
    exchangeConfig?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type PerpetualContractsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerpetualContracts to aggregate.
     */
    where?: PerpetualContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerpetualContracts to fetch.
     */
    orderBy?: PerpetualContractsOrderByWithRelationInput | PerpetualContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerpetualContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerpetualContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerpetualContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerpetualContracts
    **/
    _count?: true | PerpetualContractsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerpetualContractsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerpetualContractsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerpetualContractsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerpetualContractsMaxAggregateInputType
  }

  export type GetPerpetualContractsAggregateType<T extends PerpetualContractsAggregateArgs> = {
        [P in keyof T & keyof AggregatePerpetualContracts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerpetualContracts[P]>
      : GetScalarType<T[P], AggregatePerpetualContracts[P]>
  }




  export type PerpetualContractsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PerpetualContractsWhereInput
    orderBy?: PerpetualContractsOrderByWithAggregationInput | PerpetualContractsOrderByWithAggregationInput[]
    by: PerpetualContractsScalarFieldEnum[] | PerpetualContractsScalarFieldEnum
    having?: PerpetualContractsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerpetualContractsCountAggregateInputType | true
    _avg?: PerpetualContractsAvgAggregateInputType
    _sum?: PerpetualContractsSumAggregateInputType
    _min?: PerpetualContractsMinAggregateInputType
    _max?: PerpetualContractsMaxAggregateInputType
  }

  export type PerpetualContractsGroupByOutputType = {
    id: number
    contractSymbol: string
    displayName: string
    systemConfig: JsonValue
    exchangeConfig: JsonValue
    isActive: boolean
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: PerpetualContractsCountAggregateOutputType | null
    _avg: PerpetualContractsAvgAggregateOutputType | null
    _sum: PerpetualContractsSumAggregateOutputType | null
    _min: PerpetualContractsMinAggregateOutputType | null
    _max: PerpetualContractsMaxAggregateOutputType | null
  }

  type GetPerpetualContractsGroupByPayload<T extends PerpetualContractsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerpetualContractsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerpetualContractsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerpetualContractsGroupByOutputType[P]>
            : GetScalarType<T[P], PerpetualContractsGroupByOutputType[P]>
        }
      >
    >


  export type PerpetualContractsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractSymbol?: boolean
    displayName?: boolean
    systemConfig?: boolean
    exchangeConfig?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["perpetualContracts"]>

  export type PerpetualContractsSelectScalar = {
    id?: boolean
    contractSymbol?: boolean
    displayName?: boolean
    systemConfig?: boolean
    exchangeConfig?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $PerpetualContractsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "PerpetualContracts"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      contractSymbol: string
      displayName: string
      systemConfig: Prisma.JsonValue
      exchangeConfig: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["perpetualContracts"]>
    composites: {}
  }


  type PerpetualContractsGetPayload<S extends boolean | null | undefined | PerpetualContractsDefaultArgs> = $Result.GetResult<Prisma.$PerpetualContractsPayload, S>

  type PerpetualContractsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PerpetualContractsFindManyArgs, 'select' | 'include'> & {
      select?: PerpetualContractsCountAggregateInputType | true
    }

  export interface PerpetualContractsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerpetualContracts'], meta: { name: 'PerpetualContracts' } }
    /**
     * Find zero or one PerpetualContracts that matches the filter.
     * @param {PerpetualContractsFindUniqueArgs} args - Arguments to find a PerpetualContracts
     * @example
     * // Get one PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PerpetualContractsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PerpetualContractsFindUniqueArgs<ExtArgs>>
    ): Prisma__PerpetualContractsClient<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PerpetualContracts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PerpetualContractsFindUniqueOrThrowArgs} args - Arguments to find a PerpetualContracts
     * @example
     * // Get one PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PerpetualContractsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PerpetualContractsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PerpetualContractsClient<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PerpetualContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerpetualContractsFindFirstArgs} args - Arguments to find a PerpetualContracts
     * @example
     * // Get one PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PerpetualContractsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PerpetualContractsFindFirstArgs<ExtArgs>>
    ): Prisma__PerpetualContractsClient<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PerpetualContracts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerpetualContractsFindFirstOrThrowArgs} args - Arguments to find a PerpetualContracts
     * @example
     * // Get one PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PerpetualContractsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PerpetualContractsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PerpetualContractsClient<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PerpetualContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerpetualContractsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.findMany()
     * 
     * // Get first 10 PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perpetualContractsWithIdOnly = await prisma.perpetualContracts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PerpetualContractsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerpetualContractsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PerpetualContracts.
     * @param {PerpetualContractsCreateArgs} args - Arguments to create a PerpetualContracts.
     * @example
     * // Create one PerpetualContracts
     * const PerpetualContracts = await prisma.perpetualContracts.create({
     *   data: {
     *     // ... data to create a PerpetualContracts
     *   }
     * })
     * 
    **/
    create<T extends PerpetualContractsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PerpetualContractsCreateArgs<ExtArgs>>
    ): Prisma__PerpetualContractsClient<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PerpetualContracts.
     *     @param {PerpetualContractsCreateManyArgs} args - Arguments to create many PerpetualContracts.
     *     @example
     *     // Create many PerpetualContracts
     *     const perpetualContracts = await prisma.perpetualContracts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PerpetualContractsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerpetualContractsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PerpetualContracts.
     * @param {PerpetualContractsDeleteArgs} args - Arguments to delete one PerpetualContracts.
     * @example
     * // Delete one PerpetualContracts
     * const PerpetualContracts = await prisma.perpetualContracts.delete({
     *   where: {
     *     // ... filter to delete one PerpetualContracts
     *   }
     * })
     * 
    **/
    delete<T extends PerpetualContractsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PerpetualContractsDeleteArgs<ExtArgs>>
    ): Prisma__PerpetualContractsClient<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PerpetualContracts.
     * @param {PerpetualContractsUpdateArgs} args - Arguments to update one PerpetualContracts.
     * @example
     * // Update one PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PerpetualContractsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PerpetualContractsUpdateArgs<ExtArgs>>
    ): Prisma__PerpetualContractsClient<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PerpetualContracts.
     * @param {PerpetualContractsDeleteManyArgs} args - Arguments to filter PerpetualContracts to delete.
     * @example
     * // Delete a few PerpetualContracts
     * const { count } = await prisma.perpetualContracts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PerpetualContractsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerpetualContractsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerpetualContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerpetualContractsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PerpetualContractsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PerpetualContractsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerpetualContracts.
     * @param {PerpetualContractsUpsertArgs} args - Arguments to update or create a PerpetualContracts.
     * @example
     * // Update or create a PerpetualContracts
     * const perpetualContracts = await prisma.perpetualContracts.upsert({
     *   create: {
     *     // ... data to create a PerpetualContracts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerpetualContracts we want to update
     *   }
     * })
    **/
    upsert<T extends PerpetualContractsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PerpetualContractsUpsertArgs<ExtArgs>>
    ): Prisma__PerpetualContractsClient<$Result.GetResult<Prisma.$PerpetualContractsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PerpetualContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerpetualContractsCountArgs} args - Arguments to filter PerpetualContracts to count.
     * @example
     * // Count the number of PerpetualContracts
     * const count = await prisma.perpetualContracts.count({
     *   where: {
     *     // ... the filter for the PerpetualContracts we want to count
     *   }
     * })
    **/
    count<T extends PerpetualContractsCountArgs>(
      args?: Subset<T, PerpetualContractsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerpetualContractsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerpetualContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerpetualContractsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerpetualContractsAggregateArgs>(args: Subset<T, PerpetualContractsAggregateArgs>): Prisma.PrismaPromise<GetPerpetualContractsAggregateType<T>>

    /**
     * Group by PerpetualContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerpetualContractsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerpetualContractsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerpetualContractsGroupByArgs['orderBy'] }
        : { orderBy?: PerpetualContractsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerpetualContractsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerpetualContractsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerpetualContracts model
   */
  readonly fields: PerpetualContractsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerpetualContracts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerpetualContractsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PerpetualContracts model
   */ 
  interface PerpetualContractsFieldRefs {
    readonly id: FieldRef<"PerpetualContracts", 'Int'>
    readonly contractSymbol: FieldRef<"PerpetualContracts", 'String'>
    readonly displayName: FieldRef<"PerpetualContracts", 'String'>
    readonly systemConfig: FieldRef<"PerpetualContracts", 'Json'>
    readonly exchangeConfig: FieldRef<"PerpetualContracts", 'Json'>
    readonly isActive: FieldRef<"PerpetualContracts", 'Boolean'>
    readonly createdAt: FieldRef<"PerpetualContracts", 'DateTime'>
    readonly createdBy: FieldRef<"PerpetualContracts", 'Int'>
    readonly updatedAt: FieldRef<"PerpetualContracts", 'DateTime'>
    readonly updatedBy: FieldRef<"PerpetualContracts", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PerpetualContracts findUnique
   */
  export type PerpetualContractsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * Filter, which PerpetualContracts to fetch.
     */
    where: PerpetualContractsWhereUniqueInput
  }


  /**
   * PerpetualContracts findUniqueOrThrow
   */
  export type PerpetualContractsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * Filter, which PerpetualContracts to fetch.
     */
    where: PerpetualContractsWhereUniqueInput
  }


  /**
   * PerpetualContracts findFirst
   */
  export type PerpetualContractsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * Filter, which PerpetualContracts to fetch.
     */
    where?: PerpetualContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerpetualContracts to fetch.
     */
    orderBy?: PerpetualContractsOrderByWithRelationInput | PerpetualContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerpetualContracts.
     */
    cursor?: PerpetualContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerpetualContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerpetualContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerpetualContracts.
     */
    distinct?: PerpetualContractsScalarFieldEnum | PerpetualContractsScalarFieldEnum[]
  }


  /**
   * PerpetualContracts findFirstOrThrow
   */
  export type PerpetualContractsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * Filter, which PerpetualContracts to fetch.
     */
    where?: PerpetualContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerpetualContracts to fetch.
     */
    orderBy?: PerpetualContractsOrderByWithRelationInput | PerpetualContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerpetualContracts.
     */
    cursor?: PerpetualContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerpetualContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerpetualContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerpetualContracts.
     */
    distinct?: PerpetualContractsScalarFieldEnum | PerpetualContractsScalarFieldEnum[]
  }


  /**
   * PerpetualContracts findMany
   */
  export type PerpetualContractsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * Filter, which PerpetualContracts to fetch.
     */
    where?: PerpetualContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerpetualContracts to fetch.
     */
    orderBy?: PerpetualContractsOrderByWithRelationInput | PerpetualContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerpetualContracts.
     */
    cursor?: PerpetualContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerpetualContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerpetualContracts.
     */
    skip?: number
    distinct?: PerpetualContractsScalarFieldEnum | PerpetualContractsScalarFieldEnum[]
  }


  /**
   * PerpetualContracts create
   */
  export type PerpetualContractsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * The data needed to create a PerpetualContracts.
     */
    data: XOR<PerpetualContractsCreateInput, PerpetualContractsUncheckedCreateInput>
  }


  /**
   * PerpetualContracts createMany
   */
  export type PerpetualContractsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerpetualContracts.
     */
    data: PerpetualContractsCreateManyInput | PerpetualContractsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PerpetualContracts update
   */
  export type PerpetualContractsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * The data needed to update a PerpetualContracts.
     */
    data: XOR<PerpetualContractsUpdateInput, PerpetualContractsUncheckedUpdateInput>
    /**
     * Choose, which PerpetualContracts to update.
     */
    where: PerpetualContractsWhereUniqueInput
  }


  /**
   * PerpetualContracts updateMany
   */
  export type PerpetualContractsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerpetualContracts.
     */
    data: XOR<PerpetualContractsUpdateManyMutationInput, PerpetualContractsUncheckedUpdateManyInput>
    /**
     * Filter which PerpetualContracts to update
     */
    where?: PerpetualContractsWhereInput
  }


  /**
   * PerpetualContracts upsert
   */
  export type PerpetualContractsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * The filter to search for the PerpetualContracts to update in case it exists.
     */
    where: PerpetualContractsWhereUniqueInput
    /**
     * In case the PerpetualContracts found by the `where` argument doesn't exist, create a new PerpetualContracts with this data.
     */
    create: XOR<PerpetualContractsCreateInput, PerpetualContractsUncheckedCreateInput>
    /**
     * In case the PerpetualContracts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerpetualContractsUpdateInput, PerpetualContractsUncheckedUpdateInput>
  }


  /**
   * PerpetualContracts delete
   */
  export type PerpetualContractsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
    /**
     * Filter which PerpetualContracts to delete.
     */
    where: PerpetualContractsWhereUniqueInput
  }


  /**
   * PerpetualContracts deleteMany
   */
  export type PerpetualContractsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerpetualContracts to delete
     */
    where?: PerpetualContractsWhereInput
  }


  /**
   * PerpetualContracts without action
   */
  export type PerpetualContractsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerpetualContracts
     */
    select?: PerpetualContractsSelect<ExtArgs> | null
  }



  /**
   * Model KlineHistoricalData
   */

  export type AggregateKlineHistoricalData = {
    _count: KlineHistoricalDataCountAggregateOutputType | null
    _avg: KlineHistoricalDataAvgAggregateOutputType | null
    _sum: KlineHistoricalDataSumAggregateOutputType | null
    _min: KlineHistoricalDataMinAggregateOutputType | null
    _max: KlineHistoricalDataMaxAggregateOutputType | null
  }

  export type KlineHistoricalDataAvgAggregateOutputType = {
    id: number | null
    startTime: number | null
    endTime: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type KlineHistoricalDataSumAggregateOutputType = {
    id: number | null
    startTime: bigint | null
    endTime: bigint | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type KlineHistoricalDataMinAggregateOutputType = {
    id: number | null
    contractSymbol: string | null
    displayName: string | null
    interval: $Enums.Interval | null
    conversionRate: string | null
    startTime: bigint | null
    endTime: bigint | null
    timestampIst: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type KlineHistoricalDataMaxAggregateOutputType = {
    id: number | null
    contractSymbol: string | null
    displayName: string | null
    interval: $Enums.Interval | null
    conversionRate: string | null
    startTime: bigint | null
    endTime: bigint | null
    timestampIst: string | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type KlineHistoricalDataCountAggregateOutputType = {
    id: number
    contractSymbol: number
    displayName: number
    interval: number
    ohlc: number
    conversionRate: number
    startTime: number
    endTime: number
    timestampIst: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type KlineHistoricalDataAvgAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    createdBy?: true
    updatedBy?: true
  }

  export type KlineHistoricalDataSumAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    createdBy?: true
    updatedBy?: true
  }

  export type KlineHistoricalDataMinAggregateInputType = {
    id?: true
    contractSymbol?: true
    displayName?: true
    interval?: true
    conversionRate?: true
    startTime?: true
    endTime?: true
    timestampIst?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type KlineHistoricalDataMaxAggregateInputType = {
    id?: true
    contractSymbol?: true
    displayName?: true
    interval?: true
    conversionRate?: true
    startTime?: true
    endTime?: true
    timestampIst?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type KlineHistoricalDataCountAggregateInputType = {
    id?: true
    contractSymbol?: true
    displayName?: true
    interval?: true
    ohlc?: true
    conversionRate?: true
    startTime?: true
    endTime?: true
    timestampIst?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type KlineHistoricalDataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which KlineHistoricalData to aggregate.
     */
    where?: KlineHistoricalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KlineHistoricalData to fetch.
     */
    orderBy?: KlineHistoricalDataOrderByWithRelationInput | KlineHistoricalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KlineHistoricalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KlineHistoricalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KlineHistoricalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KlineHistoricalData
    **/
    _count?: true | KlineHistoricalDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KlineHistoricalDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KlineHistoricalDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KlineHistoricalDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KlineHistoricalDataMaxAggregateInputType
  }

  export type GetKlineHistoricalDataAggregateType<T extends KlineHistoricalDataAggregateArgs> = {
        [P in keyof T & keyof AggregateKlineHistoricalData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKlineHistoricalData[P]>
      : GetScalarType<T[P], AggregateKlineHistoricalData[P]>
  }




  export type KlineHistoricalDataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: KlineHistoricalDataWhereInput
    orderBy?: KlineHistoricalDataOrderByWithAggregationInput | KlineHistoricalDataOrderByWithAggregationInput[]
    by: KlineHistoricalDataScalarFieldEnum[] | KlineHistoricalDataScalarFieldEnum
    having?: KlineHistoricalDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KlineHistoricalDataCountAggregateInputType | true
    _avg?: KlineHistoricalDataAvgAggregateInputType
    _sum?: KlineHistoricalDataSumAggregateInputType
    _min?: KlineHistoricalDataMinAggregateInputType
    _max?: KlineHistoricalDataMaxAggregateInputType
  }

  export type KlineHistoricalDataGroupByOutputType = {
    id: number
    contractSymbol: string
    displayName: string
    interval: $Enums.Interval
    ohlc: JsonValue
    conversionRate: string
    startTime: bigint
    endTime: bigint
    timestampIst: string
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: KlineHistoricalDataCountAggregateOutputType | null
    _avg: KlineHistoricalDataAvgAggregateOutputType | null
    _sum: KlineHistoricalDataSumAggregateOutputType | null
    _min: KlineHistoricalDataMinAggregateOutputType | null
    _max: KlineHistoricalDataMaxAggregateOutputType | null
  }

  type GetKlineHistoricalDataGroupByPayload<T extends KlineHistoricalDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KlineHistoricalDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KlineHistoricalDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KlineHistoricalDataGroupByOutputType[P]>
            : GetScalarType<T[P], KlineHistoricalDataGroupByOutputType[P]>
        }
      >
    >


  export type KlineHistoricalDataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractSymbol?: boolean
    displayName?: boolean
    interval?: boolean
    ohlc?: boolean
    conversionRate?: boolean
    startTime?: boolean
    endTime?: boolean
    timestampIst?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["klineHistoricalData"]>

  export type KlineHistoricalDataSelectScalar = {
    id?: boolean
    contractSymbol?: boolean
    displayName?: boolean
    interval?: boolean
    ohlc?: boolean
    conversionRate?: boolean
    startTime?: boolean
    endTime?: boolean
    timestampIst?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $KlineHistoricalDataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "KlineHistoricalData"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      contractSymbol: string
      displayName: string
      interval: $Enums.Interval
      ohlc: Prisma.JsonValue
      conversionRate: string
      startTime: bigint
      endTime: bigint
      timestampIst: string
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["klineHistoricalData"]>
    composites: {}
  }


  type KlineHistoricalDataGetPayload<S extends boolean | null | undefined | KlineHistoricalDataDefaultArgs> = $Result.GetResult<Prisma.$KlineHistoricalDataPayload, S>

  type KlineHistoricalDataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<KlineHistoricalDataFindManyArgs, 'select' | 'include'> & {
      select?: KlineHistoricalDataCountAggregateInputType | true
    }

  export interface KlineHistoricalDataDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KlineHistoricalData'], meta: { name: 'KlineHistoricalData' } }
    /**
     * Find zero or one KlineHistoricalData that matches the filter.
     * @param {KlineHistoricalDataFindUniqueArgs} args - Arguments to find a KlineHistoricalData
     * @example
     * // Get one KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KlineHistoricalDataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, KlineHistoricalDataFindUniqueArgs<ExtArgs>>
    ): Prisma__KlineHistoricalDataClient<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one KlineHistoricalData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KlineHistoricalDataFindUniqueOrThrowArgs} args - Arguments to find a KlineHistoricalData
     * @example
     * // Get one KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KlineHistoricalDataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, KlineHistoricalDataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__KlineHistoricalDataClient<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first KlineHistoricalData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlineHistoricalDataFindFirstArgs} args - Arguments to find a KlineHistoricalData
     * @example
     * // Get one KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KlineHistoricalDataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, KlineHistoricalDataFindFirstArgs<ExtArgs>>
    ): Prisma__KlineHistoricalDataClient<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first KlineHistoricalData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlineHistoricalDataFindFirstOrThrowArgs} args - Arguments to find a KlineHistoricalData
     * @example
     * // Get one KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KlineHistoricalDataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, KlineHistoricalDataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__KlineHistoricalDataClient<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more KlineHistoricalData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlineHistoricalDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.findMany()
     * 
     * // Get first 10 KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const klineHistoricalDataWithIdOnly = await prisma.klineHistoricalData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KlineHistoricalDataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KlineHistoricalDataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a KlineHistoricalData.
     * @param {KlineHistoricalDataCreateArgs} args - Arguments to create a KlineHistoricalData.
     * @example
     * // Create one KlineHistoricalData
     * const KlineHistoricalData = await prisma.klineHistoricalData.create({
     *   data: {
     *     // ... data to create a KlineHistoricalData
     *   }
     * })
     * 
    **/
    create<T extends KlineHistoricalDataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, KlineHistoricalDataCreateArgs<ExtArgs>>
    ): Prisma__KlineHistoricalDataClient<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many KlineHistoricalData.
     *     @param {KlineHistoricalDataCreateManyArgs} args - Arguments to create many KlineHistoricalData.
     *     @example
     *     // Create many KlineHistoricalData
     *     const klineHistoricalData = await prisma.klineHistoricalData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KlineHistoricalDataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KlineHistoricalDataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KlineHistoricalData.
     * @param {KlineHistoricalDataDeleteArgs} args - Arguments to delete one KlineHistoricalData.
     * @example
     * // Delete one KlineHistoricalData
     * const KlineHistoricalData = await prisma.klineHistoricalData.delete({
     *   where: {
     *     // ... filter to delete one KlineHistoricalData
     *   }
     * })
     * 
    **/
    delete<T extends KlineHistoricalDataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, KlineHistoricalDataDeleteArgs<ExtArgs>>
    ): Prisma__KlineHistoricalDataClient<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one KlineHistoricalData.
     * @param {KlineHistoricalDataUpdateArgs} args - Arguments to update one KlineHistoricalData.
     * @example
     * // Update one KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KlineHistoricalDataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, KlineHistoricalDataUpdateArgs<ExtArgs>>
    ): Prisma__KlineHistoricalDataClient<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more KlineHistoricalData.
     * @param {KlineHistoricalDataDeleteManyArgs} args - Arguments to filter KlineHistoricalData to delete.
     * @example
     * // Delete a few KlineHistoricalData
     * const { count } = await prisma.klineHistoricalData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KlineHistoricalDataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KlineHistoricalDataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KlineHistoricalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlineHistoricalDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KlineHistoricalDataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, KlineHistoricalDataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KlineHistoricalData.
     * @param {KlineHistoricalDataUpsertArgs} args - Arguments to update or create a KlineHistoricalData.
     * @example
     * // Update or create a KlineHistoricalData
     * const klineHistoricalData = await prisma.klineHistoricalData.upsert({
     *   create: {
     *     // ... data to create a KlineHistoricalData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KlineHistoricalData we want to update
     *   }
     * })
    **/
    upsert<T extends KlineHistoricalDataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, KlineHistoricalDataUpsertArgs<ExtArgs>>
    ): Prisma__KlineHistoricalDataClient<$Result.GetResult<Prisma.$KlineHistoricalDataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of KlineHistoricalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlineHistoricalDataCountArgs} args - Arguments to filter KlineHistoricalData to count.
     * @example
     * // Count the number of KlineHistoricalData
     * const count = await prisma.klineHistoricalData.count({
     *   where: {
     *     // ... the filter for the KlineHistoricalData we want to count
     *   }
     * })
    **/
    count<T extends KlineHistoricalDataCountArgs>(
      args?: Subset<T, KlineHistoricalDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KlineHistoricalDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KlineHistoricalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlineHistoricalDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KlineHistoricalDataAggregateArgs>(args: Subset<T, KlineHistoricalDataAggregateArgs>): Prisma.PrismaPromise<GetKlineHistoricalDataAggregateType<T>>

    /**
     * Group by KlineHistoricalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlineHistoricalDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KlineHistoricalDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KlineHistoricalDataGroupByArgs['orderBy'] }
        : { orderBy?: KlineHistoricalDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KlineHistoricalDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKlineHistoricalDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KlineHistoricalData model
   */
  readonly fields: KlineHistoricalDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KlineHistoricalData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KlineHistoricalDataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the KlineHistoricalData model
   */ 
  interface KlineHistoricalDataFieldRefs {
    readonly id: FieldRef<"KlineHistoricalData", 'Int'>
    readonly contractSymbol: FieldRef<"KlineHistoricalData", 'String'>
    readonly displayName: FieldRef<"KlineHistoricalData", 'String'>
    readonly interval: FieldRef<"KlineHistoricalData", 'Interval'>
    readonly ohlc: FieldRef<"KlineHistoricalData", 'Json'>
    readonly conversionRate: FieldRef<"KlineHistoricalData", 'String'>
    readonly startTime: FieldRef<"KlineHistoricalData", 'BigInt'>
    readonly endTime: FieldRef<"KlineHistoricalData", 'BigInt'>
    readonly timestampIst: FieldRef<"KlineHistoricalData", 'String'>
    readonly createdAt: FieldRef<"KlineHistoricalData", 'DateTime'>
    readonly createdBy: FieldRef<"KlineHistoricalData", 'Int'>
    readonly updatedAt: FieldRef<"KlineHistoricalData", 'DateTime'>
    readonly updatedBy: FieldRef<"KlineHistoricalData", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * KlineHistoricalData findUnique
   */
  export type KlineHistoricalDataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * Filter, which KlineHistoricalData to fetch.
     */
    where: KlineHistoricalDataWhereUniqueInput
  }


  /**
   * KlineHistoricalData findUniqueOrThrow
   */
  export type KlineHistoricalDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * Filter, which KlineHistoricalData to fetch.
     */
    where: KlineHistoricalDataWhereUniqueInput
  }


  /**
   * KlineHistoricalData findFirst
   */
  export type KlineHistoricalDataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * Filter, which KlineHistoricalData to fetch.
     */
    where?: KlineHistoricalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KlineHistoricalData to fetch.
     */
    orderBy?: KlineHistoricalDataOrderByWithRelationInput | KlineHistoricalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KlineHistoricalData.
     */
    cursor?: KlineHistoricalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KlineHistoricalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KlineHistoricalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KlineHistoricalData.
     */
    distinct?: KlineHistoricalDataScalarFieldEnum | KlineHistoricalDataScalarFieldEnum[]
  }


  /**
   * KlineHistoricalData findFirstOrThrow
   */
  export type KlineHistoricalDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * Filter, which KlineHistoricalData to fetch.
     */
    where?: KlineHistoricalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KlineHistoricalData to fetch.
     */
    orderBy?: KlineHistoricalDataOrderByWithRelationInput | KlineHistoricalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KlineHistoricalData.
     */
    cursor?: KlineHistoricalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KlineHistoricalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KlineHistoricalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KlineHistoricalData.
     */
    distinct?: KlineHistoricalDataScalarFieldEnum | KlineHistoricalDataScalarFieldEnum[]
  }


  /**
   * KlineHistoricalData findMany
   */
  export type KlineHistoricalDataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * Filter, which KlineHistoricalData to fetch.
     */
    where?: KlineHistoricalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KlineHistoricalData to fetch.
     */
    orderBy?: KlineHistoricalDataOrderByWithRelationInput | KlineHistoricalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KlineHistoricalData.
     */
    cursor?: KlineHistoricalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KlineHistoricalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KlineHistoricalData.
     */
    skip?: number
    distinct?: KlineHistoricalDataScalarFieldEnum | KlineHistoricalDataScalarFieldEnum[]
  }


  /**
   * KlineHistoricalData create
   */
  export type KlineHistoricalDataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * The data needed to create a KlineHistoricalData.
     */
    data: XOR<KlineHistoricalDataCreateInput, KlineHistoricalDataUncheckedCreateInput>
  }


  /**
   * KlineHistoricalData createMany
   */
  export type KlineHistoricalDataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KlineHistoricalData.
     */
    data: KlineHistoricalDataCreateManyInput | KlineHistoricalDataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * KlineHistoricalData update
   */
  export type KlineHistoricalDataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * The data needed to update a KlineHistoricalData.
     */
    data: XOR<KlineHistoricalDataUpdateInput, KlineHistoricalDataUncheckedUpdateInput>
    /**
     * Choose, which KlineHistoricalData to update.
     */
    where: KlineHistoricalDataWhereUniqueInput
  }


  /**
   * KlineHistoricalData updateMany
   */
  export type KlineHistoricalDataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KlineHistoricalData.
     */
    data: XOR<KlineHistoricalDataUpdateManyMutationInput, KlineHistoricalDataUncheckedUpdateManyInput>
    /**
     * Filter which KlineHistoricalData to update
     */
    where?: KlineHistoricalDataWhereInput
  }


  /**
   * KlineHistoricalData upsert
   */
  export type KlineHistoricalDataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * The filter to search for the KlineHistoricalData to update in case it exists.
     */
    where: KlineHistoricalDataWhereUniqueInput
    /**
     * In case the KlineHistoricalData found by the `where` argument doesn't exist, create a new KlineHistoricalData with this data.
     */
    create: XOR<KlineHistoricalDataCreateInput, KlineHistoricalDataUncheckedCreateInput>
    /**
     * In case the KlineHistoricalData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KlineHistoricalDataUpdateInput, KlineHistoricalDataUncheckedUpdateInput>
  }


  /**
   * KlineHistoricalData delete
   */
  export type KlineHistoricalDataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
    /**
     * Filter which KlineHistoricalData to delete.
     */
    where: KlineHistoricalDataWhereUniqueInput
  }


  /**
   * KlineHistoricalData deleteMany
   */
  export type KlineHistoricalDataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which KlineHistoricalData to delete
     */
    where?: KlineHistoricalDataWhereInput
  }


  /**
   * KlineHistoricalData without action
   */
  export type KlineHistoricalDataDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlineHistoricalData
     */
    select?: KlineHistoricalDataSelect<ExtArgs> | null
  }



  /**
   * Model UserOrderHistory
   */

  export type AggregateUserOrderHistory = {
    _count: UserOrderHistoryCountAggregateOutputType | null
    _avg: UserOrderHistoryAvgAggregateOutputType | null
    _sum: UserOrderHistorySumAggregateOutputType | null
    _min: UserOrderHistoryMinAggregateOutputType | null
    _max: UserOrderHistoryMaxAggregateOutputType | null
  }

  export type UserOrderHistoryAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserOrderHistorySumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserOrderHistoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserOrderHistoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserOrderHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserOrderHistoryAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserOrderHistorySumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserOrderHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserOrderHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserOrderHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserOrderHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrderHistory to aggregate.
     */
    where?: UserOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrderHistories to fetch.
     */
    orderBy?: UserOrderHistoryOrderByWithRelationInput | UserOrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOrderHistories
    **/
    _count?: true | UserOrderHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserOrderHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserOrderHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOrderHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOrderHistoryMaxAggregateInputType
  }

  export type GetUserOrderHistoryAggregateType<T extends UserOrderHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOrderHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOrderHistory[P]>
      : GetScalarType<T[P], AggregateUserOrderHistory[P]>
  }




  export type UserOrderHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserOrderHistoryWhereInput
    orderBy?: UserOrderHistoryOrderByWithAggregationInput | UserOrderHistoryOrderByWithAggregationInput[]
    by: UserOrderHistoryScalarFieldEnum[] | UserOrderHistoryScalarFieldEnum
    having?: UserOrderHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOrderHistoryCountAggregateInputType | true
    _avg?: UserOrderHistoryAvgAggregateInputType
    _sum?: UserOrderHistorySumAggregateInputType
    _min?: UserOrderHistoryMinAggregateInputType
    _max?: UserOrderHistoryMaxAggregateInputType
  }

  export type UserOrderHistoryGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: UserOrderHistoryCountAggregateOutputType | null
    _avg: UserOrderHistoryAvgAggregateOutputType | null
    _sum: UserOrderHistorySumAggregateOutputType | null
    _min: UserOrderHistoryMinAggregateOutputType | null
    _max: UserOrderHistoryMaxAggregateOutputType | null
  }

  type GetUserOrderHistoryGroupByPayload<T extends UserOrderHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOrderHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOrderHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOrderHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserOrderHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserOrderHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["userOrderHistory"]>

  export type UserOrderHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $UserOrderHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "UserOrderHistory"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["userOrderHistory"]>
    composites: {}
  }


  type UserOrderHistoryGetPayload<S extends boolean | null | undefined | UserOrderHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserOrderHistoryPayload, S>

  type UserOrderHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserOrderHistoryFindManyArgs, 'select' | 'include'> & {
      select?: UserOrderHistoryCountAggregateInputType | true
    }

  export interface UserOrderHistoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOrderHistory'], meta: { name: 'UserOrderHistory' } }
    /**
     * Find zero or one UserOrderHistory that matches the filter.
     * @param {UserOrderHistoryFindUniqueArgs} args - Arguments to find a UserOrderHistory
     * @example
     * // Get one UserOrderHistory
     * const userOrderHistory = await prisma.userOrderHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserOrderHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrderHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__UserOrderHistoryClient<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserOrderHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserOrderHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserOrderHistory
     * @example
     * // Get one UserOrderHistory
     * const userOrderHistory = await prisma.userOrderHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserOrderHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrderHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserOrderHistoryClient<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserOrderHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrderHistoryFindFirstArgs} args - Arguments to find a UserOrderHistory
     * @example
     * // Get one UserOrderHistory
     * const userOrderHistory = await prisma.userOrderHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserOrderHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrderHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__UserOrderHistoryClient<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserOrderHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrderHistoryFindFirstOrThrowArgs} args - Arguments to find a UserOrderHistory
     * @example
     * // Get one UserOrderHistory
     * const userOrderHistory = await prisma.userOrderHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserOrderHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrderHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserOrderHistoryClient<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserOrderHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrderHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOrderHistories
     * const userOrderHistories = await prisma.userOrderHistory.findMany()
     * 
     * // Get first 10 UserOrderHistories
     * const userOrderHistories = await prisma.userOrderHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOrderHistoryWithIdOnly = await prisma.userOrderHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserOrderHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrderHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserOrderHistory.
     * @param {UserOrderHistoryCreateArgs} args - Arguments to create a UserOrderHistory.
     * @example
     * // Create one UserOrderHistory
     * const UserOrderHistory = await prisma.userOrderHistory.create({
     *   data: {
     *     // ... data to create a UserOrderHistory
     *   }
     * })
     * 
    **/
    create<T extends UserOrderHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrderHistoryCreateArgs<ExtArgs>>
    ): Prisma__UserOrderHistoryClient<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserOrderHistories.
     *     @param {UserOrderHistoryCreateManyArgs} args - Arguments to create many UserOrderHistories.
     *     @example
     *     // Create many UserOrderHistories
     *     const userOrderHistory = await prisma.userOrderHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserOrderHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrderHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserOrderHistory.
     * @param {UserOrderHistoryDeleteArgs} args - Arguments to delete one UserOrderHistory.
     * @example
     * // Delete one UserOrderHistory
     * const UserOrderHistory = await prisma.userOrderHistory.delete({
     *   where: {
     *     // ... filter to delete one UserOrderHistory
     *   }
     * })
     * 
    **/
    delete<T extends UserOrderHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrderHistoryDeleteArgs<ExtArgs>>
    ): Prisma__UserOrderHistoryClient<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserOrderHistory.
     * @param {UserOrderHistoryUpdateArgs} args - Arguments to update one UserOrderHistory.
     * @example
     * // Update one UserOrderHistory
     * const userOrderHistory = await prisma.userOrderHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserOrderHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrderHistoryUpdateArgs<ExtArgs>>
    ): Prisma__UserOrderHistoryClient<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserOrderHistories.
     * @param {UserOrderHistoryDeleteManyArgs} args - Arguments to filter UserOrderHistories to delete.
     * @example
     * // Delete a few UserOrderHistories
     * const { count } = await prisma.userOrderHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserOrderHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrderHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrderHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOrderHistories
     * const userOrderHistory = await prisma.userOrderHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserOrderHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrderHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserOrderHistory.
     * @param {UserOrderHistoryUpsertArgs} args - Arguments to update or create a UserOrderHistory.
     * @example
     * // Update or create a UserOrderHistory
     * const userOrderHistory = await prisma.userOrderHistory.upsert({
     *   create: {
     *     // ... data to create a UserOrderHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOrderHistory we want to update
     *   }
     * })
    **/
    upsert<T extends UserOrderHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrderHistoryUpsertArgs<ExtArgs>>
    ): Prisma__UserOrderHistoryClient<$Result.GetResult<Prisma.$UserOrderHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserOrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrderHistoryCountArgs} args - Arguments to filter UserOrderHistories to count.
     * @example
     * // Count the number of UserOrderHistories
     * const count = await prisma.userOrderHistory.count({
     *   where: {
     *     // ... the filter for the UserOrderHistories we want to count
     *   }
     * })
    **/
    count<T extends UserOrderHistoryCountArgs>(
      args?: Subset<T, UserOrderHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOrderHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrderHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOrderHistoryAggregateArgs>(args: Subset<T, UserOrderHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserOrderHistoryAggregateType<T>>

    /**
     * Group by UserOrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrderHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOrderHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOrderHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserOrderHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOrderHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOrderHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOrderHistory model
   */
  readonly fields: UserOrderHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOrderHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOrderHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserOrderHistory model
   */ 
  interface UserOrderHistoryFieldRefs {
    readonly id: FieldRef<"UserOrderHistory", 'Int'>
    readonly createdAt: FieldRef<"UserOrderHistory", 'DateTime'>
    readonly createdBy: FieldRef<"UserOrderHistory", 'Int'>
    readonly updatedAt: FieldRef<"UserOrderHistory", 'DateTime'>
    readonly updatedBy: FieldRef<"UserOrderHistory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserOrderHistory findUnique
   */
  export type UserOrderHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserOrderHistory to fetch.
     */
    where: UserOrderHistoryWhereUniqueInput
  }


  /**
   * UserOrderHistory findUniqueOrThrow
   */
  export type UserOrderHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserOrderHistory to fetch.
     */
    where: UserOrderHistoryWhereUniqueInput
  }


  /**
   * UserOrderHistory findFirst
   */
  export type UserOrderHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserOrderHistory to fetch.
     */
    where?: UserOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrderHistories to fetch.
     */
    orderBy?: UserOrderHistoryOrderByWithRelationInput | UserOrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrderHistories.
     */
    cursor?: UserOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrderHistories.
     */
    distinct?: UserOrderHistoryScalarFieldEnum | UserOrderHistoryScalarFieldEnum[]
  }


  /**
   * UserOrderHistory findFirstOrThrow
   */
  export type UserOrderHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserOrderHistory to fetch.
     */
    where?: UserOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrderHistories to fetch.
     */
    orderBy?: UserOrderHistoryOrderByWithRelationInput | UserOrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrderHistories.
     */
    cursor?: UserOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrderHistories.
     */
    distinct?: UserOrderHistoryScalarFieldEnum | UserOrderHistoryScalarFieldEnum[]
  }


  /**
   * UserOrderHistory findMany
   */
  export type UserOrderHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserOrderHistories to fetch.
     */
    where?: UserOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrderHistories to fetch.
     */
    orderBy?: UserOrderHistoryOrderByWithRelationInput | UserOrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOrderHistories.
     */
    cursor?: UserOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrderHistories.
     */
    skip?: number
    distinct?: UserOrderHistoryScalarFieldEnum | UserOrderHistoryScalarFieldEnum[]
  }


  /**
   * UserOrderHistory create
   */
  export type UserOrderHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a UserOrderHistory.
     */
    data: XOR<UserOrderHistoryCreateInput, UserOrderHistoryUncheckedCreateInput>
  }


  /**
   * UserOrderHistory createMany
   */
  export type UserOrderHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOrderHistories.
     */
    data: UserOrderHistoryCreateManyInput | UserOrderHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserOrderHistory update
   */
  export type UserOrderHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a UserOrderHistory.
     */
    data: XOR<UserOrderHistoryUpdateInput, UserOrderHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserOrderHistory to update.
     */
    where: UserOrderHistoryWhereUniqueInput
  }


  /**
   * UserOrderHistory updateMany
   */
  export type UserOrderHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOrderHistories.
     */
    data: XOR<UserOrderHistoryUpdateManyMutationInput, UserOrderHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserOrderHistories to update
     */
    where?: UserOrderHistoryWhereInput
  }


  /**
   * UserOrderHistory upsert
   */
  export type UserOrderHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the UserOrderHistory to update in case it exists.
     */
    where: UserOrderHistoryWhereUniqueInput
    /**
     * In case the UserOrderHistory found by the `where` argument doesn't exist, create a new UserOrderHistory with this data.
     */
    create: XOR<UserOrderHistoryCreateInput, UserOrderHistoryUncheckedCreateInput>
    /**
     * In case the UserOrderHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOrderHistoryUpdateInput, UserOrderHistoryUncheckedUpdateInput>
  }


  /**
   * UserOrderHistory delete
   */
  export type UserOrderHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
    /**
     * Filter which UserOrderHistory to delete.
     */
    where: UserOrderHistoryWhereUniqueInput
  }


  /**
   * UserOrderHistory deleteMany
   */
  export type UserOrderHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrderHistories to delete
     */
    where?: UserOrderHistoryWhereInput
  }


  /**
   * UserOrderHistory without action
   */
  export type UserOrderHistoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrderHistory
     */
    select?: UserOrderHistorySelect<ExtArgs> | null
  }



  /**
   * Model UserTradeHistory
   */

  export type AggregateUserTradeHistory = {
    _count: UserTradeHistoryCountAggregateOutputType | null
    _avg: UserTradeHistoryAvgAggregateOutputType | null
    _sum: UserTradeHistorySumAggregateOutputType | null
    _min: UserTradeHistoryMinAggregateOutputType | null
    _max: UserTradeHistoryMaxAggregateOutputType | null
  }

  export type UserTradeHistoryAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserTradeHistorySumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserTradeHistoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserTradeHistoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserTradeHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserTradeHistoryAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserTradeHistorySumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserTradeHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserTradeHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserTradeHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserTradeHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTradeHistory to aggregate.
     */
    where?: UserTradeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTradeHistories to fetch.
     */
    orderBy?: UserTradeHistoryOrderByWithRelationInput | UserTradeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTradeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTradeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTradeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTradeHistories
    **/
    _count?: true | UserTradeHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTradeHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTradeHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTradeHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTradeHistoryMaxAggregateInputType
  }

  export type GetUserTradeHistoryAggregateType<T extends UserTradeHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTradeHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTradeHistory[P]>
      : GetScalarType<T[P], AggregateUserTradeHistory[P]>
  }




  export type UserTradeHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserTradeHistoryWhereInput
    orderBy?: UserTradeHistoryOrderByWithAggregationInput | UserTradeHistoryOrderByWithAggregationInput[]
    by: UserTradeHistoryScalarFieldEnum[] | UserTradeHistoryScalarFieldEnum
    having?: UserTradeHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTradeHistoryCountAggregateInputType | true
    _avg?: UserTradeHistoryAvgAggregateInputType
    _sum?: UserTradeHistorySumAggregateInputType
    _min?: UserTradeHistoryMinAggregateInputType
    _max?: UserTradeHistoryMaxAggregateInputType
  }

  export type UserTradeHistoryGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: UserTradeHistoryCountAggregateOutputType | null
    _avg: UserTradeHistoryAvgAggregateOutputType | null
    _sum: UserTradeHistorySumAggregateOutputType | null
    _min: UserTradeHistoryMinAggregateOutputType | null
    _max: UserTradeHistoryMaxAggregateOutputType | null
  }

  type GetUserTradeHistoryGroupByPayload<T extends UserTradeHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTradeHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTradeHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTradeHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserTradeHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserTradeHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["userTradeHistory"]>

  export type UserTradeHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $UserTradeHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "UserTradeHistory"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["userTradeHistory"]>
    composites: {}
  }


  type UserTradeHistoryGetPayload<S extends boolean | null | undefined | UserTradeHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserTradeHistoryPayload, S>

  type UserTradeHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserTradeHistoryFindManyArgs, 'select' | 'include'> & {
      select?: UserTradeHistoryCountAggregateInputType | true
    }

  export interface UserTradeHistoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTradeHistory'], meta: { name: 'UserTradeHistory' } }
    /**
     * Find zero or one UserTradeHistory that matches the filter.
     * @param {UserTradeHistoryFindUniqueArgs} args - Arguments to find a UserTradeHistory
     * @example
     * // Get one UserTradeHistory
     * const userTradeHistory = await prisma.userTradeHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserTradeHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserTradeHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__UserTradeHistoryClient<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserTradeHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserTradeHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserTradeHistory
     * @example
     * // Get one UserTradeHistory
     * const userTradeHistory = await prisma.userTradeHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserTradeHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTradeHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserTradeHistoryClient<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserTradeHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTradeHistoryFindFirstArgs} args - Arguments to find a UserTradeHistory
     * @example
     * // Get one UserTradeHistory
     * const userTradeHistory = await prisma.userTradeHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserTradeHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTradeHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__UserTradeHistoryClient<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserTradeHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTradeHistoryFindFirstOrThrowArgs} args - Arguments to find a UserTradeHistory
     * @example
     * // Get one UserTradeHistory
     * const userTradeHistory = await prisma.userTradeHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserTradeHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTradeHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserTradeHistoryClient<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserTradeHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTradeHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTradeHistories
     * const userTradeHistories = await prisma.userTradeHistory.findMany()
     * 
     * // Get first 10 UserTradeHistories
     * const userTradeHistories = await prisma.userTradeHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTradeHistoryWithIdOnly = await prisma.userTradeHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserTradeHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTradeHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserTradeHistory.
     * @param {UserTradeHistoryCreateArgs} args - Arguments to create a UserTradeHistory.
     * @example
     * // Create one UserTradeHistory
     * const UserTradeHistory = await prisma.userTradeHistory.create({
     *   data: {
     *     // ... data to create a UserTradeHistory
     *   }
     * })
     * 
    **/
    create<T extends UserTradeHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserTradeHistoryCreateArgs<ExtArgs>>
    ): Prisma__UserTradeHistoryClient<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserTradeHistories.
     *     @param {UserTradeHistoryCreateManyArgs} args - Arguments to create many UserTradeHistories.
     *     @example
     *     // Create many UserTradeHistories
     *     const userTradeHistory = await prisma.userTradeHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserTradeHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTradeHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserTradeHistory.
     * @param {UserTradeHistoryDeleteArgs} args - Arguments to delete one UserTradeHistory.
     * @example
     * // Delete one UserTradeHistory
     * const UserTradeHistory = await prisma.userTradeHistory.delete({
     *   where: {
     *     // ... filter to delete one UserTradeHistory
     *   }
     * })
     * 
    **/
    delete<T extends UserTradeHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserTradeHistoryDeleteArgs<ExtArgs>>
    ): Prisma__UserTradeHistoryClient<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserTradeHistory.
     * @param {UserTradeHistoryUpdateArgs} args - Arguments to update one UserTradeHistory.
     * @example
     * // Update one UserTradeHistory
     * const userTradeHistory = await prisma.userTradeHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserTradeHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserTradeHistoryUpdateArgs<ExtArgs>>
    ): Prisma__UserTradeHistoryClient<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserTradeHistories.
     * @param {UserTradeHistoryDeleteManyArgs} args - Arguments to filter UserTradeHistories to delete.
     * @example
     * // Delete a few UserTradeHistories
     * const { count } = await prisma.userTradeHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserTradeHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserTradeHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTradeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTradeHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTradeHistories
     * const userTradeHistory = await prisma.userTradeHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserTradeHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserTradeHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTradeHistory.
     * @param {UserTradeHistoryUpsertArgs} args - Arguments to update or create a UserTradeHistory.
     * @example
     * // Update or create a UserTradeHistory
     * const userTradeHistory = await prisma.userTradeHistory.upsert({
     *   create: {
     *     // ... data to create a UserTradeHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTradeHistory we want to update
     *   }
     * })
    **/
    upsert<T extends UserTradeHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserTradeHistoryUpsertArgs<ExtArgs>>
    ): Prisma__UserTradeHistoryClient<$Result.GetResult<Prisma.$UserTradeHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserTradeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTradeHistoryCountArgs} args - Arguments to filter UserTradeHistories to count.
     * @example
     * // Count the number of UserTradeHistories
     * const count = await prisma.userTradeHistory.count({
     *   where: {
     *     // ... the filter for the UserTradeHistories we want to count
     *   }
     * })
    **/
    count<T extends UserTradeHistoryCountArgs>(
      args?: Subset<T, UserTradeHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTradeHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTradeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTradeHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTradeHistoryAggregateArgs>(args: Subset<T, UserTradeHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserTradeHistoryAggregateType<T>>

    /**
     * Group by UserTradeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTradeHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTradeHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTradeHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserTradeHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTradeHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTradeHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTradeHistory model
   */
  readonly fields: UserTradeHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTradeHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTradeHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserTradeHistory model
   */ 
  interface UserTradeHistoryFieldRefs {
    readonly id: FieldRef<"UserTradeHistory", 'Int'>
    readonly createdAt: FieldRef<"UserTradeHistory", 'DateTime'>
    readonly createdBy: FieldRef<"UserTradeHistory", 'Int'>
    readonly updatedAt: FieldRef<"UserTradeHistory", 'DateTime'>
    readonly updatedBy: FieldRef<"UserTradeHistory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserTradeHistory findUnique
   */
  export type UserTradeHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserTradeHistory to fetch.
     */
    where: UserTradeHistoryWhereUniqueInput
  }


  /**
   * UserTradeHistory findUniqueOrThrow
   */
  export type UserTradeHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserTradeHistory to fetch.
     */
    where: UserTradeHistoryWhereUniqueInput
  }


  /**
   * UserTradeHistory findFirst
   */
  export type UserTradeHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserTradeHistory to fetch.
     */
    where?: UserTradeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTradeHistories to fetch.
     */
    orderBy?: UserTradeHistoryOrderByWithRelationInput | UserTradeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTradeHistories.
     */
    cursor?: UserTradeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTradeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTradeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTradeHistories.
     */
    distinct?: UserTradeHistoryScalarFieldEnum | UserTradeHistoryScalarFieldEnum[]
  }


  /**
   * UserTradeHistory findFirstOrThrow
   */
  export type UserTradeHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserTradeHistory to fetch.
     */
    where?: UserTradeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTradeHistories to fetch.
     */
    orderBy?: UserTradeHistoryOrderByWithRelationInput | UserTradeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTradeHistories.
     */
    cursor?: UserTradeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTradeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTradeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTradeHistories.
     */
    distinct?: UserTradeHistoryScalarFieldEnum | UserTradeHistoryScalarFieldEnum[]
  }


  /**
   * UserTradeHistory findMany
   */
  export type UserTradeHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserTradeHistories to fetch.
     */
    where?: UserTradeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTradeHistories to fetch.
     */
    orderBy?: UserTradeHistoryOrderByWithRelationInput | UserTradeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTradeHistories.
     */
    cursor?: UserTradeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTradeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTradeHistories.
     */
    skip?: number
    distinct?: UserTradeHistoryScalarFieldEnum | UserTradeHistoryScalarFieldEnum[]
  }


  /**
   * UserTradeHistory create
   */
  export type UserTradeHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a UserTradeHistory.
     */
    data: XOR<UserTradeHistoryCreateInput, UserTradeHistoryUncheckedCreateInput>
  }


  /**
   * UserTradeHistory createMany
   */
  export type UserTradeHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTradeHistories.
     */
    data: UserTradeHistoryCreateManyInput | UserTradeHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserTradeHistory update
   */
  export type UserTradeHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a UserTradeHistory.
     */
    data: XOR<UserTradeHistoryUpdateInput, UserTradeHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserTradeHistory to update.
     */
    where: UserTradeHistoryWhereUniqueInput
  }


  /**
   * UserTradeHistory updateMany
   */
  export type UserTradeHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTradeHistories.
     */
    data: XOR<UserTradeHistoryUpdateManyMutationInput, UserTradeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserTradeHistories to update
     */
    where?: UserTradeHistoryWhereInput
  }


  /**
   * UserTradeHistory upsert
   */
  export type UserTradeHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the UserTradeHistory to update in case it exists.
     */
    where: UserTradeHistoryWhereUniqueInput
    /**
     * In case the UserTradeHistory found by the `where` argument doesn't exist, create a new UserTradeHistory with this data.
     */
    create: XOR<UserTradeHistoryCreateInput, UserTradeHistoryUncheckedCreateInput>
    /**
     * In case the UserTradeHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTradeHistoryUpdateInput, UserTradeHistoryUncheckedUpdateInput>
  }


  /**
   * UserTradeHistory delete
   */
  export type UserTradeHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
    /**
     * Filter which UserTradeHistory to delete.
     */
    where: UserTradeHistoryWhereUniqueInput
  }


  /**
   * UserTradeHistory deleteMany
   */
  export type UserTradeHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTradeHistories to delete
     */
    where?: UserTradeHistoryWhereInput
  }


  /**
   * UserTradeHistory without action
   */
  export type UserTradeHistoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTradeHistory
     */
    select?: UserTradeHistorySelect<ExtArgs> | null
  }



  /**
   * Model UserPositionHistory
   */

  export type AggregateUserPositionHistory = {
    _count: UserPositionHistoryCountAggregateOutputType | null
    _avg: UserPositionHistoryAvgAggregateOutputType | null
    _sum: UserPositionHistorySumAggregateOutputType | null
    _min: UserPositionHistoryMinAggregateOutputType | null
    _max: UserPositionHistoryMaxAggregateOutputType | null
  }

  export type UserPositionHistoryAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserPositionHistorySumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UserPositionHistoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserPositionHistoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserPositionHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserPositionHistoryAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserPositionHistorySumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserPositionHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserPositionHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserPositionHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserPositionHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPositionHistory to aggregate.
     */
    where?: UserPositionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPositionHistories to fetch.
     */
    orderBy?: UserPositionHistoryOrderByWithRelationInput | UserPositionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPositionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPositionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPositionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPositionHistories
    **/
    _count?: true | UserPositionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPositionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPositionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPositionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPositionHistoryMaxAggregateInputType
  }

  export type GetUserPositionHistoryAggregateType<T extends UserPositionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPositionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPositionHistory[P]>
      : GetScalarType<T[P], AggregateUserPositionHistory[P]>
  }




  export type UserPositionHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserPositionHistoryWhereInput
    orderBy?: UserPositionHistoryOrderByWithAggregationInput | UserPositionHistoryOrderByWithAggregationInput[]
    by: UserPositionHistoryScalarFieldEnum[] | UserPositionHistoryScalarFieldEnum
    having?: UserPositionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPositionHistoryCountAggregateInputType | true
    _avg?: UserPositionHistoryAvgAggregateInputType
    _sum?: UserPositionHistorySumAggregateInputType
    _min?: UserPositionHistoryMinAggregateInputType
    _max?: UserPositionHistoryMaxAggregateInputType
  }

  export type UserPositionHistoryGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: UserPositionHistoryCountAggregateOutputType | null
    _avg: UserPositionHistoryAvgAggregateOutputType | null
    _sum: UserPositionHistorySumAggregateOutputType | null
    _min: UserPositionHistoryMinAggregateOutputType | null
    _max: UserPositionHistoryMaxAggregateOutputType | null
  }

  type GetUserPositionHistoryGroupByPayload<T extends UserPositionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPositionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPositionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPositionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserPositionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserPositionHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["userPositionHistory"]>

  export type UserPositionHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $UserPositionHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "UserPositionHistory"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["userPositionHistory"]>
    composites: {}
  }


  type UserPositionHistoryGetPayload<S extends boolean | null | undefined | UserPositionHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserPositionHistoryPayload, S>

  type UserPositionHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserPositionHistoryFindManyArgs, 'select' | 'include'> & {
      select?: UserPositionHistoryCountAggregateInputType | true
    }

  export interface UserPositionHistoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPositionHistory'], meta: { name: 'UserPositionHistory' } }
    /**
     * Find zero or one UserPositionHistory that matches the filter.
     * @param {UserPositionHistoryFindUniqueArgs} args - Arguments to find a UserPositionHistory
     * @example
     * // Get one UserPositionHistory
     * const userPositionHistory = await prisma.userPositionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPositionHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserPositionHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__UserPositionHistoryClient<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserPositionHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPositionHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserPositionHistory
     * @example
     * // Get one UserPositionHistory
     * const userPositionHistory = await prisma.userPositionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPositionHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPositionHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserPositionHistoryClient<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserPositionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionHistoryFindFirstArgs} args - Arguments to find a UserPositionHistory
     * @example
     * // Get one UserPositionHistory
     * const userPositionHistory = await prisma.userPositionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPositionHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPositionHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__UserPositionHistoryClient<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserPositionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionHistoryFindFirstOrThrowArgs} args - Arguments to find a UserPositionHistory
     * @example
     * // Get one UserPositionHistory
     * const userPositionHistory = await prisma.userPositionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPositionHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPositionHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserPositionHistoryClient<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserPositionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPositionHistories
     * const userPositionHistories = await prisma.userPositionHistory.findMany()
     * 
     * // Get first 10 UserPositionHistories
     * const userPositionHistories = await prisma.userPositionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPositionHistoryWithIdOnly = await prisma.userPositionHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserPositionHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPositionHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserPositionHistory.
     * @param {UserPositionHistoryCreateArgs} args - Arguments to create a UserPositionHistory.
     * @example
     * // Create one UserPositionHistory
     * const UserPositionHistory = await prisma.userPositionHistory.create({
     *   data: {
     *     // ... data to create a UserPositionHistory
     *   }
     * })
     * 
    **/
    create<T extends UserPositionHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPositionHistoryCreateArgs<ExtArgs>>
    ): Prisma__UserPositionHistoryClient<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserPositionHistories.
     *     @param {UserPositionHistoryCreateManyArgs} args - Arguments to create many UserPositionHistories.
     *     @example
     *     // Create many UserPositionHistories
     *     const userPositionHistory = await prisma.userPositionHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPositionHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPositionHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPositionHistory.
     * @param {UserPositionHistoryDeleteArgs} args - Arguments to delete one UserPositionHistory.
     * @example
     * // Delete one UserPositionHistory
     * const UserPositionHistory = await prisma.userPositionHistory.delete({
     *   where: {
     *     // ... filter to delete one UserPositionHistory
     *   }
     * })
     * 
    **/
    delete<T extends UserPositionHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserPositionHistoryDeleteArgs<ExtArgs>>
    ): Prisma__UserPositionHistoryClient<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserPositionHistory.
     * @param {UserPositionHistoryUpdateArgs} args - Arguments to update one UserPositionHistory.
     * @example
     * // Update one UserPositionHistory
     * const userPositionHistory = await prisma.userPositionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPositionHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPositionHistoryUpdateArgs<ExtArgs>>
    ): Prisma__UserPositionHistoryClient<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserPositionHistories.
     * @param {UserPositionHistoryDeleteManyArgs} args - Arguments to filter UserPositionHistories to delete.
     * @example
     * // Delete a few UserPositionHistories
     * const { count } = await prisma.userPositionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPositionHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPositionHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPositionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPositionHistories
     * const userPositionHistory = await prisma.userPositionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPositionHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserPositionHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPositionHistory.
     * @param {UserPositionHistoryUpsertArgs} args - Arguments to update or create a UserPositionHistory.
     * @example
     * // Update or create a UserPositionHistory
     * const userPositionHistory = await prisma.userPositionHistory.upsert({
     *   create: {
     *     // ... data to create a UserPositionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPositionHistory we want to update
     *   }
     * })
    **/
    upsert<T extends UserPositionHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserPositionHistoryUpsertArgs<ExtArgs>>
    ): Prisma__UserPositionHistoryClient<$Result.GetResult<Prisma.$UserPositionHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserPositionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionHistoryCountArgs} args - Arguments to filter UserPositionHistories to count.
     * @example
     * // Count the number of UserPositionHistories
     * const count = await prisma.userPositionHistory.count({
     *   where: {
     *     // ... the filter for the UserPositionHistories we want to count
     *   }
     * })
    **/
    count<T extends UserPositionHistoryCountArgs>(
      args?: Subset<T, UserPositionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPositionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPositionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPositionHistoryAggregateArgs>(args: Subset<T, UserPositionHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserPositionHistoryAggregateType<T>>

    /**
     * Group by UserPositionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPositionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPositionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserPositionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPositionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPositionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPositionHistory model
   */
  readonly fields: UserPositionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPositionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPositionHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserPositionHistory model
   */ 
  interface UserPositionHistoryFieldRefs {
    readonly id: FieldRef<"UserPositionHistory", 'Int'>
    readonly createdAt: FieldRef<"UserPositionHistory", 'DateTime'>
    readonly createdBy: FieldRef<"UserPositionHistory", 'Int'>
    readonly updatedAt: FieldRef<"UserPositionHistory", 'DateTime'>
    readonly updatedBy: FieldRef<"UserPositionHistory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserPositionHistory findUnique
   */
  export type UserPositionHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserPositionHistory to fetch.
     */
    where: UserPositionHistoryWhereUniqueInput
  }


  /**
   * UserPositionHistory findUniqueOrThrow
   */
  export type UserPositionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserPositionHistory to fetch.
     */
    where: UserPositionHistoryWhereUniqueInput
  }


  /**
   * UserPositionHistory findFirst
   */
  export type UserPositionHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserPositionHistory to fetch.
     */
    where?: UserPositionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPositionHistories to fetch.
     */
    orderBy?: UserPositionHistoryOrderByWithRelationInput | UserPositionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPositionHistories.
     */
    cursor?: UserPositionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPositionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPositionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPositionHistories.
     */
    distinct?: UserPositionHistoryScalarFieldEnum | UserPositionHistoryScalarFieldEnum[]
  }


  /**
   * UserPositionHistory findFirstOrThrow
   */
  export type UserPositionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserPositionHistory to fetch.
     */
    where?: UserPositionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPositionHistories to fetch.
     */
    orderBy?: UserPositionHistoryOrderByWithRelationInput | UserPositionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPositionHistories.
     */
    cursor?: UserPositionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPositionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPositionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPositionHistories.
     */
    distinct?: UserPositionHistoryScalarFieldEnum | UserPositionHistoryScalarFieldEnum[]
  }


  /**
   * UserPositionHistory findMany
   */
  export type UserPositionHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * Filter, which UserPositionHistories to fetch.
     */
    where?: UserPositionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPositionHistories to fetch.
     */
    orderBy?: UserPositionHistoryOrderByWithRelationInput | UserPositionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPositionHistories.
     */
    cursor?: UserPositionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPositionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPositionHistories.
     */
    skip?: number
    distinct?: UserPositionHistoryScalarFieldEnum | UserPositionHistoryScalarFieldEnum[]
  }


  /**
   * UserPositionHistory create
   */
  export type UserPositionHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a UserPositionHistory.
     */
    data: XOR<UserPositionHistoryCreateInput, UserPositionHistoryUncheckedCreateInput>
  }


  /**
   * UserPositionHistory createMany
   */
  export type UserPositionHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPositionHistories.
     */
    data: UserPositionHistoryCreateManyInput | UserPositionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserPositionHistory update
   */
  export type UserPositionHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a UserPositionHistory.
     */
    data: XOR<UserPositionHistoryUpdateInput, UserPositionHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserPositionHistory to update.
     */
    where: UserPositionHistoryWhereUniqueInput
  }


  /**
   * UserPositionHistory updateMany
   */
  export type UserPositionHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPositionHistories.
     */
    data: XOR<UserPositionHistoryUpdateManyMutationInput, UserPositionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserPositionHistories to update
     */
    where?: UserPositionHistoryWhereInput
  }


  /**
   * UserPositionHistory upsert
   */
  export type UserPositionHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the UserPositionHistory to update in case it exists.
     */
    where: UserPositionHistoryWhereUniqueInput
    /**
     * In case the UserPositionHistory found by the `where` argument doesn't exist, create a new UserPositionHistory with this data.
     */
    create: XOR<UserPositionHistoryCreateInput, UserPositionHistoryUncheckedCreateInput>
    /**
     * In case the UserPositionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPositionHistoryUpdateInput, UserPositionHistoryUncheckedUpdateInput>
  }


  /**
   * UserPositionHistory delete
   */
  export type UserPositionHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
    /**
     * Filter which UserPositionHistory to delete.
     */
    where: UserPositionHistoryWhereUniqueInput
  }


  /**
   * UserPositionHistory deleteMany
   */
  export type UserPositionHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPositionHistories to delete
     */
    where?: UserPositionHistoryWhereInput
  }


  /**
   * UserPositionHistory without action
   */
  export type UserPositionHistoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPositionHistory
     */
    select?: UserPositionHistorySelect<ExtArgs> | null
  }



  /**
   * Model BinanceOrderHistory
   */

  export type AggregateBinanceOrderHistory = {
    _count: BinanceOrderHistoryCountAggregateOutputType | null
    _avg: BinanceOrderHistoryAvgAggregateOutputType | null
    _sum: BinanceOrderHistorySumAggregateOutputType | null
    _min: BinanceOrderHistoryMinAggregateOutputType | null
    _max: BinanceOrderHistoryMaxAggregateOutputType | null
  }

  export type BinanceOrderHistoryAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type BinanceOrderHistorySumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type BinanceOrderHistoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type BinanceOrderHistoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type BinanceOrderHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type BinanceOrderHistoryAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type BinanceOrderHistorySumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type BinanceOrderHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type BinanceOrderHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type BinanceOrderHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type BinanceOrderHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BinanceOrderHistory to aggregate.
     */
    where?: BinanceOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinanceOrderHistories to fetch.
     */
    orderBy?: BinanceOrderHistoryOrderByWithRelationInput | BinanceOrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinanceOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinanceOrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinanceOrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinanceOrderHistories
    **/
    _count?: true | BinanceOrderHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinanceOrderHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinanceOrderHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinanceOrderHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinanceOrderHistoryMaxAggregateInputType
  }

  export type GetBinanceOrderHistoryAggregateType<T extends BinanceOrderHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBinanceOrderHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinanceOrderHistory[P]>
      : GetScalarType<T[P], AggregateBinanceOrderHistory[P]>
  }




  export type BinanceOrderHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BinanceOrderHistoryWhereInput
    orderBy?: BinanceOrderHistoryOrderByWithAggregationInput | BinanceOrderHistoryOrderByWithAggregationInput[]
    by: BinanceOrderHistoryScalarFieldEnum[] | BinanceOrderHistoryScalarFieldEnum
    having?: BinanceOrderHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinanceOrderHistoryCountAggregateInputType | true
    _avg?: BinanceOrderHistoryAvgAggregateInputType
    _sum?: BinanceOrderHistorySumAggregateInputType
    _min?: BinanceOrderHistoryMinAggregateInputType
    _max?: BinanceOrderHistoryMaxAggregateInputType
  }

  export type BinanceOrderHistoryGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: BinanceOrderHistoryCountAggregateOutputType | null
    _avg: BinanceOrderHistoryAvgAggregateOutputType | null
    _sum: BinanceOrderHistorySumAggregateOutputType | null
    _min: BinanceOrderHistoryMinAggregateOutputType | null
    _max: BinanceOrderHistoryMaxAggregateOutputType | null
  }

  type GetBinanceOrderHistoryGroupByPayload<T extends BinanceOrderHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BinanceOrderHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinanceOrderHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinanceOrderHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BinanceOrderHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BinanceOrderHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["binanceOrderHistory"]>

  export type BinanceOrderHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $BinanceOrderHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "BinanceOrderHistory"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["binanceOrderHistory"]>
    composites: {}
  }


  type BinanceOrderHistoryGetPayload<S extends boolean | null | undefined | BinanceOrderHistoryDefaultArgs> = $Result.GetResult<Prisma.$BinanceOrderHistoryPayload, S>

  type BinanceOrderHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BinanceOrderHistoryFindManyArgs, 'select' | 'include'> & {
      select?: BinanceOrderHistoryCountAggregateInputType | true
    }

  export interface BinanceOrderHistoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BinanceOrderHistory'], meta: { name: 'BinanceOrderHistory' } }
    /**
     * Find zero or one BinanceOrderHistory that matches the filter.
     * @param {BinanceOrderHistoryFindUniqueArgs} args - Arguments to find a BinanceOrderHistory
     * @example
     * // Get one BinanceOrderHistory
     * const binanceOrderHistory = await prisma.binanceOrderHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinanceOrderHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceOrderHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__BinanceOrderHistoryClient<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BinanceOrderHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinanceOrderHistoryFindUniqueOrThrowArgs} args - Arguments to find a BinanceOrderHistory
     * @example
     * // Get one BinanceOrderHistory
     * const binanceOrderHistory = await prisma.binanceOrderHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinanceOrderHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceOrderHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BinanceOrderHistoryClient<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BinanceOrderHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceOrderHistoryFindFirstArgs} args - Arguments to find a BinanceOrderHistory
     * @example
     * // Get one BinanceOrderHistory
     * const binanceOrderHistory = await prisma.binanceOrderHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinanceOrderHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceOrderHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__BinanceOrderHistoryClient<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BinanceOrderHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceOrderHistoryFindFirstOrThrowArgs} args - Arguments to find a BinanceOrderHistory
     * @example
     * // Get one BinanceOrderHistory
     * const binanceOrderHistory = await prisma.binanceOrderHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinanceOrderHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceOrderHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BinanceOrderHistoryClient<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BinanceOrderHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceOrderHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinanceOrderHistories
     * const binanceOrderHistories = await prisma.binanceOrderHistory.findMany()
     * 
     * // Get first 10 BinanceOrderHistories
     * const binanceOrderHistories = await prisma.binanceOrderHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binanceOrderHistoryWithIdOnly = await prisma.binanceOrderHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinanceOrderHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceOrderHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BinanceOrderHistory.
     * @param {BinanceOrderHistoryCreateArgs} args - Arguments to create a BinanceOrderHistory.
     * @example
     * // Create one BinanceOrderHistory
     * const BinanceOrderHistory = await prisma.binanceOrderHistory.create({
     *   data: {
     *     // ... data to create a BinanceOrderHistory
     *   }
     * })
     * 
    **/
    create<T extends BinanceOrderHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceOrderHistoryCreateArgs<ExtArgs>>
    ): Prisma__BinanceOrderHistoryClient<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BinanceOrderHistories.
     *     @param {BinanceOrderHistoryCreateManyArgs} args - Arguments to create many BinanceOrderHistories.
     *     @example
     *     // Create many BinanceOrderHistories
     *     const binanceOrderHistory = await prisma.binanceOrderHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinanceOrderHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceOrderHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinanceOrderHistory.
     * @param {BinanceOrderHistoryDeleteArgs} args - Arguments to delete one BinanceOrderHistory.
     * @example
     * // Delete one BinanceOrderHistory
     * const BinanceOrderHistory = await prisma.binanceOrderHistory.delete({
     *   where: {
     *     // ... filter to delete one BinanceOrderHistory
     *   }
     * })
     * 
    **/
    delete<T extends BinanceOrderHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceOrderHistoryDeleteArgs<ExtArgs>>
    ): Prisma__BinanceOrderHistoryClient<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BinanceOrderHistory.
     * @param {BinanceOrderHistoryUpdateArgs} args - Arguments to update one BinanceOrderHistory.
     * @example
     * // Update one BinanceOrderHistory
     * const binanceOrderHistory = await prisma.binanceOrderHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinanceOrderHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceOrderHistoryUpdateArgs<ExtArgs>>
    ): Prisma__BinanceOrderHistoryClient<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BinanceOrderHistories.
     * @param {BinanceOrderHistoryDeleteManyArgs} args - Arguments to filter BinanceOrderHistories to delete.
     * @example
     * // Delete a few BinanceOrderHistories
     * const { count } = await prisma.binanceOrderHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinanceOrderHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceOrderHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinanceOrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceOrderHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinanceOrderHistories
     * const binanceOrderHistory = await prisma.binanceOrderHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinanceOrderHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceOrderHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinanceOrderHistory.
     * @param {BinanceOrderHistoryUpsertArgs} args - Arguments to update or create a BinanceOrderHistory.
     * @example
     * // Update or create a BinanceOrderHistory
     * const binanceOrderHistory = await prisma.binanceOrderHistory.upsert({
     *   create: {
     *     // ... data to create a BinanceOrderHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinanceOrderHistory we want to update
     *   }
     * })
    **/
    upsert<T extends BinanceOrderHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceOrderHistoryUpsertArgs<ExtArgs>>
    ): Prisma__BinanceOrderHistoryClient<$Result.GetResult<Prisma.$BinanceOrderHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BinanceOrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceOrderHistoryCountArgs} args - Arguments to filter BinanceOrderHistories to count.
     * @example
     * // Count the number of BinanceOrderHistories
     * const count = await prisma.binanceOrderHistory.count({
     *   where: {
     *     // ... the filter for the BinanceOrderHistories we want to count
     *   }
     * })
    **/
    count<T extends BinanceOrderHistoryCountArgs>(
      args?: Subset<T, BinanceOrderHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinanceOrderHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinanceOrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceOrderHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinanceOrderHistoryAggregateArgs>(args: Subset<T, BinanceOrderHistoryAggregateArgs>): Prisma.PrismaPromise<GetBinanceOrderHistoryAggregateType<T>>

    /**
     * Group by BinanceOrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceOrderHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinanceOrderHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinanceOrderHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BinanceOrderHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinanceOrderHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinanceOrderHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BinanceOrderHistory model
   */
  readonly fields: BinanceOrderHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BinanceOrderHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BinanceOrderHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BinanceOrderHistory model
   */ 
  interface BinanceOrderHistoryFieldRefs {
    readonly id: FieldRef<"BinanceOrderHistory", 'Int'>
    readonly createdAt: FieldRef<"BinanceOrderHistory", 'DateTime'>
    readonly createdBy: FieldRef<"BinanceOrderHistory", 'Int'>
    readonly updatedAt: FieldRef<"BinanceOrderHistory", 'DateTime'>
    readonly updatedBy: FieldRef<"BinanceOrderHistory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BinanceOrderHistory findUnique
   */
  export type BinanceOrderHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceOrderHistory to fetch.
     */
    where: BinanceOrderHistoryWhereUniqueInput
  }


  /**
   * BinanceOrderHistory findUniqueOrThrow
   */
  export type BinanceOrderHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceOrderHistory to fetch.
     */
    where: BinanceOrderHistoryWhereUniqueInput
  }


  /**
   * BinanceOrderHistory findFirst
   */
  export type BinanceOrderHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceOrderHistory to fetch.
     */
    where?: BinanceOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinanceOrderHistories to fetch.
     */
    orderBy?: BinanceOrderHistoryOrderByWithRelationInput | BinanceOrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinanceOrderHistories.
     */
    cursor?: BinanceOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinanceOrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinanceOrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinanceOrderHistories.
     */
    distinct?: BinanceOrderHistoryScalarFieldEnum | BinanceOrderHistoryScalarFieldEnum[]
  }


  /**
   * BinanceOrderHistory findFirstOrThrow
   */
  export type BinanceOrderHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceOrderHistory to fetch.
     */
    where?: BinanceOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinanceOrderHistories to fetch.
     */
    orderBy?: BinanceOrderHistoryOrderByWithRelationInput | BinanceOrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinanceOrderHistories.
     */
    cursor?: BinanceOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinanceOrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinanceOrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinanceOrderHistories.
     */
    distinct?: BinanceOrderHistoryScalarFieldEnum | BinanceOrderHistoryScalarFieldEnum[]
  }


  /**
   * BinanceOrderHistory findMany
   */
  export type BinanceOrderHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceOrderHistories to fetch.
     */
    where?: BinanceOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinanceOrderHistories to fetch.
     */
    orderBy?: BinanceOrderHistoryOrderByWithRelationInput | BinanceOrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinanceOrderHistories.
     */
    cursor?: BinanceOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinanceOrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinanceOrderHistories.
     */
    skip?: number
    distinct?: BinanceOrderHistoryScalarFieldEnum | BinanceOrderHistoryScalarFieldEnum[]
  }


  /**
   * BinanceOrderHistory create
   */
  export type BinanceOrderHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a BinanceOrderHistory.
     */
    data: XOR<BinanceOrderHistoryCreateInput, BinanceOrderHistoryUncheckedCreateInput>
  }


  /**
   * BinanceOrderHistory createMany
   */
  export type BinanceOrderHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BinanceOrderHistories.
     */
    data: BinanceOrderHistoryCreateManyInput | BinanceOrderHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BinanceOrderHistory update
   */
  export type BinanceOrderHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a BinanceOrderHistory.
     */
    data: XOR<BinanceOrderHistoryUpdateInput, BinanceOrderHistoryUncheckedUpdateInput>
    /**
     * Choose, which BinanceOrderHistory to update.
     */
    where: BinanceOrderHistoryWhereUniqueInput
  }


  /**
   * BinanceOrderHistory updateMany
   */
  export type BinanceOrderHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BinanceOrderHistories.
     */
    data: XOR<BinanceOrderHistoryUpdateManyMutationInput, BinanceOrderHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BinanceOrderHistories to update
     */
    where?: BinanceOrderHistoryWhereInput
  }


  /**
   * BinanceOrderHistory upsert
   */
  export type BinanceOrderHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the BinanceOrderHistory to update in case it exists.
     */
    where: BinanceOrderHistoryWhereUniqueInput
    /**
     * In case the BinanceOrderHistory found by the `where` argument doesn't exist, create a new BinanceOrderHistory with this data.
     */
    create: XOR<BinanceOrderHistoryCreateInput, BinanceOrderHistoryUncheckedCreateInput>
    /**
     * In case the BinanceOrderHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinanceOrderHistoryUpdateInput, BinanceOrderHistoryUncheckedUpdateInput>
  }


  /**
   * BinanceOrderHistory delete
   */
  export type BinanceOrderHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
    /**
     * Filter which BinanceOrderHistory to delete.
     */
    where: BinanceOrderHistoryWhereUniqueInput
  }


  /**
   * BinanceOrderHistory deleteMany
   */
  export type BinanceOrderHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BinanceOrderHistories to delete
     */
    where?: BinanceOrderHistoryWhereInput
  }


  /**
   * BinanceOrderHistory without action
   */
  export type BinanceOrderHistoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceOrderHistory
     */
    select?: BinanceOrderHistorySelect<ExtArgs> | null
  }



  /**
   * Model BinanceTradeHistory
   */

  export type AggregateBinanceTradeHistory = {
    _count: BinanceTradeHistoryCountAggregateOutputType | null
    _avg: BinanceTradeHistoryAvgAggregateOutputType | null
    _sum: BinanceTradeHistorySumAggregateOutputType | null
    _min: BinanceTradeHistoryMinAggregateOutputType | null
    _max: BinanceTradeHistoryMaxAggregateOutputType | null
  }

  export type BinanceTradeHistoryAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type BinanceTradeHistorySumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type BinanceTradeHistoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type BinanceTradeHistoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type BinanceTradeHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type BinanceTradeHistoryAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type BinanceTradeHistorySumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type BinanceTradeHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type BinanceTradeHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type BinanceTradeHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type BinanceTradeHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BinanceTradeHistory to aggregate.
     */
    where?: BinanceTradeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinanceTradeHistories to fetch.
     */
    orderBy?: BinanceTradeHistoryOrderByWithRelationInput | BinanceTradeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinanceTradeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinanceTradeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinanceTradeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinanceTradeHistories
    **/
    _count?: true | BinanceTradeHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinanceTradeHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinanceTradeHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinanceTradeHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinanceTradeHistoryMaxAggregateInputType
  }

  export type GetBinanceTradeHistoryAggregateType<T extends BinanceTradeHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBinanceTradeHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinanceTradeHistory[P]>
      : GetScalarType<T[P], AggregateBinanceTradeHistory[P]>
  }




  export type BinanceTradeHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BinanceTradeHistoryWhereInput
    orderBy?: BinanceTradeHistoryOrderByWithAggregationInput | BinanceTradeHistoryOrderByWithAggregationInput[]
    by: BinanceTradeHistoryScalarFieldEnum[] | BinanceTradeHistoryScalarFieldEnum
    having?: BinanceTradeHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinanceTradeHistoryCountAggregateInputType | true
    _avg?: BinanceTradeHistoryAvgAggregateInputType
    _sum?: BinanceTradeHistorySumAggregateInputType
    _min?: BinanceTradeHistoryMinAggregateInputType
    _max?: BinanceTradeHistoryMaxAggregateInputType
  }

  export type BinanceTradeHistoryGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: BinanceTradeHistoryCountAggregateOutputType | null
    _avg: BinanceTradeHistoryAvgAggregateOutputType | null
    _sum: BinanceTradeHistorySumAggregateOutputType | null
    _min: BinanceTradeHistoryMinAggregateOutputType | null
    _max: BinanceTradeHistoryMaxAggregateOutputType | null
  }

  type GetBinanceTradeHistoryGroupByPayload<T extends BinanceTradeHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BinanceTradeHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinanceTradeHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinanceTradeHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BinanceTradeHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BinanceTradeHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["binanceTradeHistory"]>

  export type BinanceTradeHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $BinanceTradeHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "BinanceTradeHistory"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["binanceTradeHistory"]>
    composites: {}
  }


  type BinanceTradeHistoryGetPayload<S extends boolean | null | undefined | BinanceTradeHistoryDefaultArgs> = $Result.GetResult<Prisma.$BinanceTradeHistoryPayload, S>

  type BinanceTradeHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BinanceTradeHistoryFindManyArgs, 'select' | 'include'> & {
      select?: BinanceTradeHistoryCountAggregateInputType | true
    }

  export interface BinanceTradeHistoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BinanceTradeHistory'], meta: { name: 'BinanceTradeHistory' } }
    /**
     * Find zero or one BinanceTradeHistory that matches the filter.
     * @param {BinanceTradeHistoryFindUniqueArgs} args - Arguments to find a BinanceTradeHistory
     * @example
     * // Get one BinanceTradeHistory
     * const binanceTradeHistory = await prisma.binanceTradeHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinanceTradeHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceTradeHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__BinanceTradeHistoryClient<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BinanceTradeHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinanceTradeHistoryFindUniqueOrThrowArgs} args - Arguments to find a BinanceTradeHistory
     * @example
     * // Get one BinanceTradeHistory
     * const binanceTradeHistory = await prisma.binanceTradeHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinanceTradeHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceTradeHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BinanceTradeHistoryClient<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BinanceTradeHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceTradeHistoryFindFirstArgs} args - Arguments to find a BinanceTradeHistory
     * @example
     * // Get one BinanceTradeHistory
     * const binanceTradeHistory = await prisma.binanceTradeHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinanceTradeHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceTradeHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__BinanceTradeHistoryClient<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BinanceTradeHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceTradeHistoryFindFirstOrThrowArgs} args - Arguments to find a BinanceTradeHistory
     * @example
     * // Get one BinanceTradeHistory
     * const binanceTradeHistory = await prisma.binanceTradeHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinanceTradeHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceTradeHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BinanceTradeHistoryClient<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BinanceTradeHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceTradeHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinanceTradeHistories
     * const binanceTradeHistories = await prisma.binanceTradeHistory.findMany()
     * 
     * // Get first 10 BinanceTradeHistories
     * const binanceTradeHistories = await prisma.binanceTradeHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binanceTradeHistoryWithIdOnly = await prisma.binanceTradeHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinanceTradeHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceTradeHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BinanceTradeHistory.
     * @param {BinanceTradeHistoryCreateArgs} args - Arguments to create a BinanceTradeHistory.
     * @example
     * // Create one BinanceTradeHistory
     * const BinanceTradeHistory = await prisma.binanceTradeHistory.create({
     *   data: {
     *     // ... data to create a BinanceTradeHistory
     *   }
     * })
     * 
    **/
    create<T extends BinanceTradeHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceTradeHistoryCreateArgs<ExtArgs>>
    ): Prisma__BinanceTradeHistoryClient<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BinanceTradeHistories.
     *     @param {BinanceTradeHistoryCreateManyArgs} args - Arguments to create many BinanceTradeHistories.
     *     @example
     *     // Create many BinanceTradeHistories
     *     const binanceTradeHistory = await prisma.binanceTradeHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinanceTradeHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceTradeHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinanceTradeHistory.
     * @param {BinanceTradeHistoryDeleteArgs} args - Arguments to delete one BinanceTradeHistory.
     * @example
     * // Delete one BinanceTradeHistory
     * const BinanceTradeHistory = await prisma.binanceTradeHistory.delete({
     *   where: {
     *     // ... filter to delete one BinanceTradeHistory
     *   }
     * })
     * 
    **/
    delete<T extends BinanceTradeHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceTradeHistoryDeleteArgs<ExtArgs>>
    ): Prisma__BinanceTradeHistoryClient<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BinanceTradeHistory.
     * @param {BinanceTradeHistoryUpdateArgs} args - Arguments to update one BinanceTradeHistory.
     * @example
     * // Update one BinanceTradeHistory
     * const binanceTradeHistory = await prisma.binanceTradeHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinanceTradeHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceTradeHistoryUpdateArgs<ExtArgs>>
    ): Prisma__BinanceTradeHistoryClient<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BinanceTradeHistories.
     * @param {BinanceTradeHistoryDeleteManyArgs} args - Arguments to filter BinanceTradeHistories to delete.
     * @example
     * // Delete a few BinanceTradeHistories
     * const { count } = await prisma.binanceTradeHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinanceTradeHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BinanceTradeHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinanceTradeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceTradeHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinanceTradeHistories
     * const binanceTradeHistory = await prisma.binanceTradeHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinanceTradeHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceTradeHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinanceTradeHistory.
     * @param {BinanceTradeHistoryUpsertArgs} args - Arguments to update or create a BinanceTradeHistory.
     * @example
     * // Update or create a BinanceTradeHistory
     * const binanceTradeHistory = await prisma.binanceTradeHistory.upsert({
     *   create: {
     *     // ... data to create a BinanceTradeHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinanceTradeHistory we want to update
     *   }
     * })
    **/
    upsert<T extends BinanceTradeHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BinanceTradeHistoryUpsertArgs<ExtArgs>>
    ): Prisma__BinanceTradeHistoryClient<$Result.GetResult<Prisma.$BinanceTradeHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BinanceTradeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceTradeHistoryCountArgs} args - Arguments to filter BinanceTradeHistories to count.
     * @example
     * // Count the number of BinanceTradeHistories
     * const count = await prisma.binanceTradeHistory.count({
     *   where: {
     *     // ... the filter for the BinanceTradeHistories we want to count
     *   }
     * })
    **/
    count<T extends BinanceTradeHistoryCountArgs>(
      args?: Subset<T, BinanceTradeHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinanceTradeHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinanceTradeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceTradeHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinanceTradeHistoryAggregateArgs>(args: Subset<T, BinanceTradeHistoryAggregateArgs>): Prisma.PrismaPromise<GetBinanceTradeHistoryAggregateType<T>>

    /**
     * Group by BinanceTradeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinanceTradeHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinanceTradeHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinanceTradeHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BinanceTradeHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinanceTradeHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinanceTradeHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BinanceTradeHistory model
   */
  readonly fields: BinanceTradeHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BinanceTradeHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BinanceTradeHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BinanceTradeHistory model
   */ 
  interface BinanceTradeHistoryFieldRefs {
    readonly id: FieldRef<"BinanceTradeHistory", 'Int'>
    readonly createdAt: FieldRef<"BinanceTradeHistory", 'DateTime'>
    readonly createdBy: FieldRef<"BinanceTradeHistory", 'Int'>
    readonly updatedAt: FieldRef<"BinanceTradeHistory", 'DateTime'>
    readonly updatedBy: FieldRef<"BinanceTradeHistory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BinanceTradeHistory findUnique
   */
  export type BinanceTradeHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceTradeHistory to fetch.
     */
    where: BinanceTradeHistoryWhereUniqueInput
  }


  /**
   * BinanceTradeHistory findUniqueOrThrow
   */
  export type BinanceTradeHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceTradeHistory to fetch.
     */
    where: BinanceTradeHistoryWhereUniqueInput
  }


  /**
   * BinanceTradeHistory findFirst
   */
  export type BinanceTradeHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceTradeHistory to fetch.
     */
    where?: BinanceTradeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinanceTradeHistories to fetch.
     */
    orderBy?: BinanceTradeHistoryOrderByWithRelationInput | BinanceTradeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinanceTradeHistories.
     */
    cursor?: BinanceTradeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinanceTradeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinanceTradeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinanceTradeHistories.
     */
    distinct?: BinanceTradeHistoryScalarFieldEnum | BinanceTradeHistoryScalarFieldEnum[]
  }


  /**
   * BinanceTradeHistory findFirstOrThrow
   */
  export type BinanceTradeHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceTradeHistory to fetch.
     */
    where?: BinanceTradeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinanceTradeHistories to fetch.
     */
    orderBy?: BinanceTradeHistoryOrderByWithRelationInput | BinanceTradeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinanceTradeHistories.
     */
    cursor?: BinanceTradeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinanceTradeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinanceTradeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinanceTradeHistories.
     */
    distinct?: BinanceTradeHistoryScalarFieldEnum | BinanceTradeHistoryScalarFieldEnum[]
  }


  /**
   * BinanceTradeHistory findMany
   */
  export type BinanceTradeHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * Filter, which BinanceTradeHistories to fetch.
     */
    where?: BinanceTradeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinanceTradeHistories to fetch.
     */
    orderBy?: BinanceTradeHistoryOrderByWithRelationInput | BinanceTradeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinanceTradeHistories.
     */
    cursor?: BinanceTradeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinanceTradeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinanceTradeHistories.
     */
    skip?: number
    distinct?: BinanceTradeHistoryScalarFieldEnum | BinanceTradeHistoryScalarFieldEnum[]
  }


  /**
   * BinanceTradeHistory create
   */
  export type BinanceTradeHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a BinanceTradeHistory.
     */
    data: XOR<BinanceTradeHistoryCreateInput, BinanceTradeHistoryUncheckedCreateInput>
  }


  /**
   * BinanceTradeHistory createMany
   */
  export type BinanceTradeHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BinanceTradeHistories.
     */
    data: BinanceTradeHistoryCreateManyInput | BinanceTradeHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BinanceTradeHistory update
   */
  export type BinanceTradeHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a BinanceTradeHistory.
     */
    data: XOR<BinanceTradeHistoryUpdateInput, BinanceTradeHistoryUncheckedUpdateInput>
    /**
     * Choose, which BinanceTradeHistory to update.
     */
    where: BinanceTradeHistoryWhereUniqueInput
  }


  /**
   * BinanceTradeHistory updateMany
   */
  export type BinanceTradeHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BinanceTradeHistories.
     */
    data: XOR<BinanceTradeHistoryUpdateManyMutationInput, BinanceTradeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BinanceTradeHistories to update
     */
    where?: BinanceTradeHistoryWhereInput
  }


  /**
   * BinanceTradeHistory upsert
   */
  export type BinanceTradeHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the BinanceTradeHistory to update in case it exists.
     */
    where: BinanceTradeHistoryWhereUniqueInput
    /**
     * In case the BinanceTradeHistory found by the `where` argument doesn't exist, create a new BinanceTradeHistory with this data.
     */
    create: XOR<BinanceTradeHistoryCreateInput, BinanceTradeHistoryUncheckedCreateInput>
    /**
     * In case the BinanceTradeHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinanceTradeHistoryUpdateInput, BinanceTradeHistoryUncheckedUpdateInput>
  }


  /**
   * BinanceTradeHistory delete
   */
  export type BinanceTradeHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
    /**
     * Filter which BinanceTradeHistory to delete.
     */
    where: BinanceTradeHistoryWhereUniqueInput
  }


  /**
   * BinanceTradeHistory deleteMany
   */
  export type BinanceTradeHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BinanceTradeHistories to delete
     */
    where?: BinanceTradeHistoryWhereInput
  }


  /**
   * BinanceTradeHistory without action
   */
  export type BinanceTradeHistoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinanceTradeHistory
     */
    select?: BinanceTradeHistorySelect<ExtArgs> | null
  }



  /**
   * Model CoinwiseTradeRecoincilliation
   */

  export type AggregateCoinwiseTradeRecoincilliation = {
    _count: CoinwiseTradeRecoincilliationCountAggregateOutputType | null
    _avg: CoinwiseTradeRecoincilliationAvgAggregateOutputType | null
    _sum: CoinwiseTradeRecoincilliationSumAggregateOutputType | null
    _min: CoinwiseTradeRecoincilliationMinAggregateOutputType | null
    _max: CoinwiseTradeRecoincilliationMaxAggregateOutputType | null
  }

  export type CoinwiseTradeRecoincilliationAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CoinwiseTradeRecoincilliationSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CoinwiseTradeRecoincilliationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CoinwiseTradeRecoincilliationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CoinwiseTradeRecoincilliationCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type CoinwiseTradeRecoincilliationAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CoinwiseTradeRecoincilliationSumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CoinwiseTradeRecoincilliationMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CoinwiseTradeRecoincilliationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CoinwiseTradeRecoincilliationCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type CoinwiseTradeRecoincilliationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinwiseTradeRecoincilliation to aggregate.
     */
    where?: CoinwiseTradeRecoincilliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinwiseTradeRecoincilliations to fetch.
     */
    orderBy?: CoinwiseTradeRecoincilliationOrderByWithRelationInput | CoinwiseTradeRecoincilliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoinwiseTradeRecoincilliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinwiseTradeRecoincilliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinwiseTradeRecoincilliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoinwiseTradeRecoincilliations
    **/
    _count?: true | CoinwiseTradeRecoincilliationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoinwiseTradeRecoincilliationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoinwiseTradeRecoincilliationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoinwiseTradeRecoincilliationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoinwiseTradeRecoincilliationMaxAggregateInputType
  }

  export type GetCoinwiseTradeRecoincilliationAggregateType<T extends CoinwiseTradeRecoincilliationAggregateArgs> = {
        [P in keyof T & keyof AggregateCoinwiseTradeRecoincilliation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoinwiseTradeRecoincilliation[P]>
      : GetScalarType<T[P], AggregateCoinwiseTradeRecoincilliation[P]>
  }




  export type CoinwiseTradeRecoincilliationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CoinwiseTradeRecoincilliationWhereInput
    orderBy?: CoinwiseTradeRecoincilliationOrderByWithAggregationInput | CoinwiseTradeRecoincilliationOrderByWithAggregationInput[]
    by: CoinwiseTradeRecoincilliationScalarFieldEnum[] | CoinwiseTradeRecoincilliationScalarFieldEnum
    having?: CoinwiseTradeRecoincilliationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoinwiseTradeRecoincilliationCountAggregateInputType | true
    _avg?: CoinwiseTradeRecoincilliationAvgAggregateInputType
    _sum?: CoinwiseTradeRecoincilliationSumAggregateInputType
    _min?: CoinwiseTradeRecoincilliationMinAggregateInputType
    _max?: CoinwiseTradeRecoincilliationMaxAggregateInputType
  }

  export type CoinwiseTradeRecoincilliationGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: CoinwiseTradeRecoincilliationCountAggregateOutputType | null
    _avg: CoinwiseTradeRecoincilliationAvgAggregateOutputType | null
    _sum: CoinwiseTradeRecoincilliationSumAggregateOutputType | null
    _min: CoinwiseTradeRecoincilliationMinAggregateOutputType | null
    _max: CoinwiseTradeRecoincilliationMaxAggregateOutputType | null
  }

  type GetCoinwiseTradeRecoincilliationGroupByPayload<T extends CoinwiseTradeRecoincilliationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoinwiseTradeRecoincilliationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoinwiseTradeRecoincilliationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoinwiseTradeRecoincilliationGroupByOutputType[P]>
            : GetScalarType<T[P], CoinwiseTradeRecoincilliationGroupByOutputType[P]>
        }
      >
    >


  export type CoinwiseTradeRecoincilliationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["coinwiseTradeRecoincilliation"]>

  export type CoinwiseTradeRecoincilliationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $CoinwiseTradeRecoincilliationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CoinwiseTradeRecoincilliation"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["coinwiseTradeRecoincilliation"]>
    composites: {}
  }


  type CoinwiseTradeRecoincilliationGetPayload<S extends boolean | null | undefined | CoinwiseTradeRecoincilliationDefaultArgs> = $Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload, S>

  type CoinwiseTradeRecoincilliationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CoinwiseTradeRecoincilliationFindManyArgs, 'select' | 'include'> & {
      select?: CoinwiseTradeRecoincilliationCountAggregateInputType | true
    }

  export interface CoinwiseTradeRecoincilliationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoinwiseTradeRecoincilliation'], meta: { name: 'CoinwiseTradeRecoincilliation' } }
    /**
     * Find zero or one CoinwiseTradeRecoincilliation that matches the filter.
     * @param {CoinwiseTradeRecoincilliationFindUniqueArgs} args - Arguments to find a CoinwiseTradeRecoincilliation
     * @example
     * // Get one CoinwiseTradeRecoincilliation
     * const coinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoinwiseTradeRecoincilliationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwiseTradeRecoincilliationFindUniqueArgs<ExtArgs>>
    ): Prisma__CoinwiseTradeRecoincilliationClient<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CoinwiseTradeRecoincilliation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CoinwiseTradeRecoincilliationFindUniqueOrThrowArgs} args - Arguments to find a CoinwiseTradeRecoincilliation
     * @example
     * // Get one CoinwiseTradeRecoincilliation
     * const coinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CoinwiseTradeRecoincilliationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwiseTradeRecoincilliationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CoinwiseTradeRecoincilliationClient<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CoinwiseTradeRecoincilliation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwiseTradeRecoincilliationFindFirstArgs} args - Arguments to find a CoinwiseTradeRecoincilliation
     * @example
     * // Get one CoinwiseTradeRecoincilliation
     * const coinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoinwiseTradeRecoincilliationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwiseTradeRecoincilliationFindFirstArgs<ExtArgs>>
    ): Prisma__CoinwiseTradeRecoincilliationClient<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CoinwiseTradeRecoincilliation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwiseTradeRecoincilliationFindFirstOrThrowArgs} args - Arguments to find a CoinwiseTradeRecoincilliation
     * @example
     * // Get one CoinwiseTradeRecoincilliation
     * const coinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CoinwiseTradeRecoincilliationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwiseTradeRecoincilliationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CoinwiseTradeRecoincilliationClient<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CoinwiseTradeRecoincilliations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwiseTradeRecoincilliationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoinwiseTradeRecoincilliations
     * const coinwiseTradeRecoincilliations = await prisma.coinwiseTradeRecoincilliation.findMany()
     * 
     * // Get first 10 CoinwiseTradeRecoincilliations
     * const coinwiseTradeRecoincilliations = await prisma.coinwiseTradeRecoincilliation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coinwiseTradeRecoincilliationWithIdOnly = await prisma.coinwiseTradeRecoincilliation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CoinwiseTradeRecoincilliationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwiseTradeRecoincilliationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CoinwiseTradeRecoincilliation.
     * @param {CoinwiseTradeRecoincilliationCreateArgs} args - Arguments to create a CoinwiseTradeRecoincilliation.
     * @example
     * // Create one CoinwiseTradeRecoincilliation
     * const CoinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.create({
     *   data: {
     *     // ... data to create a CoinwiseTradeRecoincilliation
     *   }
     * })
     * 
    **/
    create<T extends CoinwiseTradeRecoincilliationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwiseTradeRecoincilliationCreateArgs<ExtArgs>>
    ): Prisma__CoinwiseTradeRecoincilliationClient<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CoinwiseTradeRecoincilliations.
     *     @param {CoinwiseTradeRecoincilliationCreateManyArgs} args - Arguments to create many CoinwiseTradeRecoincilliations.
     *     @example
     *     // Create many CoinwiseTradeRecoincilliations
     *     const coinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CoinwiseTradeRecoincilliationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwiseTradeRecoincilliationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CoinwiseTradeRecoincilliation.
     * @param {CoinwiseTradeRecoincilliationDeleteArgs} args - Arguments to delete one CoinwiseTradeRecoincilliation.
     * @example
     * // Delete one CoinwiseTradeRecoincilliation
     * const CoinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.delete({
     *   where: {
     *     // ... filter to delete one CoinwiseTradeRecoincilliation
     *   }
     * })
     * 
    **/
    delete<T extends CoinwiseTradeRecoincilliationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwiseTradeRecoincilliationDeleteArgs<ExtArgs>>
    ): Prisma__CoinwiseTradeRecoincilliationClient<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CoinwiseTradeRecoincilliation.
     * @param {CoinwiseTradeRecoincilliationUpdateArgs} args - Arguments to update one CoinwiseTradeRecoincilliation.
     * @example
     * // Update one CoinwiseTradeRecoincilliation
     * const coinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoinwiseTradeRecoincilliationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwiseTradeRecoincilliationUpdateArgs<ExtArgs>>
    ): Prisma__CoinwiseTradeRecoincilliationClient<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CoinwiseTradeRecoincilliations.
     * @param {CoinwiseTradeRecoincilliationDeleteManyArgs} args - Arguments to filter CoinwiseTradeRecoincilliations to delete.
     * @example
     * // Delete a few CoinwiseTradeRecoincilliations
     * const { count } = await prisma.coinwiseTradeRecoincilliation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoinwiseTradeRecoincilliationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwiseTradeRecoincilliationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoinwiseTradeRecoincilliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwiseTradeRecoincilliationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoinwiseTradeRecoincilliations
     * const coinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoinwiseTradeRecoincilliationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwiseTradeRecoincilliationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoinwiseTradeRecoincilliation.
     * @param {CoinwiseTradeRecoincilliationUpsertArgs} args - Arguments to update or create a CoinwiseTradeRecoincilliation.
     * @example
     * // Update or create a CoinwiseTradeRecoincilliation
     * const coinwiseTradeRecoincilliation = await prisma.coinwiseTradeRecoincilliation.upsert({
     *   create: {
     *     // ... data to create a CoinwiseTradeRecoincilliation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoinwiseTradeRecoincilliation we want to update
     *   }
     * })
    **/
    upsert<T extends CoinwiseTradeRecoincilliationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwiseTradeRecoincilliationUpsertArgs<ExtArgs>>
    ): Prisma__CoinwiseTradeRecoincilliationClient<$Result.GetResult<Prisma.$CoinwiseTradeRecoincilliationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CoinwiseTradeRecoincilliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwiseTradeRecoincilliationCountArgs} args - Arguments to filter CoinwiseTradeRecoincilliations to count.
     * @example
     * // Count the number of CoinwiseTradeRecoincilliations
     * const count = await prisma.coinwiseTradeRecoincilliation.count({
     *   where: {
     *     // ... the filter for the CoinwiseTradeRecoincilliations we want to count
     *   }
     * })
    **/
    count<T extends CoinwiseTradeRecoincilliationCountArgs>(
      args?: Subset<T, CoinwiseTradeRecoincilliationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoinwiseTradeRecoincilliationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoinwiseTradeRecoincilliation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwiseTradeRecoincilliationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoinwiseTradeRecoincilliationAggregateArgs>(args: Subset<T, CoinwiseTradeRecoincilliationAggregateArgs>): Prisma.PrismaPromise<GetCoinwiseTradeRecoincilliationAggregateType<T>>

    /**
     * Group by CoinwiseTradeRecoincilliation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwiseTradeRecoincilliationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoinwiseTradeRecoincilliationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoinwiseTradeRecoincilliationGroupByArgs['orderBy'] }
        : { orderBy?: CoinwiseTradeRecoincilliationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoinwiseTradeRecoincilliationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoinwiseTradeRecoincilliationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoinwiseTradeRecoincilliation model
   */
  readonly fields: CoinwiseTradeRecoincilliationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoinwiseTradeRecoincilliation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoinwiseTradeRecoincilliationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CoinwiseTradeRecoincilliation model
   */ 
  interface CoinwiseTradeRecoincilliationFieldRefs {
    readonly id: FieldRef<"CoinwiseTradeRecoincilliation", 'Int'>
    readonly createdAt: FieldRef<"CoinwiseTradeRecoincilliation", 'DateTime'>
    readonly createdBy: FieldRef<"CoinwiseTradeRecoincilliation", 'Int'>
    readonly updatedAt: FieldRef<"CoinwiseTradeRecoincilliation", 'DateTime'>
    readonly updatedBy: FieldRef<"CoinwiseTradeRecoincilliation", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CoinwiseTradeRecoincilliation findUnique
   */
  export type CoinwiseTradeRecoincilliationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwiseTradeRecoincilliation to fetch.
     */
    where: CoinwiseTradeRecoincilliationWhereUniqueInput
  }


  /**
   * CoinwiseTradeRecoincilliation findUniqueOrThrow
   */
  export type CoinwiseTradeRecoincilliationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwiseTradeRecoincilliation to fetch.
     */
    where: CoinwiseTradeRecoincilliationWhereUniqueInput
  }


  /**
   * CoinwiseTradeRecoincilliation findFirst
   */
  export type CoinwiseTradeRecoincilliationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwiseTradeRecoincilliation to fetch.
     */
    where?: CoinwiseTradeRecoincilliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinwiseTradeRecoincilliations to fetch.
     */
    orderBy?: CoinwiseTradeRecoincilliationOrderByWithRelationInput | CoinwiseTradeRecoincilliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinwiseTradeRecoincilliations.
     */
    cursor?: CoinwiseTradeRecoincilliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinwiseTradeRecoincilliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinwiseTradeRecoincilliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinwiseTradeRecoincilliations.
     */
    distinct?: CoinwiseTradeRecoincilliationScalarFieldEnum | CoinwiseTradeRecoincilliationScalarFieldEnum[]
  }


  /**
   * CoinwiseTradeRecoincilliation findFirstOrThrow
   */
  export type CoinwiseTradeRecoincilliationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwiseTradeRecoincilliation to fetch.
     */
    where?: CoinwiseTradeRecoincilliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinwiseTradeRecoincilliations to fetch.
     */
    orderBy?: CoinwiseTradeRecoincilliationOrderByWithRelationInput | CoinwiseTradeRecoincilliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinwiseTradeRecoincilliations.
     */
    cursor?: CoinwiseTradeRecoincilliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinwiseTradeRecoincilliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinwiseTradeRecoincilliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinwiseTradeRecoincilliations.
     */
    distinct?: CoinwiseTradeRecoincilliationScalarFieldEnum | CoinwiseTradeRecoincilliationScalarFieldEnum[]
  }


  /**
   * CoinwiseTradeRecoincilliation findMany
   */
  export type CoinwiseTradeRecoincilliationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwiseTradeRecoincilliations to fetch.
     */
    where?: CoinwiseTradeRecoincilliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinwiseTradeRecoincilliations to fetch.
     */
    orderBy?: CoinwiseTradeRecoincilliationOrderByWithRelationInput | CoinwiseTradeRecoincilliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoinwiseTradeRecoincilliations.
     */
    cursor?: CoinwiseTradeRecoincilliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinwiseTradeRecoincilliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinwiseTradeRecoincilliations.
     */
    skip?: number
    distinct?: CoinwiseTradeRecoincilliationScalarFieldEnum | CoinwiseTradeRecoincilliationScalarFieldEnum[]
  }


  /**
   * CoinwiseTradeRecoincilliation create
   */
  export type CoinwiseTradeRecoincilliationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * The data needed to create a CoinwiseTradeRecoincilliation.
     */
    data: XOR<CoinwiseTradeRecoincilliationCreateInput, CoinwiseTradeRecoincilliationUncheckedCreateInput>
  }


  /**
   * CoinwiseTradeRecoincilliation createMany
   */
  export type CoinwiseTradeRecoincilliationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoinwiseTradeRecoincilliations.
     */
    data: CoinwiseTradeRecoincilliationCreateManyInput | CoinwiseTradeRecoincilliationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CoinwiseTradeRecoincilliation update
   */
  export type CoinwiseTradeRecoincilliationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * The data needed to update a CoinwiseTradeRecoincilliation.
     */
    data: XOR<CoinwiseTradeRecoincilliationUpdateInput, CoinwiseTradeRecoincilliationUncheckedUpdateInput>
    /**
     * Choose, which CoinwiseTradeRecoincilliation to update.
     */
    where: CoinwiseTradeRecoincilliationWhereUniqueInput
  }


  /**
   * CoinwiseTradeRecoincilliation updateMany
   */
  export type CoinwiseTradeRecoincilliationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoinwiseTradeRecoincilliations.
     */
    data: XOR<CoinwiseTradeRecoincilliationUpdateManyMutationInput, CoinwiseTradeRecoincilliationUncheckedUpdateManyInput>
    /**
     * Filter which CoinwiseTradeRecoincilliations to update
     */
    where?: CoinwiseTradeRecoincilliationWhereInput
  }


  /**
   * CoinwiseTradeRecoincilliation upsert
   */
  export type CoinwiseTradeRecoincilliationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * The filter to search for the CoinwiseTradeRecoincilliation to update in case it exists.
     */
    where: CoinwiseTradeRecoincilliationWhereUniqueInput
    /**
     * In case the CoinwiseTradeRecoincilliation found by the `where` argument doesn't exist, create a new CoinwiseTradeRecoincilliation with this data.
     */
    create: XOR<CoinwiseTradeRecoincilliationCreateInput, CoinwiseTradeRecoincilliationUncheckedCreateInput>
    /**
     * In case the CoinwiseTradeRecoincilliation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoinwiseTradeRecoincilliationUpdateInput, CoinwiseTradeRecoincilliationUncheckedUpdateInput>
  }


  /**
   * CoinwiseTradeRecoincilliation delete
   */
  export type CoinwiseTradeRecoincilliationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter which CoinwiseTradeRecoincilliation to delete.
     */
    where: CoinwiseTradeRecoincilliationWhereUniqueInput
  }


  /**
   * CoinwiseTradeRecoincilliation deleteMany
   */
  export type CoinwiseTradeRecoincilliationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinwiseTradeRecoincilliations to delete
     */
    where?: CoinwiseTradeRecoincilliationWhereInput
  }


  /**
   * CoinwiseTradeRecoincilliation without action
   */
  export type CoinwiseTradeRecoincilliationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwiseTradeRecoincilliation
     */
    select?: CoinwiseTradeRecoincilliationSelect<ExtArgs> | null
  }



  /**
   * Model CoinwisePositionRecoincilliation
   */

  export type AggregateCoinwisePositionRecoincilliation = {
    _count: CoinwisePositionRecoincilliationCountAggregateOutputType | null
    _avg: CoinwisePositionRecoincilliationAvgAggregateOutputType | null
    _sum: CoinwisePositionRecoincilliationSumAggregateOutputType | null
    _min: CoinwisePositionRecoincilliationMinAggregateOutputType | null
    _max: CoinwisePositionRecoincilliationMaxAggregateOutputType | null
  }

  export type CoinwisePositionRecoincilliationAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CoinwisePositionRecoincilliationSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CoinwisePositionRecoincilliationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CoinwisePositionRecoincilliationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type CoinwisePositionRecoincilliationCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type CoinwisePositionRecoincilliationAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CoinwisePositionRecoincilliationSumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CoinwisePositionRecoincilliationMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CoinwisePositionRecoincilliationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type CoinwisePositionRecoincilliationCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type CoinwisePositionRecoincilliationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinwisePositionRecoincilliation to aggregate.
     */
    where?: CoinwisePositionRecoincilliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinwisePositionRecoincilliations to fetch.
     */
    orderBy?: CoinwisePositionRecoincilliationOrderByWithRelationInput | CoinwisePositionRecoincilliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoinwisePositionRecoincilliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinwisePositionRecoincilliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinwisePositionRecoincilliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoinwisePositionRecoincilliations
    **/
    _count?: true | CoinwisePositionRecoincilliationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoinwisePositionRecoincilliationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoinwisePositionRecoincilliationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoinwisePositionRecoincilliationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoinwisePositionRecoincilliationMaxAggregateInputType
  }

  export type GetCoinwisePositionRecoincilliationAggregateType<T extends CoinwisePositionRecoincilliationAggregateArgs> = {
        [P in keyof T & keyof AggregateCoinwisePositionRecoincilliation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoinwisePositionRecoincilliation[P]>
      : GetScalarType<T[P], AggregateCoinwisePositionRecoincilliation[P]>
  }




  export type CoinwisePositionRecoincilliationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CoinwisePositionRecoincilliationWhereInput
    orderBy?: CoinwisePositionRecoincilliationOrderByWithAggregationInput | CoinwisePositionRecoincilliationOrderByWithAggregationInput[]
    by: CoinwisePositionRecoincilliationScalarFieldEnum[] | CoinwisePositionRecoincilliationScalarFieldEnum
    having?: CoinwisePositionRecoincilliationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoinwisePositionRecoincilliationCountAggregateInputType | true
    _avg?: CoinwisePositionRecoincilliationAvgAggregateInputType
    _sum?: CoinwisePositionRecoincilliationSumAggregateInputType
    _min?: CoinwisePositionRecoincilliationMinAggregateInputType
    _max?: CoinwisePositionRecoincilliationMaxAggregateInputType
  }

  export type CoinwisePositionRecoincilliationGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: CoinwisePositionRecoincilliationCountAggregateOutputType | null
    _avg: CoinwisePositionRecoincilliationAvgAggregateOutputType | null
    _sum: CoinwisePositionRecoincilliationSumAggregateOutputType | null
    _min: CoinwisePositionRecoincilliationMinAggregateOutputType | null
    _max: CoinwisePositionRecoincilliationMaxAggregateOutputType | null
  }

  type GetCoinwisePositionRecoincilliationGroupByPayload<T extends CoinwisePositionRecoincilliationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoinwisePositionRecoincilliationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoinwisePositionRecoincilliationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoinwisePositionRecoincilliationGroupByOutputType[P]>
            : GetScalarType<T[P], CoinwisePositionRecoincilliationGroupByOutputType[P]>
        }
      >
    >


  export type CoinwisePositionRecoincilliationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["coinwisePositionRecoincilliation"]>

  export type CoinwisePositionRecoincilliationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $CoinwisePositionRecoincilliationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CoinwisePositionRecoincilliation"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["coinwisePositionRecoincilliation"]>
    composites: {}
  }


  type CoinwisePositionRecoincilliationGetPayload<S extends boolean | null | undefined | CoinwisePositionRecoincilliationDefaultArgs> = $Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload, S>

  type CoinwisePositionRecoincilliationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CoinwisePositionRecoincilliationFindManyArgs, 'select' | 'include'> & {
      select?: CoinwisePositionRecoincilliationCountAggregateInputType | true
    }

  export interface CoinwisePositionRecoincilliationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoinwisePositionRecoincilliation'], meta: { name: 'CoinwisePositionRecoincilliation' } }
    /**
     * Find zero or one CoinwisePositionRecoincilliation that matches the filter.
     * @param {CoinwisePositionRecoincilliationFindUniqueArgs} args - Arguments to find a CoinwisePositionRecoincilliation
     * @example
     * // Get one CoinwisePositionRecoincilliation
     * const coinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoinwisePositionRecoincilliationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwisePositionRecoincilliationFindUniqueArgs<ExtArgs>>
    ): Prisma__CoinwisePositionRecoincilliationClient<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CoinwisePositionRecoincilliation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CoinwisePositionRecoincilliationFindUniqueOrThrowArgs} args - Arguments to find a CoinwisePositionRecoincilliation
     * @example
     * // Get one CoinwisePositionRecoincilliation
     * const coinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CoinwisePositionRecoincilliationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwisePositionRecoincilliationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CoinwisePositionRecoincilliationClient<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CoinwisePositionRecoincilliation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwisePositionRecoincilliationFindFirstArgs} args - Arguments to find a CoinwisePositionRecoincilliation
     * @example
     * // Get one CoinwisePositionRecoincilliation
     * const coinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoinwisePositionRecoincilliationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwisePositionRecoincilliationFindFirstArgs<ExtArgs>>
    ): Prisma__CoinwisePositionRecoincilliationClient<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CoinwisePositionRecoincilliation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwisePositionRecoincilliationFindFirstOrThrowArgs} args - Arguments to find a CoinwisePositionRecoincilliation
     * @example
     * // Get one CoinwisePositionRecoincilliation
     * const coinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CoinwisePositionRecoincilliationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwisePositionRecoincilliationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CoinwisePositionRecoincilliationClient<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CoinwisePositionRecoincilliations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwisePositionRecoincilliationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoinwisePositionRecoincilliations
     * const coinwisePositionRecoincilliations = await prisma.coinwisePositionRecoincilliation.findMany()
     * 
     * // Get first 10 CoinwisePositionRecoincilliations
     * const coinwisePositionRecoincilliations = await prisma.coinwisePositionRecoincilliation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coinwisePositionRecoincilliationWithIdOnly = await prisma.coinwisePositionRecoincilliation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CoinwisePositionRecoincilliationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwisePositionRecoincilliationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CoinwisePositionRecoincilliation.
     * @param {CoinwisePositionRecoincilliationCreateArgs} args - Arguments to create a CoinwisePositionRecoincilliation.
     * @example
     * // Create one CoinwisePositionRecoincilliation
     * const CoinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.create({
     *   data: {
     *     // ... data to create a CoinwisePositionRecoincilliation
     *   }
     * })
     * 
    **/
    create<T extends CoinwisePositionRecoincilliationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwisePositionRecoincilliationCreateArgs<ExtArgs>>
    ): Prisma__CoinwisePositionRecoincilliationClient<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CoinwisePositionRecoincilliations.
     *     @param {CoinwisePositionRecoincilliationCreateManyArgs} args - Arguments to create many CoinwisePositionRecoincilliations.
     *     @example
     *     // Create many CoinwisePositionRecoincilliations
     *     const coinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CoinwisePositionRecoincilliationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwisePositionRecoincilliationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CoinwisePositionRecoincilliation.
     * @param {CoinwisePositionRecoincilliationDeleteArgs} args - Arguments to delete one CoinwisePositionRecoincilliation.
     * @example
     * // Delete one CoinwisePositionRecoincilliation
     * const CoinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.delete({
     *   where: {
     *     // ... filter to delete one CoinwisePositionRecoincilliation
     *   }
     * })
     * 
    **/
    delete<T extends CoinwisePositionRecoincilliationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwisePositionRecoincilliationDeleteArgs<ExtArgs>>
    ): Prisma__CoinwisePositionRecoincilliationClient<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CoinwisePositionRecoincilliation.
     * @param {CoinwisePositionRecoincilliationUpdateArgs} args - Arguments to update one CoinwisePositionRecoincilliation.
     * @example
     * // Update one CoinwisePositionRecoincilliation
     * const coinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoinwisePositionRecoincilliationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwisePositionRecoincilliationUpdateArgs<ExtArgs>>
    ): Prisma__CoinwisePositionRecoincilliationClient<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CoinwisePositionRecoincilliations.
     * @param {CoinwisePositionRecoincilliationDeleteManyArgs} args - Arguments to filter CoinwisePositionRecoincilliations to delete.
     * @example
     * // Delete a few CoinwisePositionRecoincilliations
     * const { count } = await prisma.coinwisePositionRecoincilliation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoinwisePositionRecoincilliationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoinwisePositionRecoincilliationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoinwisePositionRecoincilliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwisePositionRecoincilliationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoinwisePositionRecoincilliations
     * const coinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoinwisePositionRecoincilliationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwisePositionRecoincilliationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoinwisePositionRecoincilliation.
     * @param {CoinwisePositionRecoincilliationUpsertArgs} args - Arguments to update or create a CoinwisePositionRecoincilliation.
     * @example
     * // Update or create a CoinwisePositionRecoincilliation
     * const coinwisePositionRecoincilliation = await prisma.coinwisePositionRecoincilliation.upsert({
     *   create: {
     *     // ... data to create a CoinwisePositionRecoincilliation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoinwisePositionRecoincilliation we want to update
     *   }
     * })
    **/
    upsert<T extends CoinwisePositionRecoincilliationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CoinwisePositionRecoincilliationUpsertArgs<ExtArgs>>
    ): Prisma__CoinwisePositionRecoincilliationClient<$Result.GetResult<Prisma.$CoinwisePositionRecoincilliationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CoinwisePositionRecoincilliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwisePositionRecoincilliationCountArgs} args - Arguments to filter CoinwisePositionRecoincilliations to count.
     * @example
     * // Count the number of CoinwisePositionRecoincilliations
     * const count = await prisma.coinwisePositionRecoincilliation.count({
     *   where: {
     *     // ... the filter for the CoinwisePositionRecoincilliations we want to count
     *   }
     * })
    **/
    count<T extends CoinwisePositionRecoincilliationCountArgs>(
      args?: Subset<T, CoinwisePositionRecoincilliationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoinwisePositionRecoincilliationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoinwisePositionRecoincilliation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwisePositionRecoincilliationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoinwisePositionRecoincilliationAggregateArgs>(args: Subset<T, CoinwisePositionRecoincilliationAggregateArgs>): Prisma.PrismaPromise<GetCoinwisePositionRecoincilliationAggregateType<T>>

    /**
     * Group by CoinwisePositionRecoincilliation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinwisePositionRecoincilliationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoinwisePositionRecoincilliationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoinwisePositionRecoincilliationGroupByArgs['orderBy'] }
        : { orderBy?: CoinwisePositionRecoincilliationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoinwisePositionRecoincilliationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoinwisePositionRecoincilliationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoinwisePositionRecoincilliation model
   */
  readonly fields: CoinwisePositionRecoincilliationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoinwisePositionRecoincilliation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoinwisePositionRecoincilliationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CoinwisePositionRecoincilliation model
   */ 
  interface CoinwisePositionRecoincilliationFieldRefs {
    readonly id: FieldRef<"CoinwisePositionRecoincilliation", 'Int'>
    readonly createdAt: FieldRef<"CoinwisePositionRecoincilliation", 'DateTime'>
    readonly createdBy: FieldRef<"CoinwisePositionRecoincilliation", 'Int'>
    readonly updatedAt: FieldRef<"CoinwisePositionRecoincilliation", 'DateTime'>
    readonly updatedBy: FieldRef<"CoinwisePositionRecoincilliation", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CoinwisePositionRecoincilliation findUnique
   */
  export type CoinwisePositionRecoincilliationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwisePositionRecoincilliation to fetch.
     */
    where: CoinwisePositionRecoincilliationWhereUniqueInput
  }


  /**
   * CoinwisePositionRecoincilliation findUniqueOrThrow
   */
  export type CoinwisePositionRecoincilliationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwisePositionRecoincilliation to fetch.
     */
    where: CoinwisePositionRecoincilliationWhereUniqueInput
  }


  /**
   * CoinwisePositionRecoincilliation findFirst
   */
  export type CoinwisePositionRecoincilliationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwisePositionRecoincilliation to fetch.
     */
    where?: CoinwisePositionRecoincilliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinwisePositionRecoincilliations to fetch.
     */
    orderBy?: CoinwisePositionRecoincilliationOrderByWithRelationInput | CoinwisePositionRecoincilliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinwisePositionRecoincilliations.
     */
    cursor?: CoinwisePositionRecoincilliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinwisePositionRecoincilliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinwisePositionRecoincilliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinwisePositionRecoincilliations.
     */
    distinct?: CoinwisePositionRecoincilliationScalarFieldEnum | CoinwisePositionRecoincilliationScalarFieldEnum[]
  }


  /**
   * CoinwisePositionRecoincilliation findFirstOrThrow
   */
  export type CoinwisePositionRecoincilliationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwisePositionRecoincilliation to fetch.
     */
    where?: CoinwisePositionRecoincilliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinwisePositionRecoincilliations to fetch.
     */
    orderBy?: CoinwisePositionRecoincilliationOrderByWithRelationInput | CoinwisePositionRecoincilliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinwisePositionRecoincilliations.
     */
    cursor?: CoinwisePositionRecoincilliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinwisePositionRecoincilliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinwisePositionRecoincilliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinwisePositionRecoincilliations.
     */
    distinct?: CoinwisePositionRecoincilliationScalarFieldEnum | CoinwisePositionRecoincilliationScalarFieldEnum[]
  }


  /**
   * CoinwisePositionRecoincilliation findMany
   */
  export type CoinwisePositionRecoincilliationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter, which CoinwisePositionRecoincilliations to fetch.
     */
    where?: CoinwisePositionRecoincilliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinwisePositionRecoincilliations to fetch.
     */
    orderBy?: CoinwisePositionRecoincilliationOrderByWithRelationInput | CoinwisePositionRecoincilliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoinwisePositionRecoincilliations.
     */
    cursor?: CoinwisePositionRecoincilliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinwisePositionRecoincilliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinwisePositionRecoincilliations.
     */
    skip?: number
    distinct?: CoinwisePositionRecoincilliationScalarFieldEnum | CoinwisePositionRecoincilliationScalarFieldEnum[]
  }


  /**
   * CoinwisePositionRecoincilliation create
   */
  export type CoinwisePositionRecoincilliationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * The data needed to create a CoinwisePositionRecoincilliation.
     */
    data: XOR<CoinwisePositionRecoincilliationCreateInput, CoinwisePositionRecoincilliationUncheckedCreateInput>
  }


  /**
   * CoinwisePositionRecoincilliation createMany
   */
  export type CoinwisePositionRecoincilliationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoinwisePositionRecoincilliations.
     */
    data: CoinwisePositionRecoincilliationCreateManyInput | CoinwisePositionRecoincilliationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CoinwisePositionRecoincilliation update
   */
  export type CoinwisePositionRecoincilliationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * The data needed to update a CoinwisePositionRecoincilliation.
     */
    data: XOR<CoinwisePositionRecoincilliationUpdateInput, CoinwisePositionRecoincilliationUncheckedUpdateInput>
    /**
     * Choose, which CoinwisePositionRecoincilliation to update.
     */
    where: CoinwisePositionRecoincilliationWhereUniqueInput
  }


  /**
   * CoinwisePositionRecoincilliation updateMany
   */
  export type CoinwisePositionRecoincilliationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoinwisePositionRecoincilliations.
     */
    data: XOR<CoinwisePositionRecoincilliationUpdateManyMutationInput, CoinwisePositionRecoincilliationUncheckedUpdateManyInput>
    /**
     * Filter which CoinwisePositionRecoincilliations to update
     */
    where?: CoinwisePositionRecoincilliationWhereInput
  }


  /**
   * CoinwisePositionRecoincilliation upsert
   */
  export type CoinwisePositionRecoincilliationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * The filter to search for the CoinwisePositionRecoincilliation to update in case it exists.
     */
    where: CoinwisePositionRecoincilliationWhereUniqueInput
    /**
     * In case the CoinwisePositionRecoincilliation found by the `where` argument doesn't exist, create a new CoinwisePositionRecoincilliation with this data.
     */
    create: XOR<CoinwisePositionRecoincilliationCreateInput, CoinwisePositionRecoincilliationUncheckedCreateInput>
    /**
     * In case the CoinwisePositionRecoincilliation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoinwisePositionRecoincilliationUpdateInput, CoinwisePositionRecoincilliationUncheckedUpdateInput>
  }


  /**
   * CoinwisePositionRecoincilliation delete
   */
  export type CoinwisePositionRecoincilliationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
    /**
     * Filter which CoinwisePositionRecoincilliation to delete.
     */
    where: CoinwisePositionRecoincilliationWhereUniqueInput
  }


  /**
   * CoinwisePositionRecoincilliation deleteMany
   */
  export type CoinwisePositionRecoincilliationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinwisePositionRecoincilliations to delete
     */
    where?: CoinwisePositionRecoincilliationWhereInput
  }


  /**
   * CoinwisePositionRecoincilliation without action
   */
  export type CoinwisePositionRecoincilliationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinwisePositionRecoincilliation
     */
    select?: CoinwisePositionRecoincilliationSelect<ExtArgs> | null
  }



  /**
   * Model Invoices
   */

  export type AggregateInvoices = {
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  export type InvoicesAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type InvoicesSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type InvoicesMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type InvoicesMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type InvoicesCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type InvoicesAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InvoicesSumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InvoicesMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InvoicesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InvoicesCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type InvoicesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to aggregate.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicesMaxAggregateInputType
  }

  export type GetInvoicesAggregateType<T extends InvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoices[P]>
      : GetScalarType<T[P], AggregateInvoices[P]>
  }




  export type InvoicesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoicesWhereInput
    orderBy?: InvoicesOrderByWithAggregationInput | InvoicesOrderByWithAggregationInput[]
    by: InvoicesScalarFieldEnum[] | InvoicesScalarFieldEnum
    having?: InvoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicesCountAggregateInputType | true
    _avg?: InvoicesAvgAggregateInputType
    _sum?: InvoicesSumAggregateInputType
    _min?: InvoicesMinAggregateInputType
    _max?: InvoicesMaxAggregateInputType
  }

  export type InvoicesGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  type GetInvoicesGroupByPayload<T extends InvoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
        }
      >
    >


  export type InvoicesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["invoices"]>

  export type InvoicesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $InvoicesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Invoices"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["invoices"]>
    composites: {}
  }


  type InvoicesGetPayload<S extends boolean | null | undefined | InvoicesDefaultArgs> = $Result.GetResult<Prisma.$InvoicesPayload, S>

  type InvoicesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvoicesFindManyArgs, 'select' | 'include'> & {
      select?: InvoicesCountAggregateInputType | true
    }

  export interface InvoicesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoices'], meta: { name: 'Invoices' } }
    /**
     * Find zero or one Invoices that matches the filter.
     * @param {InvoicesFindUniqueArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesFindUniqueArgs<ExtArgs>>
    ): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Invoices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvoicesFindUniqueOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesFindFirstArgs<ExtArgs>>
    ): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Invoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoices.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoicesWithIdOnly = await prisma.invoices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Invoices.
     * @param {InvoicesCreateArgs} args - Arguments to create a Invoices.
     * @example
     * // Create one Invoices
     * const Invoices = await prisma.invoices.create({
     *   data: {
     *     // ... data to create a Invoices
     *   }
     * })
     * 
    **/
    create<T extends InvoicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesCreateArgs<ExtArgs>>
    ): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Invoices.
     *     @param {InvoicesCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoices = await prisma.invoices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoices.
     * @param {InvoicesDeleteArgs} args - Arguments to delete one Invoices.
     * @example
     * // Delete one Invoices
     * const Invoices = await prisma.invoices.delete({
     *   where: {
     *     // ... filter to delete one Invoices
     *   }
     * })
     * 
    **/
    delete<T extends InvoicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesDeleteArgs<ExtArgs>>
    ): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Invoices.
     * @param {InvoicesUpdateArgs} args - Arguments to update one Invoices.
     * @example
     * // Update one Invoices
     * const invoices = await prisma.invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesUpdateArgs<ExtArgs>>
    ): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoicesDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoices.
     * @param {InvoicesUpsertArgs} args - Arguments to update or create a Invoices.
     * @example
     * // Update or create a Invoices
     * const invoices = await prisma.invoices.upsert({
     *   create: {
     *     // ... data to create a Invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoices we want to update
     *   }
     * })
    **/
    upsert<T extends InvoicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesUpsertArgs<ExtArgs>>
    ): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoices.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoicesCountArgs>(
      args?: Subset<T, InvoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicesAggregateArgs>(args: Subset<T, InvoicesAggregateArgs>): Prisma.PrismaPromise<GetInvoicesAggregateType<T>>

    /**
     * Group by Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoicesGroupByArgs['orderBy'] }
        : { orderBy?: InvoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoices model
   */
  readonly fields: InvoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoicesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Invoices model
   */ 
  interface InvoicesFieldRefs {
    readonly id: FieldRef<"Invoices", 'Int'>
    readonly createdAt: FieldRef<"Invoices", 'DateTime'>
    readonly createdBy: FieldRef<"Invoices", 'Int'>
    readonly updatedAt: FieldRef<"Invoices", 'DateTime'>
    readonly updatedBy: FieldRef<"Invoices", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Invoices findUnique
   */
  export type InvoicesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where: InvoicesWhereUniqueInput
  }


  /**
   * Invoices findUniqueOrThrow
   */
  export type InvoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where: InvoicesWhereUniqueInput
  }


  /**
   * Invoices findFirst
   */
  export type InvoicesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }


  /**
   * Invoices findFirstOrThrow
   */
  export type InvoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }


  /**
   * Invoices findMany
   */
  export type InvoicesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }


  /**
   * Invoices create
   */
  export type InvoicesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * The data needed to create a Invoices.
     */
    data: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>
  }


  /**
   * Invoices createMany
   */
  export type InvoicesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoicesCreateManyInput | InvoicesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Invoices update
   */
  export type InvoicesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * The data needed to update a Invoices.
     */
    data: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>
    /**
     * Choose, which Invoices to update.
     */
    where: InvoicesWhereUniqueInput
  }


  /**
   * Invoices updateMany
   */
  export type InvoicesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoicesWhereInput
  }


  /**
   * Invoices upsert
   */
  export type InvoicesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * The filter to search for the Invoices to update in case it exists.
     */
    where: InvoicesWhereUniqueInput
    /**
     * In case the Invoices found by the `where` argument doesn't exist, create a new Invoices with this data.
     */
    create: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>
    /**
     * In case the Invoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>
  }


  /**
   * Invoices delete
   */
  export type InvoicesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Filter which Invoices to delete.
     */
    where: InvoicesWhereUniqueInput
  }


  /**
   * Invoices deleteMany
   */
  export type InvoicesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoicesWhereInput
  }


  /**
   * Invoices without action
   */
  export type InvoicesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
  }



  /**
   * Model Reports
   */

  export type AggregateReports = {
    _count: ReportsCountAggregateOutputType | null
    _avg: ReportsAvgAggregateOutputType | null
    _sum: ReportsSumAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  export type ReportsAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type ReportsSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type ReportsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type ReportsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    createdBy: number | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type ReportsCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ReportsAvgAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ReportsSumAggregateInputType = {
    id?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ReportsMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ReportsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ReportsCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ReportsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to aggregate.
     */
    where?: ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportsOrderByWithRelationInput | ReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportsMaxAggregateInputType
  }

  export type GetReportsAggregateType<T extends ReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReports[P]>
      : GetScalarType<T[P], AggregateReports[P]>
  }




  export type ReportsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReportsWhereInput
    orderBy?: ReportsOrderByWithAggregationInput | ReportsOrderByWithAggregationInput[]
    by: ReportsScalarFieldEnum[] | ReportsScalarFieldEnum
    having?: ReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportsCountAggregateInputType | true
    _avg?: ReportsAvgAggregateInputType
    _sum?: ReportsSumAggregateInputType
    _min?: ReportsMinAggregateInputType
    _max?: ReportsMaxAggregateInputType
  }

  export type ReportsGroupByOutputType = {
    id: number
    createdAt: Date
    createdBy: number
    updatedAt: Date
    updatedBy: number
    _count: ReportsCountAggregateOutputType | null
    _avg: ReportsAvgAggregateOutputType | null
    _sum: ReportsSumAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  type GetReportsGroupByPayload<T extends ReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportsGroupByOutputType[P]>
            : GetScalarType<T[P], ReportsGroupByOutputType[P]>
        }
      >
    >


  export type ReportsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["reports"]>

  export type ReportsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $ReportsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Reports"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      createdAt: Date
      createdBy: number
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["reports"]>
    composites: {}
  }


  type ReportsGetPayload<S extends boolean | null | undefined | ReportsDefaultArgs> = $Result.GetResult<Prisma.$ReportsPayload, S>

  type ReportsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ReportsFindManyArgs, 'select' | 'include'> & {
      select?: ReportsCountAggregateInputType | true
    }

  export interface ReportsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reports'], meta: { name: 'Reports' } }
    /**
     * Find zero or one Reports that matches the filter.
     * @param {ReportsFindUniqueArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportsFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportsClient<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Reports that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportsFindUniqueOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportsClient<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsFindFirstArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportsFindFirstArgs<ExtArgs>>
    ): Prisma__ReportsClient<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Reports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsFindFirstOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportsClient<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.reports.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.reports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportsWithIdOnly = await prisma.reports.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Reports.
     * @param {ReportsCreateArgs} args - Arguments to create a Reports.
     * @example
     * // Create one Reports
     * const Reports = await prisma.reports.create({
     *   data: {
     *     // ... data to create a Reports
     *   }
     * })
     * 
    **/
    create<T extends ReportsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportsCreateArgs<ExtArgs>>
    ): Prisma__ReportsClient<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportsCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const reports = await prisma.reports.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reports.
     * @param {ReportsDeleteArgs} args - Arguments to delete one Reports.
     * @example
     * // Delete one Reports
     * const Reports = await prisma.reports.delete({
     *   where: {
     *     // ... filter to delete one Reports
     *   }
     * })
     * 
    **/
    delete<T extends ReportsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportsDeleteArgs<ExtArgs>>
    ): Prisma__ReportsClient<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Reports.
     * @param {ReportsUpdateArgs} args - Arguments to update one Reports.
     * @example
     * // Update one Reports
     * const reports = await prisma.reports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportsUpdateArgs<ExtArgs>>
    ): Prisma__ReportsClient<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportsDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.reports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const reports = await prisma.reports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reports.
     * @param {ReportsUpsertArgs} args - Arguments to update or create a Reports.
     * @example
     * // Update or create a Reports
     * const reports = await prisma.reports.upsert({
     *   create: {
     *     // ... data to create a Reports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reports we want to update
     *   }
     * })
    **/
    upsert<T extends ReportsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportsUpsertArgs<ExtArgs>>
    ): Prisma__ReportsClient<$Result.GetResult<Prisma.$ReportsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.reports.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportsCountArgs>(
      args?: Subset<T, ReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportsAggregateArgs>(args: Subset<T, ReportsAggregateArgs>): Prisma.PrismaPromise<GetReportsAggregateType<T>>

    /**
     * Group by Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportsGroupByArgs['orderBy'] }
        : { orderBy?: ReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reports model
   */
  readonly fields: ReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Reports model
   */ 
  interface ReportsFieldRefs {
    readonly id: FieldRef<"Reports", 'Int'>
    readonly createdAt: FieldRef<"Reports", 'DateTime'>
    readonly createdBy: FieldRef<"Reports", 'Int'>
    readonly updatedAt: FieldRef<"Reports", 'DateTime'>
    readonly updatedBy: FieldRef<"Reports", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Reports findUnique
   */
  export type ReportsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where: ReportsWhereUniqueInput
  }


  /**
   * Reports findUniqueOrThrow
   */
  export type ReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where: ReportsWhereUniqueInput
  }


  /**
   * Reports findFirst
   */
  export type ReportsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportsOrderByWithRelationInput | ReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }


  /**
   * Reports findFirstOrThrow
   */
  export type ReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportsOrderByWithRelationInput | ReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }


  /**
   * Reports findMany
   */
  export type ReportsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportsOrderByWithRelationInput | ReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }


  /**
   * Reports create
   */
  export type ReportsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * The data needed to create a Reports.
     */
    data: XOR<ReportsCreateInput, ReportsUncheckedCreateInput>
  }


  /**
   * Reports createMany
   */
  export type ReportsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportsCreateManyInput | ReportsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Reports update
   */
  export type ReportsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * The data needed to update a Reports.
     */
    data: XOR<ReportsUpdateInput, ReportsUncheckedUpdateInput>
    /**
     * Choose, which Reports to update.
     */
    where: ReportsWhereUniqueInput
  }


  /**
   * Reports updateMany
   */
  export type ReportsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportsUpdateManyMutationInput, ReportsUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportsWhereInput
  }


  /**
   * Reports upsert
   */
  export type ReportsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * The filter to search for the Reports to update in case it exists.
     */
    where: ReportsWhereUniqueInput
    /**
     * In case the Reports found by the `where` argument doesn't exist, create a new Reports with this data.
     */
    create: XOR<ReportsCreateInput, ReportsUncheckedCreateInput>
    /**
     * In case the Reports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportsUpdateInput, ReportsUncheckedUpdateInput>
  }


  /**
   * Reports delete
   */
  export type ReportsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
    /**
     * Filter which Reports to delete.
     */
    where: ReportsWhereUniqueInput
  }


  /**
   * Reports deleteMany
   */
  export type ReportsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportsWhereInput
  }


  /**
   * Reports without action
   */
  export type ReportsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reports
     */
    select?: ReportsSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    parentAccount: 'parentAccount',
    accountType: 'accountType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserAccountScalarFieldEnum = (typeof UserAccountScalarFieldEnum)[keyof typeof UserAccountScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    userType: 'userType',
    signupType: 'signupType',
    role: 'role',
    email: 'email',
    phone: 'phone',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneCountryCode: 'phoneCountryCode',
    initVector: 'initVector',
    password: 'password',
    passwordUpdatedAt: 'passwordUpdatedAt',
    kycStatus: 'kycStatus',
    kycId: 'kycId',
    bankVerificationStatus: 'bankVerificationStatus',
    bankDetailsId: 'bankDetailsId',
    isActive: 'isActive',
    inrDepositEnabled: 'inrDepositEnabled',
    cryptoDepositEnabled: 'cryptoDepositEnabled',
    inrWithdrawEnabled: 'inrWithdrawEnabled',
    cryptoWithdrawEnabled: 'cryptoWithdrawEnabled',
    tradeEnabled: 'tradeEnabled',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DepositWithdrawLimitsScalarFieldEnum: {
    id: 'id',
    userType: 'userType',
    fiatDepositLimit: 'fiatDepositLimit',
    fiatWithdrawLimit: 'fiatWithdrawLimit',
    cryptoDepositLimit: 'cryptoDepositLimit',
    cryptoWithdrawLimit: 'cryptoWithdrawLimit',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type DepositWithdrawLimitsScalarFieldEnum = (typeof DepositWithdrawLimitsScalarFieldEnum)[keyof typeof DepositWithdrawLimitsScalarFieldEnum]


  export const TwoFAScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    phone: 'phone',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    status: 'status',
    reason: 'reason',
    expiryTime: 'expiryTime',
    mobileVerifiedAtleastOnce: 'mobileVerifiedAtleastOnce',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type TwoFAScalarFieldEnum = (typeof TwoFAScalarFieldEnum)[keyof typeof TwoFAScalarFieldEnum]


  export const UserKycScalarFieldEnum: {
    id: 'id',
    encryptedUserDataId: 'encryptedUserDataId',
    fullName: 'fullName',
    gender: 'gender',
    dob: 'dob',
    address: 'address',
    fatherName: 'fatherName',
    kycType: 'kycType',
    kycStatus: 'kycStatus',
    hyperVergeStatus: 'hyperVergeStatus',
    panStatus: 'panStatus',
    aadharFrontStatus: 'aadharFrontStatus',
    aadharBackStatus: 'aadharBackStatus',
    selfieStatus: 'selfieStatus',
    aadharPanNameMatchStatus: 'aadharPanNameMatchStatus',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserKycScalarFieldEnum = (typeof UserKycScalarFieldEnum)[keyof typeof UserKycScalarFieldEnum]


  export const EncryptedUserDataScalarFieldEnum: {
    id: 'id',
    panNumber: 'panNumber',
    aadharNumber: 'aadharNumber',
    userId: 'userId',
    fileKey: 'fileKey',
    bucketName: 'bucketName',
    initVector: 'initVector',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type EncryptedUserDataScalarFieldEnum = (typeof EncryptedUserDataScalarFieldEnum)[keyof typeof EncryptedUserDataScalarFieldEnum]


  export const UserBankDetailsScalarFieldEnum: {
    id: 'id',
    bankDetailsType: 'bankDetailsType',
    userId: 'userId',
    bankAccountNumber: 'bankAccountNumber',
    bankName: 'bankName',
    accountHolderName: 'accountHolderName',
    ifsc: 'ifsc',
    bankVerificationStatus: 'bankVerificationStatus',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserBankDetailsScalarFieldEnum = (typeof UserBankDetailsScalarFieldEnum)[keyof typeof UserBankDetailsScalarFieldEnum]


  export const FiatPaymentsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    paymentType: 'paymentType',
    paymentStatus: 'paymentStatus',
    systemBankId: 'systemBankId',
    userBankId: 'userBankId',
    systemAccountNumber: 'systemAccountNumber',
    userAccountNumber: 'userAccountNumber',
    amount: 'amount',
    fee: 'fee',
    amountCredited: 'amountCredited',
    amountDebited: 'amountDebited',
    bankProofUrl: 'bankProofUrl',
    receiptNumber: 'receiptNumber',
    userRemarks: 'userRemarks',
    adminRemarks: 'adminRemarks',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type FiatPaymentsScalarFieldEnum = (typeof FiatPaymentsScalarFieldEnum)[keyof typeof FiatPaymentsScalarFieldEnum]


  export const CryptoDepositScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    cryptoWalletId: 'cryptoWalletId',
    liminalTxnRefId: 'liminalTxnRefId',
    coin: 'coin',
    walletId: 'walletId',
    timestamp: 'timestamp',
    fee: 'fee',
    effectiveChange: 'effectiveChange',
    runningBalance: 'runningBalance',
    externalAddress: 'externalAddress',
    effectiveChangeUsd: 'effectiveChangeUsd',
    wallet: 'wallet',
    tokenContractAddress: 'tokenContractAddress',
    explorerLink: 'explorerLink',
    inputs: 'inputs',
    outputs: 'outputs',
    sequenceId: 'sequenceId',
    type: 'type',
    conversionRate: 'conversionRate',
    isConverted: 'isConverted',
    conversionTimestamp: 'conversionTimestamp',
    inrCreditStatus: 'inrCreditStatus',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type CryptoDepositScalarFieldEnum = (typeof CryptoDepositScalarFieldEnum)[keyof typeof CryptoDepositScalarFieldEnum]


  export const InrConversionHistoryScalarFieldEnum: {
    id: 'id',
    cryptoDepositId: 'cryptoDepositId',
    accountId: 'accountId',
    baseToken: 'baseToken',
    baseTokenQuantity: 'baseTokenQuantity',
    inrValue: 'inrValue',
    inrValAfterDeduction: 'inrValAfterDeduction',
    gst: 'gst',
    txnFee: 'txnFee',
    tds: 'tds',
    coinConversionRate: 'coinConversionRate',
    receivingAddress: 'receivingAddress',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type InrConversionHistoryScalarFieldEnum = (typeof InrConversionHistoryScalarFieldEnum)[keyof typeof InrConversionHistoryScalarFieldEnum]


  export const BankFeedScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    serialNumber: 'serialNumber',
    amount: 'amount',
    fee: 'fee',
    bankName: 'bankName',
    bankRefId: 'bankRefId',
    processStatus: 'processStatus',
    userRemarks: 'userRemarks',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type BankFeedScalarFieldEnum = (typeof BankFeedScalarFieldEnum)[keyof typeof BankFeedScalarFieldEnum]


  export const InrLedgerScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    change: 'change',
    operation: 'operation',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type InrLedgerScalarFieldEnum = (typeof InrLedgerScalarFieldEnum)[keyof typeof InrLedgerScalarFieldEnum]


  export const CryptoLedgerScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    coin: 'coin',
    change: 'change',
    operation: 'operation',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type CryptoLedgerScalarFieldEnum = (typeof CryptoLedgerScalarFieldEnum)[keyof typeof CryptoLedgerScalarFieldEnum]


  export const TradeLedgerScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    change: 'change',
    tradeId: 'tradeId',
    positionType: 'positionType',
    operation: 'operation',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type TradeLedgerScalarFieldEnum = (typeof TradeLedgerScalarFieldEnum)[keyof typeof TradeLedgerScalarFieldEnum]


  export const SystemConfigForDashboardScalarFieldEnum: {
    id: 'id',
    parameterGroup: 'parameterGroup',
    parameterName: 'parameterName',
    parameterType: 'parameterType',
    isRanged: 'isRanged',
    parameterValue: 'parameterValue',
    symbol: 'symbol',
    rangeStart: 'rangeStart',
    rangeEnd: 'rangeEnd',
    roleBasedAccess: 'roleBasedAccess',
    role: 'role',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SystemConfigForDashboardScalarFieldEnum = (typeof SystemConfigForDashboardScalarFieldEnum)[keyof typeof SystemConfigForDashboardScalarFieldEnum]


  export const SystemConfigChangeLogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    userId: 'userId',
    parameterName: 'parameterName',
    parameterValue: 'parameterValue',
    isRanged: 'isRanged',
    rangeStart: 'rangeStart',
    rangeEnd: 'rangeEnd',
    userType: 'userType',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SystemConfigChangeLogScalarFieldEnum = (typeof SystemConfigChangeLogScalarFieldEnum)[keyof typeof SystemConfigChangeLogScalarFieldEnum]


  export const InrWalletScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    walletBalance: 'walletBalance',
    amountAvailable: 'amountAvailable',
    amountLocked: 'amountLocked',
    unrealizedPnl: 'unrealizedPnl',
    last24hourChange: 'last24hourChange',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type InrWalletScalarFieldEnum = (typeof InrWalletScalarFieldEnum)[keyof typeof InrWalletScalarFieldEnum]


  export const ParentWalletScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    walletAddress: 'walletAddress',
    chain: 'chain',
    coin: 'coin',
    parentChain: 'parentChain',
    type: 'type',
    subType: 'subType',
    lastUsedIndex: 'lastUsedIndex',
    displayName: 'displayName',
    toBeDisplayed: 'toBeDisplayed',
    parentChainIconUrl: 'parentChainIconUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentWalletScalarFieldEnum = (typeof ParentWalletScalarFieldEnum)[keyof typeof ParentWalletScalarFieldEnum]


  export const StableCoinScalarFieldEnum: {
    id: 'id',
    parentWalletId: 'parentWalletId',
    token: 'token',
    parentChain: 'parentChain',
    tokenIconUrl: 'tokenIconUrl'
  };

  export type StableCoinScalarFieldEnum = (typeof StableCoinScalarFieldEnum)[keyof typeof StableCoinScalarFieldEnum]


  export const CryptoWalletScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    parentWalletId: 'parentWalletId',
    liminalRefId: 'liminalRefId',
    liminalParentId: 'liminalParentId',
    liminalCoin: 'liminalCoin',
    liminalChain: 'liminalChain',
    publicAddress: 'publicAddress',
    balance: 'balance',
    lastConversion: 'lastConversion',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type CryptoWalletScalarFieldEnum = (typeof CryptoWalletScalarFieldEnum)[keyof typeof CryptoWalletScalarFieldEnum]


  export const PerpetualContractsScalarFieldEnum: {
    id: 'id',
    contractSymbol: 'contractSymbol',
    displayName: 'displayName',
    systemConfig: 'systemConfig',
    exchangeConfig: 'exchangeConfig',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type PerpetualContractsScalarFieldEnum = (typeof PerpetualContractsScalarFieldEnum)[keyof typeof PerpetualContractsScalarFieldEnum]


  export const KlineHistoricalDataScalarFieldEnum: {
    id: 'id',
    contractSymbol: 'contractSymbol',
    displayName: 'displayName',
    interval: 'interval',
    ohlc: 'ohlc',
    conversionRate: 'conversionRate',
    startTime: 'startTime',
    endTime: 'endTime',
    timestampIst: 'timestampIst',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type KlineHistoricalDataScalarFieldEnum = (typeof KlineHistoricalDataScalarFieldEnum)[keyof typeof KlineHistoricalDataScalarFieldEnum]


  export const UserOrderHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserOrderHistoryScalarFieldEnum = (typeof UserOrderHistoryScalarFieldEnum)[keyof typeof UserOrderHistoryScalarFieldEnum]


  export const UserTradeHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserTradeHistoryScalarFieldEnum = (typeof UserTradeHistoryScalarFieldEnum)[keyof typeof UserTradeHistoryScalarFieldEnum]


  export const UserPositionHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserPositionHistoryScalarFieldEnum = (typeof UserPositionHistoryScalarFieldEnum)[keyof typeof UserPositionHistoryScalarFieldEnum]


  export const BinanceOrderHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type BinanceOrderHistoryScalarFieldEnum = (typeof BinanceOrderHistoryScalarFieldEnum)[keyof typeof BinanceOrderHistoryScalarFieldEnum]


  export const BinanceTradeHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type BinanceTradeHistoryScalarFieldEnum = (typeof BinanceTradeHistoryScalarFieldEnum)[keyof typeof BinanceTradeHistoryScalarFieldEnum]


  export const CoinwiseTradeRecoincilliationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type CoinwiseTradeRecoincilliationScalarFieldEnum = (typeof CoinwiseTradeRecoincilliationScalarFieldEnum)[keyof typeof CoinwiseTradeRecoincilliationScalarFieldEnum]


  export const CoinwisePositionRecoincilliationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type CoinwisePositionRecoincilliationScalarFieldEnum = (typeof CoinwisePositionRecoincilliationScalarFieldEnum)[keyof typeof CoinwisePositionRecoincilliationScalarFieldEnum]


  export const InvoicesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type InvoicesScalarFieldEnum = (typeof InvoicesScalarFieldEnum)[keyof typeof InvoicesScalarFieldEnum]


  export const ReportsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ReportsScalarFieldEnum = (typeof ReportsScalarFieldEnum)[keyof typeof ReportsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'UserAccountType'
   */
  export type EnumUserAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserAccountType'>
    


  /**
   * Reference to a field of type 'UserAccountType[]'
   */
  export type ListEnumUserAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserAccountType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'SignUpType'
   */
  export type EnumSignUpTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SignUpType'>
    


  /**
   * Reference to a field of type 'SignUpType[]'
   */
  export type ListEnumSignUpTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SignUpType[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserKycStatus'
   */
  export type EnumUserKycStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserKycStatus'>
    


  /**
   * Reference to a field of type 'UserKycStatus[]'
   */
  export type ListEnumUserKycStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserKycStatus[]'>
    


  /**
   * Reference to a field of type 'BankVerificationStatus'
   */
  export type EnumBankVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankVerificationStatus'>
    


  /**
   * Reference to a field of type 'BankVerificationStatus[]'
   */
  export type ListEnumBankVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankVerificationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TwoFAStatus'
   */
  export type EnumTwoFAStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TwoFAStatus'>
    


  /**
   * Reference to a field of type 'TwoFAStatus[]'
   */
  export type ListEnumTwoFAStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TwoFAStatus[]'>
    


  /**
   * Reference to a field of type 'Reason'
   */
  export type EnumReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Reason'>
    


  /**
   * Reference to a field of type 'Reason[]'
   */
  export type ListEnumReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Reason[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'KycType'
   */
  export type EnumKycTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KycType'>
    


  /**
   * Reference to a field of type 'KycType[]'
   */
  export type ListEnumKycTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KycType[]'>
    


  /**
   * Reference to a field of type 'HypervergeStatus'
   */
  export type EnumHypervergeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HypervergeStatus'>
    


  /**
   * Reference to a field of type 'HypervergeStatus[]'
   */
  export type ListEnumHypervergeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HypervergeStatus[]'>
    


  /**
   * Reference to a field of type 'BankDetailsType'
   */
  export type EnumBankDetailsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankDetailsType'>
    


  /**
   * Reference to a field of type 'BankDetailsType[]'
   */
  export type ListEnumBankDetailsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankDetailsType[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'InrCreditStatus'
   */
  export type EnumInrCreditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InrCreditStatus'>
    


  /**
   * Reference to a field of type 'InrCreditStatus[]'
   */
  export type ListEnumInrCreditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InrCreditStatus[]'>
    


  /**
   * Reference to a field of type 'ProcessStatus'
   */
  export type EnumProcessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessStatus'>
    


  /**
   * Reference to a field of type 'ProcessStatus[]'
   */
  export type ListEnumProcessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessStatus[]'>
    


  /**
   * Reference to a field of type 'InrOperation'
   */
  export type EnumInrOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InrOperation'>
    


  /**
   * Reference to a field of type 'InrOperation[]'
   */
  export type ListEnumInrOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InrOperation[]'>
    


  /**
   * Reference to a field of type 'CryptoOperation'
   */
  export type EnumCryptoOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CryptoOperation'>
    


  /**
   * Reference to a field of type 'CryptoOperation[]'
   */
  export type ListEnumCryptoOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CryptoOperation[]'>
    


  /**
   * Reference to a field of type 'PositionType'
   */
  export type EnumPositionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PositionType'>
    


  /**
   * Reference to a field of type 'PositionType[]'
   */
  export type ListEnumPositionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PositionType[]'>
    


  /**
   * Reference to a field of type 'TradeOperation'
   */
  export type EnumTradeOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeOperation'>
    


  /**
   * Reference to a field of type 'TradeOperation[]'
   */
  export type ListEnumTradeOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeOperation[]'>
    


  /**
   * Reference to a field of type 'ParameterGroup'
   */
  export type EnumParameterGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParameterGroup'>
    


  /**
   * Reference to a field of type 'ParameterGroup[]'
   */
  export type ListEnumParameterGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParameterGroup[]'>
    


  /**
   * Reference to a field of type 'ParamType'
   */
  export type EnumParamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParamType'>
    


  /**
   * Reference to a field of type 'ParamType[]'
   */
  export type ListEnumParamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParamType[]'>
    


  /**
   * Reference to a field of type 'ParentWalletType'
   */
  export type EnumParentWalletTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParentWalletType'>
    


  /**
   * Reference to a field of type 'ParentWalletType[]'
   */
  export type ListEnumParentWalletTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParentWalletType[]'>
    


  /**
   * Reference to a field of type 'Interval'
   */
  export type EnumIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Interval'>
    


  /**
   * Reference to a field of type 'Interval[]'
   */
  export type ListEnumIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Interval[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type UserAccountWhereInput = {
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    id?: IntFilter<"UserAccount"> | number
    userId?: IntFilter<"UserAccount"> | number
    parentAccount?: IntNullableFilter<"UserAccount"> | number | null
    accountType?: EnumUserAccountTypeFilter<"UserAccount"> | $Enums.UserAccountType
    isActive?: BoolFilter<"UserAccount"> | boolean
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    createdBy?: IntNullableFilter<"UserAccount"> | number | null
    updatedAt?: DateTimeFilter<"UserAccount"> | Date | string
    updatedBy?: IntNullableFilter<"UserAccount"> | number | null
    UserRel?: XOR<UserRelationFilter, UserWhereInput>
    InrLedgerRel?: InrLedgerListRelationFilter
    CryptoLedgerRel?: CryptoLedgerListRelationFilter
    TradeLedgerRel?: TradeLedgerListRelationFilter
    InrWalletRel?: XOR<InrWalletNullableRelationFilter, InrWalletWhereInput> | null
    CryptoWalletRel?: CryptoWalletListRelationFilter
    InrConvRel?: InrConversionHistoryListRelationFilter
  }

  export type UserAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    parentAccount?: SortOrderInput | SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    UserRel?: UserOrderByWithRelationInput
    InrLedgerRel?: InrLedgerOrderByRelationAggregateInput
    CryptoLedgerRel?: CryptoLedgerOrderByRelationAggregateInput
    TradeLedgerRel?: TradeLedgerOrderByRelationAggregateInput
    InrWalletRel?: InrWalletOrderByWithRelationInput
    CryptoWalletRel?: CryptoWalletOrderByRelationAggregateInput
    InrConvRel?: InrConversionHistoryOrderByRelationAggregateInput
  }

  export type UserAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    parentAccount?: IntNullableFilter<"UserAccount"> | number | null
    accountType?: EnumUserAccountTypeFilter<"UserAccount"> | $Enums.UserAccountType
    isActive?: BoolFilter<"UserAccount"> | boolean
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    createdBy?: IntNullableFilter<"UserAccount"> | number | null
    updatedAt?: DateTimeFilter<"UserAccount"> | Date | string
    updatedBy?: IntNullableFilter<"UserAccount"> | number | null
    UserRel?: XOR<UserRelationFilter, UserWhereInput>
    InrLedgerRel?: InrLedgerListRelationFilter
    CryptoLedgerRel?: CryptoLedgerListRelationFilter
    TradeLedgerRel?: TradeLedgerListRelationFilter
    InrWalletRel?: XOR<InrWalletNullableRelationFilter, InrWalletWhereInput> | null
    CryptoWalletRel?: CryptoWalletListRelationFilter
    InrConvRel?: InrConversionHistoryListRelationFilter
  }, "id" | "id" | "userId">

  export type UserAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    parentAccount?: SortOrderInput | SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: UserAccountCountOrderByAggregateInput
    _avg?: UserAccountAvgOrderByAggregateInput
    _max?: UserAccountMaxOrderByAggregateInput
    _min?: UserAccountMinOrderByAggregateInput
    _sum?: UserAccountSumOrderByAggregateInput
  }

  export type UserAccountScalarWhereWithAggregatesInput = {
    AND?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    OR?: UserAccountScalarWhereWithAggregatesInput[]
    NOT?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAccount"> | number
    userId?: IntWithAggregatesFilter<"UserAccount"> | number
    parentAccount?: IntNullableWithAggregatesFilter<"UserAccount"> | number | null
    accountType?: EnumUserAccountTypeWithAggregatesFilter<"UserAccount"> | $Enums.UserAccountType
    isActive?: BoolWithAggregatesFilter<"UserAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserAccount"> | Date | string
    createdBy?: IntNullableWithAggregatesFilter<"UserAccount"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"UserAccount"> | Date | string
    updatedBy?: IntNullableWithAggregatesFilter<"UserAccount"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    signupType?: EnumSignUpTypeNullableFilter<"User"> | $Enums.SignUpType | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phoneCountryCode?: StringFilter<"User"> | string
    initVector?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    passwordUpdatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    kycStatus?: EnumUserKycStatusFilter<"User"> | $Enums.UserKycStatus
    kycId?: IntNullableFilter<"User"> | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFilter<"User"> | $Enums.BankVerificationStatus
    bankDetailsId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    inrDepositEnabled?: BoolFilter<"User"> | boolean
    cryptoDepositEnabled?: BoolFilter<"User"> | boolean
    inrWithdrawEnabled?: BoolFilter<"User"> | boolean
    cryptoWithdrawEnabled?: BoolFilter<"User"> | boolean
    tradeEnabled?: BoolFilter<"User"> | boolean
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: IntNullableFilter<"User"> | number | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    updatedBy?: IntNullableFilter<"User"> | number | null
    UserKycRel?: XOR<UserKycNullableRelationFilter, UserKycWhereInput> | null
    BankDetailRel?: XOR<UserBankDetailsNullableRelationFilter, UserBankDetailsWhereInput> | null
    UserBankDetailsRel?: UserBankDetailsListRelationFilter
    FiatPaymentsRel?: FiatPaymentsListRelationFilter
    UserAccountRel?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
    TwoFARel?: TwoFAListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userType?: SortOrder
    signupType?: SortOrderInput | SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phoneCountryCode?: SortOrder
    initVector?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    passwordUpdatedAt?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    kycId?: SortOrderInput | SortOrder
    bankVerificationStatus?: SortOrder
    bankDetailsId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    inrDepositEnabled?: SortOrder
    cryptoDepositEnabled?: SortOrder
    inrWithdrawEnabled?: SortOrder
    cryptoWithdrawEnabled?: SortOrder
    tradeEnabled?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    UserKycRel?: UserKycOrderByWithRelationInput
    BankDetailRel?: UserBankDetailsOrderByWithRelationInput
    UserBankDetailsRel?: UserBankDetailsOrderByRelationAggregateInput
    FiatPaymentsRel?: FiatPaymentsOrderByRelationAggregateInput
    UserAccountRel?: UserAccountOrderByWithRelationInput
    TwoFARel?: TwoFAOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phone?: string
    kycId?: number
    bankDetailsId?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    signupType?: EnumSignUpTypeNullableFilter<"User"> | $Enums.SignUpType | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phoneCountryCode?: StringFilter<"User"> | string
    initVector?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    passwordUpdatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    kycStatus?: EnumUserKycStatusFilter<"User"> | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFilter<"User"> | $Enums.BankVerificationStatus
    isActive?: BoolFilter<"User"> | boolean
    inrDepositEnabled?: BoolFilter<"User"> | boolean
    cryptoDepositEnabled?: BoolFilter<"User"> | boolean
    inrWithdrawEnabled?: BoolFilter<"User"> | boolean
    cryptoWithdrawEnabled?: BoolFilter<"User"> | boolean
    tradeEnabled?: BoolFilter<"User"> | boolean
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: IntNullableFilter<"User"> | number | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    updatedBy?: IntNullableFilter<"User"> | number | null
    UserKycRel?: XOR<UserKycNullableRelationFilter, UserKycWhereInput> | null
    BankDetailRel?: XOR<UserBankDetailsNullableRelationFilter, UserBankDetailsWhereInput> | null
    UserBankDetailsRel?: UserBankDetailsListRelationFilter
    FiatPaymentsRel?: FiatPaymentsListRelationFilter
    UserAccountRel?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
    TwoFARel?: TwoFAListRelationFilter
  }, "id" | "id" | "email" | "phone" | "kycId" | "bankDetailsId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userType?: SortOrder
    signupType?: SortOrderInput | SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phoneCountryCode?: SortOrder
    initVector?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    passwordUpdatedAt?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    kycId?: SortOrderInput | SortOrder
    bankVerificationStatus?: SortOrder
    bankDetailsId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    inrDepositEnabled?: SortOrder
    cryptoDepositEnabled?: SortOrder
    inrWithdrawEnabled?: SortOrder
    cryptoWithdrawEnabled?: SortOrder
    tradeEnabled?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    userType?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    signupType?: EnumSignUpTypeNullableWithAggregatesFilter<"User"> | $Enums.SignUpType | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneCountryCode?: StringWithAggregatesFilter<"User"> | string
    initVector?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordUpdatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    kycStatus?: EnumUserKycStatusWithAggregatesFilter<"User"> | $Enums.UserKycStatus
    kycId?: IntNullableWithAggregatesFilter<"User"> | number | null
    bankVerificationStatus?: EnumBankVerificationStatusWithAggregatesFilter<"User"> | $Enums.BankVerificationStatus
    bankDetailsId?: IntNullableWithAggregatesFilter<"User"> | number | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    inrDepositEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    cryptoDepositEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    inrWithdrawEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    cryptoWithdrawEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    tradeEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdBy?: IntNullableWithAggregatesFilter<"User"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedBy?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type DepositWithdrawLimitsWhereInput = {
    AND?: DepositWithdrawLimitsWhereInput | DepositWithdrawLimitsWhereInput[]
    OR?: DepositWithdrawLimitsWhereInput[]
    NOT?: DepositWithdrawLimitsWhereInput | DepositWithdrawLimitsWhereInput[]
    id?: IntFilter<"DepositWithdrawLimits"> | number
    userType?: EnumUserTypeFilter<"DepositWithdrawLimits"> | $Enums.UserType
    fiatDepositLimit?: FloatFilter<"DepositWithdrawLimits"> | number
    fiatWithdrawLimit?: FloatFilter<"DepositWithdrawLimits"> | number
    cryptoDepositLimit?: FloatNullableFilter<"DepositWithdrawLimits"> | number | null
    cryptoWithdrawLimit?: FloatNullableFilter<"DepositWithdrawLimits"> | number | null
    createdAt?: DateTimeFilter<"DepositWithdrawLimits"> | Date | string
    createdBy?: IntFilter<"DepositWithdrawLimits"> | number
    updatedAt?: DateTimeFilter<"DepositWithdrawLimits"> | Date | string
    updatedBy?: IntNullableFilter<"DepositWithdrawLimits"> | number | null
  }

  export type DepositWithdrawLimitsOrderByWithRelationInput = {
    id?: SortOrder
    userType?: SortOrder
    fiatDepositLimit?: SortOrder
    fiatWithdrawLimit?: SortOrder
    cryptoDepositLimit?: SortOrderInput | SortOrder
    cryptoWithdrawLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type DepositWithdrawLimitsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepositWithdrawLimitsWhereInput | DepositWithdrawLimitsWhereInput[]
    OR?: DepositWithdrawLimitsWhereInput[]
    NOT?: DepositWithdrawLimitsWhereInput | DepositWithdrawLimitsWhereInput[]
    userType?: EnumUserTypeFilter<"DepositWithdrawLimits"> | $Enums.UserType
    fiatDepositLimit?: FloatFilter<"DepositWithdrawLimits"> | number
    fiatWithdrawLimit?: FloatFilter<"DepositWithdrawLimits"> | number
    cryptoDepositLimit?: FloatNullableFilter<"DepositWithdrawLimits"> | number | null
    cryptoWithdrawLimit?: FloatNullableFilter<"DepositWithdrawLimits"> | number | null
    createdAt?: DateTimeFilter<"DepositWithdrawLimits"> | Date | string
    createdBy?: IntFilter<"DepositWithdrawLimits"> | number
    updatedAt?: DateTimeFilter<"DepositWithdrawLimits"> | Date | string
    updatedBy?: IntNullableFilter<"DepositWithdrawLimits"> | number | null
  }, "id" | "id">

  export type DepositWithdrawLimitsOrderByWithAggregationInput = {
    id?: SortOrder
    userType?: SortOrder
    fiatDepositLimit?: SortOrder
    fiatWithdrawLimit?: SortOrder
    cryptoDepositLimit?: SortOrderInput | SortOrder
    cryptoWithdrawLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: DepositWithdrawLimitsCountOrderByAggregateInput
    _avg?: DepositWithdrawLimitsAvgOrderByAggregateInput
    _max?: DepositWithdrawLimitsMaxOrderByAggregateInput
    _min?: DepositWithdrawLimitsMinOrderByAggregateInput
    _sum?: DepositWithdrawLimitsSumOrderByAggregateInput
  }

  export type DepositWithdrawLimitsScalarWhereWithAggregatesInput = {
    AND?: DepositWithdrawLimitsScalarWhereWithAggregatesInput | DepositWithdrawLimitsScalarWhereWithAggregatesInput[]
    OR?: DepositWithdrawLimitsScalarWhereWithAggregatesInput[]
    NOT?: DepositWithdrawLimitsScalarWhereWithAggregatesInput | DepositWithdrawLimitsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DepositWithdrawLimits"> | number
    userType?: EnumUserTypeWithAggregatesFilter<"DepositWithdrawLimits"> | $Enums.UserType
    fiatDepositLimit?: FloatWithAggregatesFilter<"DepositWithdrawLimits"> | number
    fiatWithdrawLimit?: FloatWithAggregatesFilter<"DepositWithdrawLimits"> | number
    cryptoDepositLimit?: FloatNullableWithAggregatesFilter<"DepositWithdrawLimits"> | number | null
    cryptoWithdrawLimit?: FloatNullableWithAggregatesFilter<"DepositWithdrawLimits"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DepositWithdrawLimits"> | Date | string
    createdBy?: IntWithAggregatesFilter<"DepositWithdrawLimits"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"DepositWithdrawLimits"> | Date | string
    updatedBy?: IntNullableWithAggregatesFilter<"DepositWithdrawLimits"> | number | null
  }

  export type TwoFAWhereInput = {
    AND?: TwoFAWhereInput | TwoFAWhereInput[]
    OR?: TwoFAWhereInput[]
    NOT?: TwoFAWhereInput | TwoFAWhereInput[]
    id?: IntFilter<"TwoFA"> | number
    userId?: IntFilter<"TwoFA"> | number
    email?: StringFilter<"TwoFA"> | string
    phone?: StringNullableFilter<"TwoFA"> | string | null
    emailVerified?: DateTimeNullableFilter<"TwoFA"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"TwoFA"> | Date | string | null
    status?: EnumTwoFAStatusFilter<"TwoFA"> | $Enums.TwoFAStatus
    reason?: EnumReasonFilter<"TwoFA"> | $Enums.Reason
    expiryTime?: IntFilter<"TwoFA"> | number
    mobileVerifiedAtleastOnce?: BoolFilter<"TwoFA"> | boolean
    createdAt?: DateTimeFilter<"TwoFA"> | Date | string
    createdBy?: IntFilter<"TwoFA"> | number
    updatedAt?: DateTimeFilter<"TwoFA"> | Date | string
    updatedBy?: IntNullableFilter<"TwoFA"> | number | null
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TwoFAOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    status?: SortOrder
    reason?: SortOrder
    expiryTime?: SortOrder
    mobileVerifiedAtleastOnce?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type TwoFAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TwoFAWhereInput | TwoFAWhereInput[]
    OR?: TwoFAWhereInput[]
    NOT?: TwoFAWhereInput | TwoFAWhereInput[]
    userId?: IntFilter<"TwoFA"> | number
    email?: StringFilter<"TwoFA"> | string
    phone?: StringNullableFilter<"TwoFA"> | string | null
    emailVerified?: DateTimeNullableFilter<"TwoFA"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"TwoFA"> | Date | string | null
    status?: EnumTwoFAStatusFilter<"TwoFA"> | $Enums.TwoFAStatus
    reason?: EnumReasonFilter<"TwoFA"> | $Enums.Reason
    expiryTime?: IntFilter<"TwoFA"> | number
    mobileVerifiedAtleastOnce?: BoolFilter<"TwoFA"> | boolean
    createdAt?: DateTimeFilter<"TwoFA"> | Date | string
    createdBy?: IntFilter<"TwoFA"> | number
    updatedAt?: DateTimeFilter<"TwoFA"> | Date | string
    updatedBy?: IntNullableFilter<"TwoFA"> | number | null
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type TwoFAOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    status?: SortOrder
    reason?: SortOrder
    expiryTime?: SortOrder
    mobileVerifiedAtleastOnce?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: TwoFACountOrderByAggregateInput
    _avg?: TwoFAAvgOrderByAggregateInput
    _max?: TwoFAMaxOrderByAggregateInput
    _min?: TwoFAMinOrderByAggregateInput
    _sum?: TwoFASumOrderByAggregateInput
  }

  export type TwoFAScalarWhereWithAggregatesInput = {
    AND?: TwoFAScalarWhereWithAggregatesInput | TwoFAScalarWhereWithAggregatesInput[]
    OR?: TwoFAScalarWhereWithAggregatesInput[]
    NOT?: TwoFAScalarWhereWithAggregatesInput | TwoFAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TwoFA"> | number
    userId?: IntWithAggregatesFilter<"TwoFA"> | number
    email?: StringWithAggregatesFilter<"TwoFA"> | string
    phone?: StringNullableWithAggregatesFilter<"TwoFA"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"TwoFA"> | Date | string | null
    phoneVerified?: DateTimeNullableWithAggregatesFilter<"TwoFA"> | Date | string | null
    status?: EnumTwoFAStatusWithAggregatesFilter<"TwoFA"> | $Enums.TwoFAStatus
    reason?: EnumReasonWithAggregatesFilter<"TwoFA"> | $Enums.Reason
    expiryTime?: IntWithAggregatesFilter<"TwoFA"> | number
    mobileVerifiedAtleastOnce?: BoolWithAggregatesFilter<"TwoFA"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TwoFA"> | Date | string
    createdBy?: IntWithAggregatesFilter<"TwoFA"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"TwoFA"> | Date | string
    updatedBy?: IntNullableWithAggregatesFilter<"TwoFA"> | number | null
  }

  export type UserKycWhereInput = {
    AND?: UserKycWhereInput | UserKycWhereInput[]
    OR?: UserKycWhereInput[]
    NOT?: UserKycWhereInput | UserKycWhereInput[]
    id?: IntFilter<"UserKyc"> | number
    encryptedUserDataId?: IntNullableFilter<"UserKyc"> | number | null
    fullName?: StringNullableFilter<"UserKyc"> | string | null
    gender?: EnumGenderNullableFilter<"UserKyc"> | $Enums.Gender | null
    dob?: StringNullableFilter<"UserKyc"> | string | null
    address?: StringNullableFilter<"UserKyc"> | string | null
    fatherName?: StringNullableFilter<"UserKyc"> | string | null
    kycType?: EnumKycTypeFilter<"UserKyc"> | $Enums.KycType
    kycStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    hyperVergeStatus?: EnumHypervergeStatusNullableFilter<"UserKyc"> | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    createdAt?: DateTimeFilter<"UserKyc"> | Date | string
    createdBy?: IntFilter<"UserKyc"> | number
    updatedAt?: DateTimeFilter<"UserKyc"> | Date | string
    updatedBy?: IntNullableFilter<"UserKyc"> | number | null
    EncryptedUserDataRel?: XOR<EncryptedUserDataNullableRelationFilter, EncryptedUserDataWhereInput> | null
    UserRel?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type UserKycOrderByWithRelationInput = {
    id?: SortOrder
    encryptedUserDataId?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    fatherName?: SortOrderInput | SortOrder
    kycType?: SortOrder
    kycStatus?: SortOrder
    hyperVergeStatus?: SortOrderInput | SortOrder
    panStatus?: SortOrder
    aadharFrontStatus?: SortOrder
    aadharBackStatus?: SortOrder
    selfieStatus?: SortOrder
    aadharPanNameMatchStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    EncryptedUserDataRel?: EncryptedUserDataOrderByWithRelationInput
    UserRel?: UserOrderByWithRelationInput
  }

  export type UserKycWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    encryptedUserDataId?: number
    AND?: UserKycWhereInput | UserKycWhereInput[]
    OR?: UserKycWhereInput[]
    NOT?: UserKycWhereInput | UserKycWhereInput[]
    fullName?: StringNullableFilter<"UserKyc"> | string | null
    gender?: EnumGenderNullableFilter<"UserKyc"> | $Enums.Gender | null
    dob?: StringNullableFilter<"UserKyc"> | string | null
    address?: StringNullableFilter<"UserKyc"> | string | null
    fatherName?: StringNullableFilter<"UserKyc"> | string | null
    kycType?: EnumKycTypeFilter<"UserKyc"> | $Enums.KycType
    kycStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    hyperVergeStatus?: EnumHypervergeStatusNullableFilter<"UserKyc"> | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFilter<"UserKyc"> | $Enums.UserKycStatus
    createdAt?: DateTimeFilter<"UserKyc"> | Date | string
    createdBy?: IntFilter<"UserKyc"> | number
    updatedAt?: DateTimeFilter<"UserKyc"> | Date | string
    updatedBy?: IntNullableFilter<"UserKyc"> | number | null
    EncryptedUserDataRel?: XOR<EncryptedUserDataNullableRelationFilter, EncryptedUserDataWhereInput> | null
    UserRel?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "id" | "encryptedUserDataId">

  export type UserKycOrderByWithAggregationInput = {
    id?: SortOrder
    encryptedUserDataId?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    fatherName?: SortOrderInput | SortOrder
    kycType?: SortOrder
    kycStatus?: SortOrder
    hyperVergeStatus?: SortOrderInput | SortOrder
    panStatus?: SortOrder
    aadharFrontStatus?: SortOrder
    aadharBackStatus?: SortOrder
    selfieStatus?: SortOrder
    aadharPanNameMatchStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: UserKycCountOrderByAggregateInput
    _avg?: UserKycAvgOrderByAggregateInput
    _max?: UserKycMaxOrderByAggregateInput
    _min?: UserKycMinOrderByAggregateInput
    _sum?: UserKycSumOrderByAggregateInput
  }

  export type UserKycScalarWhereWithAggregatesInput = {
    AND?: UserKycScalarWhereWithAggregatesInput | UserKycScalarWhereWithAggregatesInput[]
    OR?: UserKycScalarWhereWithAggregatesInput[]
    NOT?: UserKycScalarWhereWithAggregatesInput | UserKycScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserKyc"> | number
    encryptedUserDataId?: IntNullableWithAggregatesFilter<"UserKyc"> | number | null
    fullName?: StringNullableWithAggregatesFilter<"UserKyc"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"UserKyc"> | $Enums.Gender | null
    dob?: StringNullableWithAggregatesFilter<"UserKyc"> | string | null
    address?: StringNullableWithAggregatesFilter<"UserKyc"> | string | null
    fatherName?: StringNullableWithAggregatesFilter<"UserKyc"> | string | null
    kycType?: EnumKycTypeWithAggregatesFilter<"UserKyc"> | $Enums.KycType
    kycStatus?: EnumUserKycStatusWithAggregatesFilter<"UserKyc"> | $Enums.UserKycStatus
    hyperVergeStatus?: EnumHypervergeStatusNullableWithAggregatesFilter<"UserKyc"> | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusWithAggregatesFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusWithAggregatesFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusWithAggregatesFilter<"UserKyc"> | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusWithAggregatesFilter<"UserKyc"> | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusWithAggregatesFilter<"UserKyc"> | $Enums.UserKycStatus
    createdAt?: DateTimeWithAggregatesFilter<"UserKyc"> | Date | string
    createdBy?: IntWithAggregatesFilter<"UserKyc"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"UserKyc"> | Date | string
    updatedBy?: IntNullableWithAggregatesFilter<"UserKyc"> | number | null
  }

  export type EncryptedUserDataWhereInput = {
    AND?: EncryptedUserDataWhereInput | EncryptedUserDataWhereInput[]
    OR?: EncryptedUserDataWhereInput[]
    NOT?: EncryptedUserDataWhereInput | EncryptedUserDataWhereInput[]
    id?: IntFilter<"EncryptedUserData"> | number
    panNumber?: StringNullableFilter<"EncryptedUserData"> | string | null
    aadharNumber?: StringNullableFilter<"EncryptedUserData"> | string | null
    userId?: IntFilter<"EncryptedUserData"> | number
    fileKey?: StringNullableFilter<"EncryptedUserData"> | string | null
    bucketName?: StringNullableFilter<"EncryptedUserData"> | string | null
    initVector?: StringNullableFilter<"EncryptedUserData"> | string | null
    createdAt?: DateTimeFilter<"EncryptedUserData"> | Date | string
    createdBy?: IntFilter<"EncryptedUserData"> | number
    updatedAt?: DateTimeFilter<"EncryptedUserData"> | Date | string
    updatedBy?: IntNullableFilter<"EncryptedUserData"> | number | null
    UserKyc?: XOR<UserKycNullableRelationFilter, UserKycWhereInput> | null
  }

  export type EncryptedUserDataOrderByWithRelationInput = {
    id?: SortOrder
    panNumber?: SortOrderInput | SortOrder
    aadharNumber?: SortOrderInput | SortOrder
    userId?: SortOrder
    fileKey?: SortOrderInput | SortOrder
    bucketName?: SortOrderInput | SortOrder
    initVector?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    UserKyc?: UserKycOrderByWithRelationInput
  }

  export type EncryptedUserDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    panNumber?: string
    aadharNumber?: string
    AND?: EncryptedUserDataWhereInput | EncryptedUserDataWhereInput[]
    OR?: EncryptedUserDataWhereInput[]
    NOT?: EncryptedUserDataWhereInput | EncryptedUserDataWhereInput[]
    userId?: IntFilter<"EncryptedUserData"> | number
    fileKey?: StringNullableFilter<"EncryptedUserData"> | string | null
    bucketName?: StringNullableFilter<"EncryptedUserData"> | string | null
    initVector?: StringNullableFilter<"EncryptedUserData"> | string | null
    createdAt?: DateTimeFilter<"EncryptedUserData"> | Date | string
    createdBy?: IntFilter<"EncryptedUserData"> | number
    updatedAt?: DateTimeFilter<"EncryptedUserData"> | Date | string
    updatedBy?: IntNullableFilter<"EncryptedUserData"> | number | null
    UserKyc?: XOR<UserKycNullableRelationFilter, UserKycWhereInput> | null
  }, "id" | "id" | "panNumber" | "aadharNumber">

  export type EncryptedUserDataOrderByWithAggregationInput = {
    id?: SortOrder
    panNumber?: SortOrderInput | SortOrder
    aadharNumber?: SortOrderInput | SortOrder
    userId?: SortOrder
    fileKey?: SortOrderInput | SortOrder
    bucketName?: SortOrderInput | SortOrder
    initVector?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: EncryptedUserDataCountOrderByAggregateInput
    _avg?: EncryptedUserDataAvgOrderByAggregateInput
    _max?: EncryptedUserDataMaxOrderByAggregateInput
    _min?: EncryptedUserDataMinOrderByAggregateInput
    _sum?: EncryptedUserDataSumOrderByAggregateInput
  }

  export type EncryptedUserDataScalarWhereWithAggregatesInput = {
    AND?: EncryptedUserDataScalarWhereWithAggregatesInput | EncryptedUserDataScalarWhereWithAggregatesInput[]
    OR?: EncryptedUserDataScalarWhereWithAggregatesInput[]
    NOT?: EncryptedUserDataScalarWhereWithAggregatesInput | EncryptedUserDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncryptedUserData"> | number
    panNumber?: StringNullableWithAggregatesFilter<"EncryptedUserData"> | string | null
    aadharNumber?: StringNullableWithAggregatesFilter<"EncryptedUserData"> | string | null
    userId?: IntWithAggregatesFilter<"EncryptedUserData"> | number
    fileKey?: StringNullableWithAggregatesFilter<"EncryptedUserData"> | string | null
    bucketName?: StringNullableWithAggregatesFilter<"EncryptedUserData"> | string | null
    initVector?: StringNullableWithAggregatesFilter<"EncryptedUserData"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EncryptedUserData"> | Date | string
    createdBy?: IntWithAggregatesFilter<"EncryptedUserData"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"EncryptedUserData"> | Date | string
    updatedBy?: IntNullableWithAggregatesFilter<"EncryptedUserData"> | number | null
  }

  export type UserBankDetailsWhereInput = {
    AND?: UserBankDetailsWhereInput | UserBankDetailsWhereInput[]
    OR?: UserBankDetailsWhereInput[]
    NOT?: UserBankDetailsWhereInput | UserBankDetailsWhereInput[]
    id?: IntFilter<"UserBankDetails"> | number
    bankDetailsType?: EnumBankDetailsTypeFilter<"UserBankDetails"> | $Enums.BankDetailsType
    userId?: IntNullableFilter<"UserBankDetails"> | number | null
    bankAccountNumber?: StringNullableFilter<"UserBankDetails"> | string | null
    bankName?: StringNullableFilter<"UserBankDetails"> | string | null
    accountHolderName?: StringNullableFilter<"UserBankDetails"> | string | null
    ifsc?: StringNullableFilter<"UserBankDetails"> | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFilter<"UserBankDetails"> | $Enums.BankVerificationStatus
    isActive?: BoolFilter<"UserBankDetails"> | boolean
    createdAt?: DateTimeFilter<"UserBankDetails"> | Date | string
    createdBy?: IntFilter<"UserBankDetails"> | number
    updatedAt?: DateTimeFilter<"UserBankDetails"> | Date | string
    updatedBy?: IntNullableFilter<"UserBankDetails"> | number | null
    userRel?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    UserBankRel?: FiatPaymentsListRelationFilter
    FiatPaymentsRel?: FiatPaymentsListRelationFilter
    UserRel?: UserListRelationFilter
  }

  export type UserBankDetailsOrderByWithRelationInput = {
    id?: SortOrder
    bankDetailsType?: SortOrder
    userId?: SortOrderInput | SortOrder
    bankAccountNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountHolderName?: SortOrderInput | SortOrder
    ifsc?: SortOrderInput | SortOrder
    bankVerificationStatus?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    userRel?: UserOrderByWithRelationInput
    UserBankRel?: FiatPaymentsOrderByRelationAggregateInput
    FiatPaymentsRel?: FiatPaymentsOrderByRelationAggregateInput
    UserRel?: UserOrderByRelationAggregateInput
  }

  export type UserBankDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bankAccountNumber?: string
    AND?: UserBankDetailsWhereInput | UserBankDetailsWhereInput[]
    OR?: UserBankDetailsWhereInput[]
    NOT?: UserBankDetailsWhereInput | UserBankDetailsWhereInput[]
    bankDetailsType?: EnumBankDetailsTypeFilter<"UserBankDetails"> | $Enums.BankDetailsType
    userId?: IntNullableFilter<"UserBankDetails"> | number | null
    bankName?: StringNullableFilter<"UserBankDetails"> | string | null
    accountHolderName?: StringNullableFilter<"UserBankDetails"> | string | null
    ifsc?: StringNullableFilter<"UserBankDetails"> | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFilter<"UserBankDetails"> | $Enums.BankVerificationStatus
    isActive?: BoolFilter<"UserBankDetails"> | boolean
    createdAt?: DateTimeFilter<"UserBankDetails"> | Date | string
    createdBy?: IntFilter<"UserBankDetails"> | number
    updatedAt?: DateTimeFilter<"UserBankDetails"> | Date | string
    updatedBy?: IntNullableFilter<"UserBankDetails"> | number | null
    userRel?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    UserBankRel?: FiatPaymentsListRelationFilter
    FiatPaymentsRel?: FiatPaymentsListRelationFilter
    UserRel?: UserListRelationFilter
  }, "id" | "id" | "bankAccountNumber">

  export type UserBankDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    bankDetailsType?: SortOrder
    userId?: SortOrderInput | SortOrder
    bankAccountNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountHolderName?: SortOrderInput | SortOrder
    ifsc?: SortOrderInput | SortOrder
    bankVerificationStatus?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: UserBankDetailsCountOrderByAggregateInput
    _avg?: UserBankDetailsAvgOrderByAggregateInput
    _max?: UserBankDetailsMaxOrderByAggregateInput
    _min?: UserBankDetailsMinOrderByAggregateInput
    _sum?: UserBankDetailsSumOrderByAggregateInput
  }

  export type UserBankDetailsScalarWhereWithAggregatesInput = {
    AND?: UserBankDetailsScalarWhereWithAggregatesInput | UserBankDetailsScalarWhereWithAggregatesInput[]
    OR?: UserBankDetailsScalarWhereWithAggregatesInput[]
    NOT?: UserBankDetailsScalarWhereWithAggregatesInput | UserBankDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserBankDetails"> | number
    bankDetailsType?: EnumBankDetailsTypeWithAggregatesFilter<"UserBankDetails"> | $Enums.BankDetailsType
    userId?: IntNullableWithAggregatesFilter<"UserBankDetails"> | number | null
    bankAccountNumber?: StringNullableWithAggregatesFilter<"UserBankDetails"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"UserBankDetails"> | string | null
    accountHolderName?: StringNullableWithAggregatesFilter<"UserBankDetails"> | string | null
    ifsc?: StringNullableWithAggregatesFilter<"UserBankDetails"> | string | null
    bankVerificationStatus?: EnumBankVerificationStatusWithAggregatesFilter<"UserBankDetails"> | $Enums.BankVerificationStatus
    isActive?: BoolWithAggregatesFilter<"UserBankDetails"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserBankDetails"> | Date | string
    createdBy?: IntWithAggregatesFilter<"UserBankDetails"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"UserBankDetails"> | Date | string
    updatedBy?: IntNullableWithAggregatesFilter<"UserBankDetails"> | number | null
  }

  export type FiatPaymentsWhereInput = {
    AND?: FiatPaymentsWhereInput | FiatPaymentsWhereInput[]
    OR?: FiatPaymentsWhereInput[]
    NOT?: FiatPaymentsWhereInput | FiatPaymentsWhereInput[]
    id?: IntFilter<"FiatPayments"> | number
    userId?: IntFilter<"FiatPayments"> | number
    paymentType?: EnumPaymentTypeFilter<"FiatPayments"> | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFilter<"FiatPayments"> | $Enums.PaymentStatus
    systemBankId?: IntFilter<"FiatPayments"> | number
    userBankId?: IntFilter<"FiatPayments"> | number
    systemAccountNumber?: StringFilter<"FiatPayments"> | string
    userAccountNumber?: StringFilter<"FiatPayments"> | string
    amount?: FloatFilter<"FiatPayments"> | number
    fee?: FloatFilter<"FiatPayments"> | number
    amountCredited?: FloatNullableFilter<"FiatPayments"> | number | null
    amountDebited?: FloatNullableFilter<"FiatPayments"> | number | null
    bankProofUrl?: StringNullableFilter<"FiatPayments"> | string | null
    receiptNumber?: StringNullableFilter<"FiatPayments"> | string | null
    userRemarks?: StringNullableFilter<"FiatPayments"> | string | null
    adminRemarks?: StringNullableFilter<"FiatPayments"> | string | null
    createdAt?: DateTimeFilter<"FiatPayments"> | Date | string
    createdBy?: IntFilter<"FiatPayments"> | number
    updatedAt?: DateTimeFilter<"FiatPayments"> | Date | string
    updatedBy?: IntFilter<"FiatPayments"> | number
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    systemBankRel?: XOR<UserBankDetailsNullableRelationFilter, UserBankDetailsWhereInput> | null
    userBankRel?: XOR<UserBankDetailsNullableRelationFilter, UserBankDetailsWhereInput> | null
    BankFeedRel?: XOR<BankFeedNullableRelationFilter, BankFeedWhereInput> | null
  }

  export type FiatPaymentsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    systemBankId?: SortOrder
    userBankId?: SortOrder
    systemAccountNumber?: SortOrder
    userAccountNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    amountCredited?: SortOrderInput | SortOrder
    amountDebited?: SortOrderInput | SortOrder
    bankProofUrl?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    userRemarks?: SortOrderInput | SortOrder
    adminRemarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    user?: UserOrderByWithRelationInput
    systemBankRel?: UserBankDetailsOrderByWithRelationInput
    userBankRel?: UserBankDetailsOrderByWithRelationInput
    BankFeedRel?: BankFeedOrderByWithRelationInput
  }

  export type FiatPaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FiatPaymentsWhereInput | FiatPaymentsWhereInput[]
    OR?: FiatPaymentsWhereInput[]
    NOT?: FiatPaymentsWhereInput | FiatPaymentsWhereInput[]
    userId?: IntFilter<"FiatPayments"> | number
    paymentType?: EnumPaymentTypeFilter<"FiatPayments"> | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFilter<"FiatPayments"> | $Enums.PaymentStatus
    systemBankId?: IntFilter<"FiatPayments"> | number
    userBankId?: IntFilter<"FiatPayments"> | number
    systemAccountNumber?: StringFilter<"FiatPayments"> | string
    userAccountNumber?: StringFilter<"FiatPayments"> | string
    amount?: FloatFilter<"FiatPayments"> | number
    fee?: FloatFilter<"FiatPayments"> | number
    amountCredited?: FloatNullableFilter<"FiatPayments"> | number | null
    amountDebited?: FloatNullableFilter<"FiatPayments"> | number | null
    bankProofUrl?: StringNullableFilter<"FiatPayments"> | string | null
    receiptNumber?: StringNullableFilter<"FiatPayments"> | string | null
    userRemarks?: StringNullableFilter<"FiatPayments"> | string | null
    adminRemarks?: StringNullableFilter<"FiatPayments"> | string | null
    createdAt?: DateTimeFilter<"FiatPayments"> | Date | string
    createdBy?: IntFilter<"FiatPayments"> | number
    updatedAt?: DateTimeFilter<"FiatPayments"> | Date | string
    updatedBy?: IntFilter<"FiatPayments"> | number
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    systemBankRel?: XOR<UserBankDetailsNullableRelationFilter, UserBankDetailsWhereInput> | null
    userBankRel?: XOR<UserBankDetailsNullableRelationFilter, UserBankDetailsWhereInput> | null
    BankFeedRel?: XOR<BankFeedNullableRelationFilter, BankFeedWhereInput> | null
  }, "id" | "id">

  export type FiatPaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    systemBankId?: SortOrder
    userBankId?: SortOrder
    systemAccountNumber?: SortOrder
    userAccountNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    amountCredited?: SortOrderInput | SortOrder
    amountDebited?: SortOrderInput | SortOrder
    bankProofUrl?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    userRemarks?: SortOrderInput | SortOrder
    adminRemarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: FiatPaymentsCountOrderByAggregateInput
    _avg?: FiatPaymentsAvgOrderByAggregateInput
    _max?: FiatPaymentsMaxOrderByAggregateInput
    _min?: FiatPaymentsMinOrderByAggregateInput
    _sum?: FiatPaymentsSumOrderByAggregateInput
  }

  export type FiatPaymentsScalarWhereWithAggregatesInput = {
    AND?: FiatPaymentsScalarWhereWithAggregatesInput | FiatPaymentsScalarWhereWithAggregatesInput[]
    OR?: FiatPaymentsScalarWhereWithAggregatesInput[]
    NOT?: FiatPaymentsScalarWhereWithAggregatesInput | FiatPaymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FiatPayments"> | number
    userId?: IntWithAggregatesFilter<"FiatPayments"> | number
    paymentType?: EnumPaymentTypeWithAggregatesFilter<"FiatPayments"> | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"FiatPayments"> | $Enums.PaymentStatus
    systemBankId?: IntWithAggregatesFilter<"FiatPayments"> | number
    userBankId?: IntWithAggregatesFilter<"FiatPayments"> | number
    systemAccountNumber?: StringWithAggregatesFilter<"FiatPayments"> | string
    userAccountNumber?: StringWithAggregatesFilter<"FiatPayments"> | string
    amount?: FloatWithAggregatesFilter<"FiatPayments"> | number
    fee?: FloatWithAggregatesFilter<"FiatPayments"> | number
    amountCredited?: FloatNullableWithAggregatesFilter<"FiatPayments"> | number | null
    amountDebited?: FloatNullableWithAggregatesFilter<"FiatPayments"> | number | null
    bankProofUrl?: StringNullableWithAggregatesFilter<"FiatPayments"> | string | null
    receiptNumber?: StringNullableWithAggregatesFilter<"FiatPayments"> | string | null
    userRemarks?: StringNullableWithAggregatesFilter<"FiatPayments"> | string | null
    adminRemarks?: StringNullableWithAggregatesFilter<"FiatPayments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FiatPayments"> | Date | string
    createdBy?: IntWithAggregatesFilter<"FiatPayments"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"FiatPayments"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"FiatPayments"> | number
  }

  export type CryptoDepositWhereInput = {
    AND?: CryptoDepositWhereInput | CryptoDepositWhereInput[]
    OR?: CryptoDepositWhereInput[]
    NOT?: CryptoDepositWhereInput | CryptoDepositWhereInput[]
    id?: IntFilter<"CryptoDeposit"> | number
    accountId?: IntFilter<"CryptoDeposit"> | number
    cryptoWalletId?: IntFilter<"CryptoDeposit"> | number
    liminalTxnRefId?: StringFilter<"CryptoDeposit"> | string
    coin?: StringFilter<"CryptoDeposit"> | string
    walletId?: IntFilter<"CryptoDeposit"> | number
    timestamp?: StringFilter<"CryptoDeposit"> | string
    fee?: StringNullableFilter<"CryptoDeposit"> | string | null
    effectiveChange?: StringNullableFilter<"CryptoDeposit"> | string | null
    runningBalance?: StringNullableFilter<"CryptoDeposit"> | string | null
    externalAddress?: StringNullableFilter<"CryptoDeposit"> | string | null
    effectiveChangeUsd?: StringNullableFilter<"CryptoDeposit"> | string | null
    wallet?: JsonNullableFilter<"CryptoDeposit">
    tokenContractAddress?: StringNullableFilter<"CryptoDeposit"> | string | null
    explorerLink?: StringNullableFilter<"CryptoDeposit"> | string | null
    inputs?: JsonNullableListFilter<"CryptoDeposit">
    outputs?: JsonNullableListFilter<"CryptoDeposit">
    sequenceId?: StringNullableFilter<"CryptoDeposit"> | string | null
    type?: StringNullableFilter<"CryptoDeposit"> | string | null
    conversionRate?: StringNullableFilter<"CryptoDeposit"> | string | null
    isConverted?: BoolNullableFilter<"CryptoDeposit"> | boolean | null
    conversionTimestamp?: DateTimeNullableFilter<"CryptoDeposit"> | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFilter<"CryptoDeposit"> | $Enums.InrCreditStatus
    createdAt?: DateTimeFilter<"CryptoDeposit"> | Date | string
    createdBy?: IntFilter<"CryptoDeposit"> | number
    updatedAt?: DateTimeFilter<"CryptoDeposit"> | Date | string
    updatedBy?: IntFilter<"CryptoDeposit"> | number
    cryptoWallet?: XOR<CryptoWalletNullableRelationFilter, CryptoWalletWhereInput> | null
    inrConvHistRel?: InrConversionHistoryListRelationFilter
  }

  export type CryptoDepositOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    cryptoWalletId?: SortOrder
    liminalTxnRefId?: SortOrder
    coin?: SortOrder
    walletId?: SortOrder
    timestamp?: SortOrder
    fee?: SortOrderInput | SortOrder
    effectiveChange?: SortOrderInput | SortOrder
    runningBalance?: SortOrderInput | SortOrder
    externalAddress?: SortOrderInput | SortOrder
    effectiveChangeUsd?: SortOrderInput | SortOrder
    wallet?: SortOrderInput | SortOrder
    tokenContractAddress?: SortOrderInput | SortOrder
    explorerLink?: SortOrderInput | SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    sequenceId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    conversionRate?: SortOrderInput | SortOrder
    isConverted?: SortOrderInput | SortOrder
    conversionTimestamp?: SortOrderInput | SortOrder
    inrCreditStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    cryptoWallet?: CryptoWalletOrderByWithRelationInput
    inrConvHistRel?: InrConversionHistoryOrderByRelationAggregateInput
  }

  export type CryptoDepositWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    liminalTxnRefId?: string
    AND?: CryptoDepositWhereInput | CryptoDepositWhereInput[]
    OR?: CryptoDepositWhereInput[]
    NOT?: CryptoDepositWhereInput | CryptoDepositWhereInput[]
    accountId?: IntFilter<"CryptoDeposit"> | number
    cryptoWalletId?: IntFilter<"CryptoDeposit"> | number
    coin?: StringFilter<"CryptoDeposit"> | string
    walletId?: IntFilter<"CryptoDeposit"> | number
    timestamp?: StringFilter<"CryptoDeposit"> | string
    fee?: StringNullableFilter<"CryptoDeposit"> | string | null
    effectiveChange?: StringNullableFilter<"CryptoDeposit"> | string | null
    runningBalance?: StringNullableFilter<"CryptoDeposit"> | string | null
    externalAddress?: StringNullableFilter<"CryptoDeposit"> | string | null
    effectiveChangeUsd?: StringNullableFilter<"CryptoDeposit"> | string | null
    wallet?: JsonNullableFilter<"CryptoDeposit">
    tokenContractAddress?: StringNullableFilter<"CryptoDeposit"> | string | null
    explorerLink?: StringNullableFilter<"CryptoDeposit"> | string | null
    inputs?: JsonNullableListFilter<"CryptoDeposit">
    outputs?: JsonNullableListFilter<"CryptoDeposit">
    sequenceId?: StringNullableFilter<"CryptoDeposit"> | string | null
    type?: StringNullableFilter<"CryptoDeposit"> | string | null
    conversionRate?: StringNullableFilter<"CryptoDeposit"> | string | null
    isConverted?: BoolNullableFilter<"CryptoDeposit"> | boolean | null
    conversionTimestamp?: DateTimeNullableFilter<"CryptoDeposit"> | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFilter<"CryptoDeposit"> | $Enums.InrCreditStatus
    createdAt?: DateTimeFilter<"CryptoDeposit"> | Date | string
    createdBy?: IntFilter<"CryptoDeposit"> | number
    updatedAt?: DateTimeFilter<"CryptoDeposit"> | Date | string
    updatedBy?: IntFilter<"CryptoDeposit"> | number
    cryptoWallet?: XOR<CryptoWalletNullableRelationFilter, CryptoWalletWhereInput> | null
    inrConvHistRel?: InrConversionHistoryListRelationFilter
  }, "id" | "id" | "liminalTxnRefId">

  export type CryptoDepositOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    cryptoWalletId?: SortOrder
    liminalTxnRefId?: SortOrder
    coin?: SortOrder
    walletId?: SortOrder
    timestamp?: SortOrder
    fee?: SortOrderInput | SortOrder
    effectiveChange?: SortOrderInput | SortOrder
    runningBalance?: SortOrderInput | SortOrder
    externalAddress?: SortOrderInput | SortOrder
    effectiveChangeUsd?: SortOrderInput | SortOrder
    wallet?: SortOrderInput | SortOrder
    tokenContractAddress?: SortOrderInput | SortOrder
    explorerLink?: SortOrderInput | SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    sequenceId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    conversionRate?: SortOrderInput | SortOrder
    isConverted?: SortOrderInput | SortOrder
    conversionTimestamp?: SortOrderInput | SortOrder
    inrCreditStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: CryptoDepositCountOrderByAggregateInput
    _avg?: CryptoDepositAvgOrderByAggregateInput
    _max?: CryptoDepositMaxOrderByAggregateInput
    _min?: CryptoDepositMinOrderByAggregateInput
    _sum?: CryptoDepositSumOrderByAggregateInput
  }

  export type CryptoDepositScalarWhereWithAggregatesInput = {
    AND?: CryptoDepositScalarWhereWithAggregatesInput | CryptoDepositScalarWhereWithAggregatesInput[]
    OR?: CryptoDepositScalarWhereWithAggregatesInput[]
    NOT?: CryptoDepositScalarWhereWithAggregatesInput | CryptoDepositScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CryptoDeposit"> | number
    accountId?: IntWithAggregatesFilter<"CryptoDeposit"> | number
    cryptoWalletId?: IntWithAggregatesFilter<"CryptoDeposit"> | number
    liminalTxnRefId?: StringWithAggregatesFilter<"CryptoDeposit"> | string
    coin?: StringWithAggregatesFilter<"CryptoDeposit"> | string
    walletId?: IntWithAggregatesFilter<"CryptoDeposit"> | number
    timestamp?: StringWithAggregatesFilter<"CryptoDeposit"> | string
    fee?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    effectiveChange?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    runningBalance?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    externalAddress?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    effectiveChangeUsd?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    wallet?: JsonNullableWithAggregatesFilter<"CryptoDeposit">
    tokenContractAddress?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    explorerLink?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    inputs?: JsonNullableListFilter<"CryptoDeposit">
    outputs?: JsonNullableListFilter<"CryptoDeposit">
    sequenceId?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    type?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    conversionRate?: StringNullableWithAggregatesFilter<"CryptoDeposit"> | string | null
    isConverted?: BoolNullableWithAggregatesFilter<"CryptoDeposit"> | boolean | null
    conversionTimestamp?: DateTimeNullableWithAggregatesFilter<"CryptoDeposit"> | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusWithAggregatesFilter<"CryptoDeposit"> | $Enums.InrCreditStatus
    createdAt?: DateTimeWithAggregatesFilter<"CryptoDeposit"> | Date | string
    createdBy?: IntWithAggregatesFilter<"CryptoDeposit"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoDeposit"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"CryptoDeposit"> | number
  }

  export type InrConversionHistoryWhereInput = {
    AND?: InrConversionHistoryWhereInput | InrConversionHistoryWhereInput[]
    OR?: InrConversionHistoryWhereInput[]
    NOT?: InrConversionHistoryWhereInput | InrConversionHistoryWhereInput[]
    id?: IntFilter<"InrConversionHistory"> | number
    cryptoDepositId?: IntNullableFilter<"InrConversionHistory"> | number | null
    accountId?: IntFilter<"InrConversionHistory"> | number
    baseToken?: StringFilter<"InrConversionHistory"> | string
    baseTokenQuantity?: FloatFilter<"InrConversionHistory"> | number
    inrValue?: FloatFilter<"InrConversionHistory"> | number
    inrValAfterDeduction?: FloatFilter<"InrConversionHistory"> | number
    gst?: FloatNullableFilter<"InrConversionHistory"> | number | null
    txnFee?: FloatNullableFilter<"InrConversionHistory"> | number | null
    tds?: FloatNullableFilter<"InrConversionHistory"> | number | null
    coinConversionRate?: FloatNullableFilter<"InrConversionHistory"> | number | null
    receivingAddress?: StringNullableFilter<"InrConversionHistory"> | string | null
    createdAt?: DateTimeFilter<"InrConversionHistory"> | Date | string
    createdBy?: IntFilter<"InrConversionHistory"> | number
    updatedAt?: DateTimeFilter<"InrConversionHistory"> | Date | string
    updatedBy?: IntFilter<"InrConversionHistory"> | number
    cryptoDeposit?: XOR<CryptoDepositNullableRelationFilter, CryptoDepositWhereInput> | null
    account?: XOR<UserAccountRelationFilter, UserAccountWhereInput>
  }

  export type InrConversionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    cryptoDepositId?: SortOrderInput | SortOrder
    accountId?: SortOrder
    baseToken?: SortOrder
    baseTokenQuantity?: SortOrder
    inrValue?: SortOrder
    inrValAfterDeduction?: SortOrder
    gst?: SortOrderInput | SortOrder
    txnFee?: SortOrderInput | SortOrder
    tds?: SortOrderInput | SortOrder
    coinConversionRate?: SortOrderInput | SortOrder
    receivingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    cryptoDeposit?: CryptoDepositOrderByWithRelationInput
    account?: UserAccountOrderByWithRelationInput
  }

  export type InrConversionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cryptoDepositId?: number
    AND?: InrConversionHistoryWhereInput | InrConversionHistoryWhereInput[]
    OR?: InrConversionHistoryWhereInput[]
    NOT?: InrConversionHistoryWhereInput | InrConversionHistoryWhereInput[]
    accountId?: IntFilter<"InrConversionHistory"> | number
    baseToken?: StringFilter<"InrConversionHistory"> | string
    baseTokenQuantity?: FloatFilter<"InrConversionHistory"> | number
    inrValue?: FloatFilter<"InrConversionHistory"> | number
    inrValAfterDeduction?: FloatFilter<"InrConversionHistory"> | number
    gst?: FloatNullableFilter<"InrConversionHistory"> | number | null
    txnFee?: FloatNullableFilter<"InrConversionHistory"> | number | null
    tds?: FloatNullableFilter<"InrConversionHistory"> | number | null
    coinConversionRate?: FloatNullableFilter<"InrConversionHistory"> | number | null
    receivingAddress?: StringNullableFilter<"InrConversionHistory"> | string | null
    createdAt?: DateTimeFilter<"InrConversionHistory"> | Date | string
    createdBy?: IntFilter<"InrConversionHistory"> | number
    updatedAt?: DateTimeFilter<"InrConversionHistory"> | Date | string
    updatedBy?: IntFilter<"InrConversionHistory"> | number
    cryptoDeposit?: XOR<CryptoDepositNullableRelationFilter, CryptoDepositWhereInput> | null
    account?: XOR<UserAccountRelationFilter, UserAccountWhereInput>
  }, "id" | "id" | "cryptoDepositId">

  export type InrConversionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    cryptoDepositId?: SortOrderInput | SortOrder
    accountId?: SortOrder
    baseToken?: SortOrder
    baseTokenQuantity?: SortOrder
    inrValue?: SortOrder
    inrValAfterDeduction?: SortOrder
    gst?: SortOrderInput | SortOrder
    txnFee?: SortOrderInput | SortOrder
    tds?: SortOrderInput | SortOrder
    coinConversionRate?: SortOrderInput | SortOrder
    receivingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: InrConversionHistoryCountOrderByAggregateInput
    _avg?: InrConversionHistoryAvgOrderByAggregateInput
    _max?: InrConversionHistoryMaxOrderByAggregateInput
    _min?: InrConversionHistoryMinOrderByAggregateInput
    _sum?: InrConversionHistorySumOrderByAggregateInput
  }

  export type InrConversionHistoryScalarWhereWithAggregatesInput = {
    AND?: InrConversionHistoryScalarWhereWithAggregatesInput | InrConversionHistoryScalarWhereWithAggregatesInput[]
    OR?: InrConversionHistoryScalarWhereWithAggregatesInput[]
    NOT?: InrConversionHistoryScalarWhereWithAggregatesInput | InrConversionHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InrConversionHistory"> | number
    cryptoDepositId?: IntNullableWithAggregatesFilter<"InrConversionHistory"> | number | null
    accountId?: IntWithAggregatesFilter<"InrConversionHistory"> | number
    baseToken?: StringWithAggregatesFilter<"InrConversionHistory"> | string
    baseTokenQuantity?: FloatWithAggregatesFilter<"InrConversionHistory"> | number
    inrValue?: FloatWithAggregatesFilter<"InrConversionHistory"> | number
    inrValAfterDeduction?: FloatWithAggregatesFilter<"InrConversionHistory"> | number
    gst?: FloatNullableWithAggregatesFilter<"InrConversionHistory"> | number | null
    txnFee?: FloatNullableWithAggregatesFilter<"InrConversionHistory"> | number | null
    tds?: FloatNullableWithAggregatesFilter<"InrConversionHistory"> | number | null
    coinConversionRate?: FloatNullableWithAggregatesFilter<"InrConversionHistory"> | number | null
    receivingAddress?: StringNullableWithAggregatesFilter<"InrConversionHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InrConversionHistory"> | Date | string
    createdBy?: IntWithAggregatesFilter<"InrConversionHistory"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"InrConversionHistory"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"InrConversionHistory"> | number
  }

  export type BankFeedWhereInput = {
    AND?: BankFeedWhereInput | BankFeedWhereInput[]
    OR?: BankFeedWhereInput[]
    NOT?: BankFeedWhereInput | BankFeedWhereInput[]
    id?: IntFilter<"BankFeed"> | number
    paymentId?: IntNullableFilter<"BankFeed"> | number | null
    serialNumber?: IntFilter<"BankFeed"> | number
    amount?: StringFilter<"BankFeed"> | string
    fee?: StringFilter<"BankFeed"> | string
    bankName?: StringFilter<"BankFeed"> | string
    bankRefId?: StringFilter<"BankFeed"> | string
    processStatus?: EnumProcessStatusFilter<"BankFeed"> | $Enums.ProcessStatus
    userRemarks?: StringNullableFilter<"BankFeed"> | string | null
    createdAt?: DateTimeFilter<"BankFeed"> | Date | string
    createdBy?: IntFilter<"BankFeed"> | number
    updatedAt?: DateTimeFilter<"BankFeed"> | Date | string
    updatedBy?: IntFilter<"BankFeed"> | number
    fiatPayment?: XOR<FiatPaymentsNullableRelationFilter, FiatPaymentsWhereInput> | null
  }

  export type BankFeedOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    serialNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    bankName?: SortOrder
    bankRefId?: SortOrder
    processStatus?: SortOrder
    userRemarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    fiatPayment?: FiatPaymentsOrderByWithRelationInput
  }

  export type BankFeedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    paymentId?: number
    serialNumber?: number
    AND?: BankFeedWhereInput | BankFeedWhereInput[]
    OR?: BankFeedWhereInput[]
    NOT?: BankFeedWhereInput | BankFeedWhereInput[]
    amount?: StringFilter<"BankFeed"> | string
    fee?: StringFilter<"BankFeed"> | string
    bankName?: StringFilter<"BankFeed"> | string
    bankRefId?: StringFilter<"BankFeed"> | string
    processStatus?: EnumProcessStatusFilter<"BankFeed"> | $Enums.ProcessStatus
    userRemarks?: StringNullableFilter<"BankFeed"> | string | null
    createdAt?: DateTimeFilter<"BankFeed"> | Date | string
    createdBy?: IntFilter<"BankFeed"> | number
    updatedAt?: DateTimeFilter<"BankFeed"> | Date | string
    updatedBy?: IntFilter<"BankFeed"> | number
    fiatPayment?: XOR<FiatPaymentsNullableRelationFilter, FiatPaymentsWhereInput> | null
  }, "id" | "id" | "paymentId" | "serialNumber">

  export type BankFeedOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    serialNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    bankName?: SortOrder
    bankRefId?: SortOrder
    processStatus?: SortOrder
    userRemarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: BankFeedCountOrderByAggregateInput
    _avg?: BankFeedAvgOrderByAggregateInput
    _max?: BankFeedMaxOrderByAggregateInput
    _min?: BankFeedMinOrderByAggregateInput
    _sum?: BankFeedSumOrderByAggregateInput
  }

  export type BankFeedScalarWhereWithAggregatesInput = {
    AND?: BankFeedScalarWhereWithAggregatesInput | BankFeedScalarWhereWithAggregatesInput[]
    OR?: BankFeedScalarWhereWithAggregatesInput[]
    NOT?: BankFeedScalarWhereWithAggregatesInput | BankFeedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BankFeed"> | number
    paymentId?: IntNullableWithAggregatesFilter<"BankFeed"> | number | null
    serialNumber?: IntWithAggregatesFilter<"BankFeed"> | number
    amount?: StringWithAggregatesFilter<"BankFeed"> | string
    fee?: StringWithAggregatesFilter<"BankFeed"> | string
    bankName?: StringWithAggregatesFilter<"BankFeed"> | string
    bankRefId?: StringWithAggregatesFilter<"BankFeed"> | string
    processStatus?: EnumProcessStatusWithAggregatesFilter<"BankFeed"> | $Enums.ProcessStatus
    userRemarks?: StringNullableWithAggregatesFilter<"BankFeed"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BankFeed"> | Date | string
    createdBy?: IntWithAggregatesFilter<"BankFeed"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"BankFeed"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"BankFeed"> | number
  }

  export type InrLedgerWhereInput = {
    AND?: InrLedgerWhereInput | InrLedgerWhereInput[]
    OR?: InrLedgerWhereInput[]
    NOT?: InrLedgerWhereInput | InrLedgerWhereInput[]
    id?: IntFilter<"InrLedger"> | number
    accountId?: IntFilter<"InrLedger"> | number
    change?: FloatFilter<"InrLedger"> | number
    operation?: EnumInrOperationFilter<"InrLedger"> | $Enums.InrOperation
    timestamp?: DateTimeFilter<"InrLedger"> | Date | string
    createdAt?: DateTimeFilter<"InrLedger"> | Date | string
    createdBy?: IntFilter<"InrLedger"> | number
    updatedAt?: DateTimeFilter<"InrLedger"> | Date | string
    updatedBy?: IntFilter<"InrLedger"> | number
    account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
  }

  export type InrLedgerOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    account?: UserAccountOrderByWithRelationInput
  }

  export type InrLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InrLedgerWhereInput | InrLedgerWhereInput[]
    OR?: InrLedgerWhereInput[]
    NOT?: InrLedgerWhereInput | InrLedgerWhereInput[]
    accountId?: IntFilter<"InrLedger"> | number
    change?: FloatFilter<"InrLedger"> | number
    operation?: EnumInrOperationFilter<"InrLedger"> | $Enums.InrOperation
    timestamp?: DateTimeFilter<"InrLedger"> | Date | string
    createdAt?: DateTimeFilter<"InrLedger"> | Date | string
    createdBy?: IntFilter<"InrLedger"> | number
    updatedAt?: DateTimeFilter<"InrLedger"> | Date | string
    updatedBy?: IntFilter<"InrLedger"> | number
    account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
  }, "id" | "id">

  export type InrLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: InrLedgerCountOrderByAggregateInput
    _avg?: InrLedgerAvgOrderByAggregateInput
    _max?: InrLedgerMaxOrderByAggregateInput
    _min?: InrLedgerMinOrderByAggregateInput
    _sum?: InrLedgerSumOrderByAggregateInput
  }

  export type InrLedgerScalarWhereWithAggregatesInput = {
    AND?: InrLedgerScalarWhereWithAggregatesInput | InrLedgerScalarWhereWithAggregatesInput[]
    OR?: InrLedgerScalarWhereWithAggregatesInput[]
    NOT?: InrLedgerScalarWhereWithAggregatesInput | InrLedgerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InrLedger"> | number
    accountId?: IntWithAggregatesFilter<"InrLedger"> | number
    change?: FloatWithAggregatesFilter<"InrLedger"> | number
    operation?: EnumInrOperationWithAggregatesFilter<"InrLedger"> | $Enums.InrOperation
    timestamp?: DateTimeWithAggregatesFilter<"InrLedger"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"InrLedger"> | Date | string
    createdBy?: IntWithAggregatesFilter<"InrLedger"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"InrLedger"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"InrLedger"> | number
  }

  export type CryptoLedgerWhereInput = {
    AND?: CryptoLedgerWhereInput | CryptoLedgerWhereInput[]
    OR?: CryptoLedgerWhereInput[]
    NOT?: CryptoLedgerWhereInput | CryptoLedgerWhereInput[]
    id?: IntFilter<"CryptoLedger"> | number
    accountId?: IntFilter<"CryptoLedger"> | number
    coin?: StringFilter<"CryptoLedger"> | string
    change?: FloatFilter<"CryptoLedger"> | number
    operation?: EnumCryptoOperationFilter<"CryptoLedger"> | $Enums.CryptoOperation
    timestamp?: DateTimeFilter<"CryptoLedger"> | Date | string
    createdAt?: DateTimeFilter<"CryptoLedger"> | Date | string
    createdBy?: IntFilter<"CryptoLedger"> | number
    updatedAt?: DateTimeFilter<"CryptoLedger"> | Date | string
    updatedBy?: IntFilter<"CryptoLedger"> | number
    account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
  }

  export type CryptoLedgerOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    coin?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    account?: UserAccountOrderByWithRelationInput
  }

  export type CryptoLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CryptoLedgerWhereInput | CryptoLedgerWhereInput[]
    OR?: CryptoLedgerWhereInput[]
    NOT?: CryptoLedgerWhereInput | CryptoLedgerWhereInput[]
    accountId?: IntFilter<"CryptoLedger"> | number
    coin?: StringFilter<"CryptoLedger"> | string
    change?: FloatFilter<"CryptoLedger"> | number
    operation?: EnumCryptoOperationFilter<"CryptoLedger"> | $Enums.CryptoOperation
    timestamp?: DateTimeFilter<"CryptoLedger"> | Date | string
    createdAt?: DateTimeFilter<"CryptoLedger"> | Date | string
    createdBy?: IntFilter<"CryptoLedger"> | number
    updatedAt?: DateTimeFilter<"CryptoLedger"> | Date | string
    updatedBy?: IntFilter<"CryptoLedger"> | number
    account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
  }, "id" | "id">

  export type CryptoLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    coin?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: CryptoLedgerCountOrderByAggregateInput
    _avg?: CryptoLedgerAvgOrderByAggregateInput
    _max?: CryptoLedgerMaxOrderByAggregateInput
    _min?: CryptoLedgerMinOrderByAggregateInput
    _sum?: CryptoLedgerSumOrderByAggregateInput
  }

  export type CryptoLedgerScalarWhereWithAggregatesInput = {
    AND?: CryptoLedgerScalarWhereWithAggregatesInput | CryptoLedgerScalarWhereWithAggregatesInput[]
    OR?: CryptoLedgerScalarWhereWithAggregatesInput[]
    NOT?: CryptoLedgerScalarWhereWithAggregatesInput | CryptoLedgerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CryptoLedger"> | number
    accountId?: IntWithAggregatesFilter<"CryptoLedger"> | number
    coin?: StringWithAggregatesFilter<"CryptoLedger"> | string
    change?: FloatWithAggregatesFilter<"CryptoLedger"> | number
    operation?: EnumCryptoOperationWithAggregatesFilter<"CryptoLedger"> | $Enums.CryptoOperation
    timestamp?: DateTimeWithAggregatesFilter<"CryptoLedger"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CryptoLedger"> | Date | string
    createdBy?: IntWithAggregatesFilter<"CryptoLedger"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoLedger"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"CryptoLedger"> | number
  }

  export type TradeLedgerWhereInput = {
    AND?: TradeLedgerWhereInput | TradeLedgerWhereInput[]
    OR?: TradeLedgerWhereInput[]
    NOT?: TradeLedgerWhereInput | TradeLedgerWhereInput[]
    id?: IntFilter<"TradeLedger"> | number
    accountId?: IntFilter<"TradeLedger"> | number
    change?: StringFilter<"TradeLedger"> | string
    tradeId?: StringFilter<"TradeLedger"> | string
    positionType?: EnumPositionTypeFilter<"TradeLedger"> | $Enums.PositionType
    operation?: EnumTradeOperationFilter<"TradeLedger"> | $Enums.TradeOperation
    timestamp?: DateTimeFilter<"TradeLedger"> | Date | string
    createdAt?: DateTimeFilter<"TradeLedger"> | Date | string
    createdBy?: IntFilter<"TradeLedger"> | number
    updatedAt?: DateTimeFilter<"TradeLedger"> | Date | string
    updatedBy?: IntFilter<"TradeLedger"> | number
    account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
  }

  export type TradeLedgerOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    tradeId?: SortOrder
    positionType?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    account?: UserAccountOrderByWithRelationInput
  }

  export type TradeLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    accountId?: number
    AND?: TradeLedgerWhereInput | TradeLedgerWhereInput[]
    OR?: TradeLedgerWhereInput[]
    NOT?: TradeLedgerWhereInput | TradeLedgerWhereInput[]
    change?: StringFilter<"TradeLedger"> | string
    tradeId?: StringFilter<"TradeLedger"> | string
    positionType?: EnumPositionTypeFilter<"TradeLedger"> | $Enums.PositionType
    operation?: EnumTradeOperationFilter<"TradeLedger"> | $Enums.TradeOperation
    timestamp?: DateTimeFilter<"TradeLedger"> | Date | string
    createdAt?: DateTimeFilter<"TradeLedger"> | Date | string
    createdBy?: IntFilter<"TradeLedger"> | number
    updatedAt?: DateTimeFilter<"TradeLedger"> | Date | string
    updatedBy?: IntFilter<"TradeLedger"> | number
    account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
  }, "id" | "id" | "accountId">

  export type TradeLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    tradeId?: SortOrder
    positionType?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: TradeLedgerCountOrderByAggregateInput
    _avg?: TradeLedgerAvgOrderByAggregateInput
    _max?: TradeLedgerMaxOrderByAggregateInput
    _min?: TradeLedgerMinOrderByAggregateInput
    _sum?: TradeLedgerSumOrderByAggregateInput
  }

  export type TradeLedgerScalarWhereWithAggregatesInput = {
    AND?: TradeLedgerScalarWhereWithAggregatesInput | TradeLedgerScalarWhereWithAggregatesInput[]
    OR?: TradeLedgerScalarWhereWithAggregatesInput[]
    NOT?: TradeLedgerScalarWhereWithAggregatesInput | TradeLedgerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TradeLedger"> | number
    accountId?: IntWithAggregatesFilter<"TradeLedger"> | number
    change?: StringWithAggregatesFilter<"TradeLedger"> | string
    tradeId?: StringWithAggregatesFilter<"TradeLedger"> | string
    positionType?: EnumPositionTypeWithAggregatesFilter<"TradeLedger"> | $Enums.PositionType
    operation?: EnumTradeOperationWithAggregatesFilter<"TradeLedger"> | $Enums.TradeOperation
    timestamp?: DateTimeWithAggregatesFilter<"TradeLedger"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TradeLedger"> | Date | string
    createdBy?: IntWithAggregatesFilter<"TradeLedger"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"TradeLedger"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"TradeLedger"> | number
  }

  export type SystemConfigForDashboardWhereInput = {
    AND?: SystemConfigForDashboardWhereInput | SystemConfigForDashboardWhereInput[]
    OR?: SystemConfigForDashboardWhereInput[]
    NOT?: SystemConfigForDashboardWhereInput | SystemConfigForDashboardWhereInput[]
    id?: IntFilter<"SystemConfigForDashboard"> | number
    parameterGroup?: EnumParameterGroupFilter<"SystemConfigForDashboard"> | $Enums.ParameterGroup
    parameterName?: StringFilter<"SystemConfigForDashboard"> | string
    parameterType?: EnumParamTypeFilter<"SystemConfigForDashboard"> | $Enums.ParamType
    isRanged?: BoolFilter<"SystemConfigForDashboard"> | boolean
    parameterValue?: StringNullableFilter<"SystemConfigForDashboard"> | string | null
    symbol?: StringNullableFilter<"SystemConfigForDashboard"> | string | null
    rangeStart?: StringNullableFilter<"SystemConfigForDashboard"> | string | null
    rangeEnd?: StringNullableFilter<"SystemConfigForDashboard"> | string | null
    roleBasedAccess?: BoolFilter<"SystemConfigForDashboard"> | boolean
    role?: EnumRoleFilter<"SystemConfigForDashboard"> | $Enums.Role
    createdAt?: DateTimeFilter<"SystemConfigForDashboard"> | Date | string
    createdBy?: IntFilter<"SystemConfigForDashboard"> | number
    updatedAt?: DateTimeFilter<"SystemConfigForDashboard"> | Date | string
    updatedBy?: IntFilter<"SystemConfigForDashboard"> | number
  }

  export type SystemConfigForDashboardOrderByWithRelationInput = {
    id?: SortOrder
    parameterGroup?: SortOrder
    parameterName?: SortOrder
    parameterType?: SortOrder
    isRanged?: SortOrder
    parameterValue?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    rangeStart?: SortOrderInput | SortOrder
    rangeEnd?: SortOrderInput | SortOrder
    roleBasedAccess?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigForDashboardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    parameterName?: string
    AND?: SystemConfigForDashboardWhereInput | SystemConfigForDashboardWhereInput[]
    OR?: SystemConfigForDashboardWhereInput[]
    NOT?: SystemConfigForDashboardWhereInput | SystemConfigForDashboardWhereInput[]
    parameterGroup?: EnumParameterGroupFilter<"SystemConfigForDashboard"> | $Enums.ParameterGroup
    parameterType?: EnumParamTypeFilter<"SystemConfigForDashboard"> | $Enums.ParamType
    isRanged?: BoolFilter<"SystemConfigForDashboard"> | boolean
    parameterValue?: StringNullableFilter<"SystemConfigForDashboard"> | string | null
    symbol?: StringNullableFilter<"SystemConfigForDashboard"> | string | null
    rangeStart?: StringNullableFilter<"SystemConfigForDashboard"> | string | null
    rangeEnd?: StringNullableFilter<"SystemConfigForDashboard"> | string | null
    roleBasedAccess?: BoolFilter<"SystemConfigForDashboard"> | boolean
    role?: EnumRoleFilter<"SystemConfigForDashboard"> | $Enums.Role
    createdAt?: DateTimeFilter<"SystemConfigForDashboard"> | Date | string
    createdBy?: IntFilter<"SystemConfigForDashboard"> | number
    updatedAt?: DateTimeFilter<"SystemConfigForDashboard"> | Date | string
    updatedBy?: IntFilter<"SystemConfigForDashboard"> | number
  }, "id" | "id" | "parameterName">

  export type SystemConfigForDashboardOrderByWithAggregationInput = {
    id?: SortOrder
    parameterGroup?: SortOrder
    parameterName?: SortOrder
    parameterType?: SortOrder
    isRanged?: SortOrder
    parameterValue?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    rangeStart?: SortOrderInput | SortOrder
    rangeEnd?: SortOrderInput | SortOrder
    roleBasedAccess?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: SystemConfigForDashboardCountOrderByAggregateInput
    _avg?: SystemConfigForDashboardAvgOrderByAggregateInput
    _max?: SystemConfigForDashboardMaxOrderByAggregateInput
    _min?: SystemConfigForDashboardMinOrderByAggregateInput
    _sum?: SystemConfigForDashboardSumOrderByAggregateInput
  }

  export type SystemConfigForDashboardScalarWhereWithAggregatesInput = {
    AND?: SystemConfigForDashboardScalarWhereWithAggregatesInput | SystemConfigForDashboardScalarWhereWithAggregatesInput[]
    OR?: SystemConfigForDashboardScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigForDashboardScalarWhereWithAggregatesInput | SystemConfigForDashboardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemConfigForDashboard"> | number
    parameterGroup?: EnumParameterGroupWithAggregatesFilter<"SystemConfigForDashboard"> | $Enums.ParameterGroup
    parameterName?: StringWithAggregatesFilter<"SystemConfigForDashboard"> | string
    parameterType?: EnumParamTypeWithAggregatesFilter<"SystemConfigForDashboard"> | $Enums.ParamType
    isRanged?: BoolWithAggregatesFilter<"SystemConfigForDashboard"> | boolean
    parameterValue?: StringNullableWithAggregatesFilter<"SystemConfigForDashboard"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"SystemConfigForDashboard"> | string | null
    rangeStart?: StringNullableWithAggregatesFilter<"SystemConfigForDashboard"> | string | null
    rangeEnd?: StringNullableWithAggregatesFilter<"SystemConfigForDashboard"> | string | null
    roleBasedAccess?: BoolWithAggregatesFilter<"SystemConfigForDashboard"> | boolean
    role?: EnumRoleWithAggregatesFilter<"SystemConfigForDashboard"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfigForDashboard"> | Date | string
    createdBy?: IntWithAggregatesFilter<"SystemConfigForDashboard"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfigForDashboard"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"SystemConfigForDashboard"> | number
  }

  export type SystemConfigChangeLogWhereInput = {
    AND?: SystemConfigChangeLogWhereInput | SystemConfigChangeLogWhereInput[]
    OR?: SystemConfigChangeLogWhereInput[]
    NOT?: SystemConfigChangeLogWhereInput | SystemConfigChangeLogWhereInput[]
    id?: IntFilter<"SystemConfigChangeLog"> | number
    timestamp?: DateTimeFilter<"SystemConfigChangeLog"> | Date | string
    userId?: IntFilter<"SystemConfigChangeLog"> | number
    parameterName?: StringFilter<"SystemConfigChangeLog"> | string
    parameterValue?: StringNullableFilter<"SystemConfigChangeLog"> | string | null
    isRanged?: BoolFilter<"SystemConfigChangeLog"> | boolean
    rangeStart?: StringNullableFilter<"SystemConfigChangeLog"> | string | null
    rangeEnd?: StringNullableFilter<"SystemConfigChangeLog"> | string | null
    userType?: StringFilter<"SystemConfigChangeLog"> | string
    createdAt?: DateTimeFilter<"SystemConfigChangeLog"> | Date | string
    createdBy?: IntFilter<"SystemConfigChangeLog"> | number
    updatedAt?: DateTimeFilter<"SystemConfigChangeLog"> | Date | string
    updatedBy?: IntFilter<"SystemConfigChangeLog"> | number
  }

  export type SystemConfigChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    parameterName?: SortOrder
    parameterValue?: SortOrderInput | SortOrder
    isRanged?: SortOrder
    rangeStart?: SortOrderInput | SortOrder
    rangeEnd?: SortOrderInput | SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    parameterName?: string
    AND?: SystemConfigChangeLogWhereInput | SystemConfigChangeLogWhereInput[]
    OR?: SystemConfigChangeLogWhereInput[]
    NOT?: SystemConfigChangeLogWhereInput | SystemConfigChangeLogWhereInput[]
    timestamp?: DateTimeFilter<"SystemConfigChangeLog"> | Date | string
    userId?: IntFilter<"SystemConfigChangeLog"> | number
    parameterValue?: StringNullableFilter<"SystemConfigChangeLog"> | string | null
    isRanged?: BoolFilter<"SystemConfigChangeLog"> | boolean
    rangeStart?: StringNullableFilter<"SystemConfigChangeLog"> | string | null
    rangeEnd?: StringNullableFilter<"SystemConfigChangeLog"> | string | null
    userType?: StringFilter<"SystemConfigChangeLog"> | string
    createdAt?: DateTimeFilter<"SystemConfigChangeLog"> | Date | string
    createdBy?: IntFilter<"SystemConfigChangeLog"> | number
    updatedAt?: DateTimeFilter<"SystemConfigChangeLog"> | Date | string
    updatedBy?: IntFilter<"SystemConfigChangeLog"> | number
  }, "id" | "id" | "parameterName">

  export type SystemConfigChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    parameterName?: SortOrder
    parameterValue?: SortOrderInput | SortOrder
    isRanged?: SortOrder
    rangeStart?: SortOrderInput | SortOrder
    rangeEnd?: SortOrderInput | SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: SystemConfigChangeLogCountOrderByAggregateInput
    _avg?: SystemConfigChangeLogAvgOrderByAggregateInput
    _max?: SystemConfigChangeLogMaxOrderByAggregateInput
    _min?: SystemConfigChangeLogMinOrderByAggregateInput
    _sum?: SystemConfigChangeLogSumOrderByAggregateInput
  }

  export type SystemConfigChangeLogScalarWhereWithAggregatesInput = {
    AND?: SystemConfigChangeLogScalarWhereWithAggregatesInput | SystemConfigChangeLogScalarWhereWithAggregatesInput[]
    OR?: SystemConfigChangeLogScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigChangeLogScalarWhereWithAggregatesInput | SystemConfigChangeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemConfigChangeLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"SystemConfigChangeLog"> | Date | string
    userId?: IntWithAggregatesFilter<"SystemConfigChangeLog"> | number
    parameterName?: StringWithAggregatesFilter<"SystemConfigChangeLog"> | string
    parameterValue?: StringNullableWithAggregatesFilter<"SystemConfigChangeLog"> | string | null
    isRanged?: BoolWithAggregatesFilter<"SystemConfigChangeLog"> | boolean
    rangeStart?: StringNullableWithAggregatesFilter<"SystemConfigChangeLog"> | string | null
    rangeEnd?: StringNullableWithAggregatesFilter<"SystemConfigChangeLog"> | string | null
    userType?: StringWithAggregatesFilter<"SystemConfigChangeLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfigChangeLog"> | Date | string
    createdBy?: IntWithAggregatesFilter<"SystemConfigChangeLog"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfigChangeLog"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"SystemConfigChangeLog"> | number
  }

  export type InrWalletWhereInput = {
    AND?: InrWalletWhereInput | InrWalletWhereInput[]
    OR?: InrWalletWhereInput[]
    NOT?: InrWalletWhereInput | InrWalletWhereInput[]
    id?: IntFilter<"InrWallet"> | number
    accountId?: IntFilter<"InrWallet"> | number
    walletBalance?: FloatFilter<"InrWallet"> | number
    amountAvailable?: FloatFilter<"InrWallet"> | number
    amountLocked?: FloatFilter<"InrWallet"> | number
    unrealizedPnl?: FloatFilter<"InrWallet"> | number
    last24hourChange?: FloatFilter<"InrWallet"> | number
    createdAt?: DateTimeFilter<"InrWallet"> | Date | string
    createdBy?: IntFilter<"InrWallet"> | number
    updatedAt?: DateTimeFilter<"InrWallet"> | Date | string
    updatedBy?: IntFilter<"InrWallet"> | number
    Account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
  }

  export type InrWalletOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    walletBalance?: SortOrder
    amountAvailable?: SortOrder
    amountLocked?: SortOrder
    unrealizedPnl?: SortOrder
    last24hourChange?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    Account?: UserAccountOrderByWithRelationInput
  }

  export type InrWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    accountId?: number
    AND?: InrWalletWhereInput | InrWalletWhereInput[]
    OR?: InrWalletWhereInput[]
    NOT?: InrWalletWhereInput | InrWalletWhereInput[]
    walletBalance?: FloatFilter<"InrWallet"> | number
    amountAvailable?: FloatFilter<"InrWallet"> | number
    amountLocked?: FloatFilter<"InrWallet"> | number
    unrealizedPnl?: FloatFilter<"InrWallet"> | number
    last24hourChange?: FloatFilter<"InrWallet"> | number
    createdAt?: DateTimeFilter<"InrWallet"> | Date | string
    createdBy?: IntFilter<"InrWallet"> | number
    updatedAt?: DateTimeFilter<"InrWallet"> | Date | string
    updatedBy?: IntFilter<"InrWallet"> | number
    Account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
  }, "id" | "id" | "accountId">

  export type InrWalletOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    walletBalance?: SortOrder
    amountAvailable?: SortOrder
    amountLocked?: SortOrder
    unrealizedPnl?: SortOrder
    last24hourChange?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: InrWalletCountOrderByAggregateInput
    _avg?: InrWalletAvgOrderByAggregateInput
    _max?: InrWalletMaxOrderByAggregateInput
    _min?: InrWalletMinOrderByAggregateInput
    _sum?: InrWalletSumOrderByAggregateInput
  }

  export type InrWalletScalarWhereWithAggregatesInput = {
    AND?: InrWalletScalarWhereWithAggregatesInput | InrWalletScalarWhereWithAggregatesInput[]
    OR?: InrWalletScalarWhereWithAggregatesInput[]
    NOT?: InrWalletScalarWhereWithAggregatesInput | InrWalletScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InrWallet"> | number
    accountId?: IntWithAggregatesFilter<"InrWallet"> | number
    walletBalance?: FloatWithAggregatesFilter<"InrWallet"> | number
    amountAvailable?: FloatWithAggregatesFilter<"InrWallet"> | number
    amountLocked?: FloatWithAggregatesFilter<"InrWallet"> | number
    unrealizedPnl?: FloatWithAggregatesFilter<"InrWallet"> | number
    last24hourChange?: FloatWithAggregatesFilter<"InrWallet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InrWallet"> | Date | string
    createdBy?: IntWithAggregatesFilter<"InrWallet"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"InrWallet"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"InrWallet"> | number
  }

  export type ParentWalletWhereInput = {
    AND?: ParentWalletWhereInput | ParentWalletWhereInput[]
    OR?: ParentWalletWhereInput[]
    NOT?: ParentWalletWhereInput | ParentWalletWhereInput[]
    id?: IntFilter<"ParentWallet"> | number
    walletId?: IntFilter<"ParentWallet"> | number
    walletAddress?: StringFilter<"ParentWallet"> | string
    chain?: StringFilter<"ParentWallet"> | string
    coin?: StringFilter<"ParentWallet"> | string
    parentChain?: StringFilter<"ParentWallet"> | string
    type?: StringFilter<"ParentWallet"> | string
    subType?: EnumParentWalletTypeFilter<"ParentWallet"> | $Enums.ParentWalletType
    lastUsedIndex?: IntFilter<"ParentWallet"> | number
    displayName?: StringNullableFilter<"ParentWallet"> | string | null
    toBeDisplayed?: BoolFilter<"ParentWallet"> | boolean
    parentChainIconUrl?: StringNullableFilter<"ParentWallet"> | string | null
    createdAt?: DateTimeFilter<"ParentWallet"> | Date | string
    updatedAt?: DateTimeFilter<"ParentWallet"> | Date | string
    childCryptoWallet?: CryptoWalletListRelationFilter
    parentWallet?: StableCoinListRelationFilter
  }

  export type ParentWalletOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    walletAddress?: SortOrder
    chain?: SortOrder
    coin?: SortOrder
    parentChain?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    lastUsedIndex?: SortOrder
    displayName?: SortOrderInput | SortOrder
    toBeDisplayed?: SortOrder
    parentChainIconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    childCryptoWallet?: CryptoWalletOrderByRelationAggregateInput
    parentWallet?: StableCoinOrderByRelationAggregateInput
  }

  export type ParentWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParentWalletWhereInput | ParentWalletWhereInput[]
    OR?: ParentWalletWhereInput[]
    NOT?: ParentWalletWhereInput | ParentWalletWhereInput[]
    walletId?: IntFilter<"ParentWallet"> | number
    walletAddress?: StringFilter<"ParentWallet"> | string
    chain?: StringFilter<"ParentWallet"> | string
    coin?: StringFilter<"ParentWallet"> | string
    parentChain?: StringFilter<"ParentWallet"> | string
    type?: StringFilter<"ParentWallet"> | string
    subType?: EnumParentWalletTypeFilter<"ParentWallet"> | $Enums.ParentWalletType
    lastUsedIndex?: IntFilter<"ParentWallet"> | number
    displayName?: StringNullableFilter<"ParentWallet"> | string | null
    toBeDisplayed?: BoolFilter<"ParentWallet"> | boolean
    parentChainIconUrl?: StringNullableFilter<"ParentWallet"> | string | null
    createdAt?: DateTimeFilter<"ParentWallet"> | Date | string
    updatedAt?: DateTimeFilter<"ParentWallet"> | Date | string
    childCryptoWallet?: CryptoWalletListRelationFilter
    parentWallet?: StableCoinListRelationFilter
  }, "id" | "id">

  export type ParentWalletOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    walletAddress?: SortOrder
    chain?: SortOrder
    coin?: SortOrder
    parentChain?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    lastUsedIndex?: SortOrder
    displayName?: SortOrderInput | SortOrder
    toBeDisplayed?: SortOrder
    parentChainIconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentWalletCountOrderByAggregateInput
    _avg?: ParentWalletAvgOrderByAggregateInput
    _max?: ParentWalletMaxOrderByAggregateInput
    _min?: ParentWalletMinOrderByAggregateInput
    _sum?: ParentWalletSumOrderByAggregateInput
  }

  export type ParentWalletScalarWhereWithAggregatesInput = {
    AND?: ParentWalletScalarWhereWithAggregatesInput | ParentWalletScalarWhereWithAggregatesInput[]
    OR?: ParentWalletScalarWhereWithAggregatesInput[]
    NOT?: ParentWalletScalarWhereWithAggregatesInput | ParentWalletScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParentWallet"> | number
    walletId?: IntWithAggregatesFilter<"ParentWallet"> | number
    walletAddress?: StringWithAggregatesFilter<"ParentWallet"> | string
    chain?: StringWithAggregatesFilter<"ParentWallet"> | string
    coin?: StringWithAggregatesFilter<"ParentWallet"> | string
    parentChain?: StringWithAggregatesFilter<"ParentWallet"> | string
    type?: StringWithAggregatesFilter<"ParentWallet"> | string
    subType?: EnumParentWalletTypeWithAggregatesFilter<"ParentWallet"> | $Enums.ParentWalletType
    lastUsedIndex?: IntWithAggregatesFilter<"ParentWallet"> | number
    displayName?: StringNullableWithAggregatesFilter<"ParentWallet"> | string | null
    toBeDisplayed?: BoolWithAggregatesFilter<"ParentWallet"> | boolean
    parentChainIconUrl?: StringNullableWithAggregatesFilter<"ParentWallet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ParentWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParentWallet"> | Date | string
  }

  export type StableCoinWhereInput = {
    AND?: StableCoinWhereInput | StableCoinWhereInput[]
    OR?: StableCoinWhereInput[]
    NOT?: StableCoinWhereInput | StableCoinWhereInput[]
    id?: IntFilter<"StableCoin"> | number
    parentWalletId?: IntFilter<"StableCoin"> | number
    token?: StringFilter<"StableCoin"> | string
    parentChain?: StringFilter<"StableCoin"> | string
    tokenIconUrl?: StringNullableFilter<"StableCoin"> | string | null
    parentWallet?: XOR<ParentWalletRelationFilter, ParentWalletWhereInput>
  }

  export type StableCoinOrderByWithRelationInput = {
    id?: SortOrder
    parentWalletId?: SortOrder
    token?: SortOrder
    parentChain?: SortOrder
    tokenIconUrl?: SortOrderInput | SortOrder
    parentWallet?: ParentWalletOrderByWithRelationInput
  }

  export type StableCoinWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    parentWalletId_token?: StableCoinParentWalletIdTokenCompoundUniqueInput
    AND?: StableCoinWhereInput | StableCoinWhereInput[]
    OR?: StableCoinWhereInput[]
    NOT?: StableCoinWhereInput | StableCoinWhereInput[]
    parentWalletId?: IntFilter<"StableCoin"> | number
    token?: StringFilter<"StableCoin"> | string
    parentChain?: StringFilter<"StableCoin"> | string
    tokenIconUrl?: StringNullableFilter<"StableCoin"> | string | null
    parentWallet?: XOR<ParentWalletRelationFilter, ParentWalletWhereInput>
  }, "id" | "id" | "parentWalletId_token">

  export type StableCoinOrderByWithAggregationInput = {
    id?: SortOrder
    parentWalletId?: SortOrder
    token?: SortOrder
    parentChain?: SortOrder
    tokenIconUrl?: SortOrderInput | SortOrder
    _count?: StableCoinCountOrderByAggregateInput
    _avg?: StableCoinAvgOrderByAggregateInput
    _max?: StableCoinMaxOrderByAggregateInput
    _min?: StableCoinMinOrderByAggregateInput
    _sum?: StableCoinSumOrderByAggregateInput
  }

  export type StableCoinScalarWhereWithAggregatesInput = {
    AND?: StableCoinScalarWhereWithAggregatesInput | StableCoinScalarWhereWithAggregatesInput[]
    OR?: StableCoinScalarWhereWithAggregatesInput[]
    NOT?: StableCoinScalarWhereWithAggregatesInput | StableCoinScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StableCoin"> | number
    parentWalletId?: IntWithAggregatesFilter<"StableCoin"> | number
    token?: StringWithAggregatesFilter<"StableCoin"> | string
    parentChain?: StringWithAggregatesFilter<"StableCoin"> | string
    tokenIconUrl?: StringNullableWithAggregatesFilter<"StableCoin"> | string | null
  }

  export type CryptoWalletWhereInput = {
    AND?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    OR?: CryptoWalletWhereInput[]
    NOT?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    id?: IntFilter<"CryptoWallet"> | number
    accountId?: IntNullableFilter<"CryptoWallet"> | number | null
    parentWalletId?: IntFilter<"CryptoWallet"> | number
    liminalRefId?: StringFilter<"CryptoWallet"> | string
    liminalParentId?: IntFilter<"CryptoWallet"> | number
    liminalCoin?: StringFilter<"CryptoWallet"> | string
    liminalChain?: StringFilter<"CryptoWallet"> | string
    publicAddress?: StringFilter<"CryptoWallet"> | string
    balance?: FloatFilter<"CryptoWallet"> | number
    lastConversion?: DateTimeNullableFilter<"CryptoWallet"> | Date | string | null
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    createdBy?: IntFilter<"CryptoWallet"> | number
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedBy?: IntFilter<"CryptoWallet"> | number
    account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
    parentWallet?: XOR<ParentWalletRelationFilter, ParentWalletWhereInput>
    cryptoDeposit?: CryptoDepositListRelationFilter
  }

  export type CryptoWalletOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrderInput | SortOrder
    parentWalletId?: SortOrder
    liminalRefId?: SortOrder
    liminalParentId?: SortOrder
    liminalCoin?: SortOrder
    liminalChain?: SortOrder
    publicAddress?: SortOrder
    balance?: SortOrder
    lastConversion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    account?: UserAccountOrderByWithRelationInput
    parentWallet?: ParentWalletOrderByWithRelationInput
    cryptoDeposit?: CryptoDepositOrderByRelationAggregateInput
  }

  export type CryptoWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    liminalCoin_publicAddress?: CryptoWalletLiminalCoinPublicAddressCompoundUniqueInput
    AND?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    OR?: CryptoWalletWhereInput[]
    NOT?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    accountId?: IntNullableFilter<"CryptoWallet"> | number | null
    parentWalletId?: IntFilter<"CryptoWallet"> | number
    liminalRefId?: StringFilter<"CryptoWallet"> | string
    liminalParentId?: IntFilter<"CryptoWallet"> | number
    liminalCoin?: StringFilter<"CryptoWallet"> | string
    liminalChain?: StringFilter<"CryptoWallet"> | string
    publicAddress?: StringFilter<"CryptoWallet"> | string
    balance?: FloatFilter<"CryptoWallet"> | number
    lastConversion?: DateTimeNullableFilter<"CryptoWallet"> | Date | string | null
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    createdBy?: IntFilter<"CryptoWallet"> | number
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedBy?: IntFilter<"CryptoWallet"> | number
    account?: XOR<UserAccountNullableRelationFilter, UserAccountWhereInput> | null
    parentWallet?: XOR<ParentWalletRelationFilter, ParentWalletWhereInput>
    cryptoDeposit?: CryptoDepositListRelationFilter
  }, "id" | "id" | "liminalCoin_publicAddress">

  export type CryptoWalletOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrderInput | SortOrder
    parentWalletId?: SortOrder
    liminalRefId?: SortOrder
    liminalParentId?: SortOrder
    liminalCoin?: SortOrder
    liminalChain?: SortOrder
    publicAddress?: SortOrder
    balance?: SortOrder
    lastConversion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: CryptoWalletCountOrderByAggregateInput
    _avg?: CryptoWalletAvgOrderByAggregateInput
    _max?: CryptoWalletMaxOrderByAggregateInput
    _min?: CryptoWalletMinOrderByAggregateInput
    _sum?: CryptoWalletSumOrderByAggregateInput
  }

  export type CryptoWalletScalarWhereWithAggregatesInput = {
    AND?: CryptoWalletScalarWhereWithAggregatesInput | CryptoWalletScalarWhereWithAggregatesInput[]
    OR?: CryptoWalletScalarWhereWithAggregatesInput[]
    NOT?: CryptoWalletScalarWhereWithAggregatesInput | CryptoWalletScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CryptoWallet"> | number
    accountId?: IntNullableWithAggregatesFilter<"CryptoWallet"> | number | null
    parentWalletId?: IntWithAggregatesFilter<"CryptoWallet"> | number
    liminalRefId?: StringWithAggregatesFilter<"CryptoWallet"> | string
    liminalParentId?: IntWithAggregatesFilter<"CryptoWallet"> | number
    liminalCoin?: StringWithAggregatesFilter<"CryptoWallet"> | string
    liminalChain?: StringWithAggregatesFilter<"CryptoWallet"> | string
    publicAddress?: StringWithAggregatesFilter<"CryptoWallet"> | string
    balance?: FloatWithAggregatesFilter<"CryptoWallet"> | number
    lastConversion?: DateTimeNullableWithAggregatesFilter<"CryptoWallet"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CryptoWallet"> | Date | string
    createdBy?: IntWithAggregatesFilter<"CryptoWallet"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoWallet"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"CryptoWallet"> | number
  }

  export type PerpetualContractsWhereInput = {
    AND?: PerpetualContractsWhereInput | PerpetualContractsWhereInput[]
    OR?: PerpetualContractsWhereInput[]
    NOT?: PerpetualContractsWhereInput | PerpetualContractsWhereInput[]
    id?: IntFilter<"PerpetualContracts"> | number
    contractSymbol?: StringFilter<"PerpetualContracts"> | string
    displayName?: StringFilter<"PerpetualContracts"> | string
    systemConfig?: JsonFilter<"PerpetualContracts">
    exchangeConfig?: JsonFilter<"PerpetualContracts">
    isActive?: BoolFilter<"PerpetualContracts"> | boolean
    createdAt?: DateTimeFilter<"PerpetualContracts"> | Date | string
    createdBy?: IntFilter<"PerpetualContracts"> | number
    updatedAt?: DateTimeFilter<"PerpetualContracts"> | Date | string
    updatedBy?: IntFilter<"PerpetualContracts"> | number
  }

  export type PerpetualContractsOrderByWithRelationInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    systemConfig?: SortOrder
    exchangeConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PerpetualContractsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    contractSymbol?: string
    AND?: PerpetualContractsWhereInput | PerpetualContractsWhereInput[]
    OR?: PerpetualContractsWhereInput[]
    NOT?: PerpetualContractsWhereInput | PerpetualContractsWhereInput[]
    displayName?: StringFilter<"PerpetualContracts"> | string
    systemConfig?: JsonFilter<"PerpetualContracts">
    exchangeConfig?: JsonFilter<"PerpetualContracts">
    isActive?: BoolFilter<"PerpetualContracts"> | boolean
    createdAt?: DateTimeFilter<"PerpetualContracts"> | Date | string
    createdBy?: IntFilter<"PerpetualContracts"> | number
    updatedAt?: DateTimeFilter<"PerpetualContracts"> | Date | string
    updatedBy?: IntFilter<"PerpetualContracts"> | number
  }, "id" | "id" | "contractSymbol">

  export type PerpetualContractsOrderByWithAggregationInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    systemConfig?: SortOrder
    exchangeConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: PerpetualContractsCountOrderByAggregateInput
    _avg?: PerpetualContractsAvgOrderByAggregateInput
    _max?: PerpetualContractsMaxOrderByAggregateInput
    _min?: PerpetualContractsMinOrderByAggregateInput
    _sum?: PerpetualContractsSumOrderByAggregateInput
  }

  export type PerpetualContractsScalarWhereWithAggregatesInput = {
    AND?: PerpetualContractsScalarWhereWithAggregatesInput | PerpetualContractsScalarWhereWithAggregatesInput[]
    OR?: PerpetualContractsScalarWhereWithAggregatesInput[]
    NOT?: PerpetualContractsScalarWhereWithAggregatesInput | PerpetualContractsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PerpetualContracts"> | number
    contractSymbol?: StringWithAggregatesFilter<"PerpetualContracts"> | string
    displayName?: StringWithAggregatesFilter<"PerpetualContracts"> | string
    systemConfig?: JsonWithAggregatesFilter<"PerpetualContracts">
    exchangeConfig?: JsonWithAggregatesFilter<"PerpetualContracts">
    isActive?: BoolWithAggregatesFilter<"PerpetualContracts"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PerpetualContracts"> | Date | string
    createdBy?: IntWithAggregatesFilter<"PerpetualContracts"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"PerpetualContracts"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"PerpetualContracts"> | number
  }

  export type KlineHistoricalDataWhereInput = {
    AND?: KlineHistoricalDataWhereInput | KlineHistoricalDataWhereInput[]
    OR?: KlineHistoricalDataWhereInput[]
    NOT?: KlineHistoricalDataWhereInput | KlineHistoricalDataWhereInput[]
    id?: IntFilter<"KlineHistoricalData"> | number
    contractSymbol?: StringFilter<"KlineHistoricalData"> | string
    displayName?: StringFilter<"KlineHistoricalData"> | string
    interval?: EnumIntervalFilter<"KlineHistoricalData"> | $Enums.Interval
    ohlc?: JsonFilter<"KlineHistoricalData">
    conversionRate?: StringFilter<"KlineHistoricalData"> | string
    startTime?: BigIntFilter<"KlineHistoricalData"> | bigint | number
    endTime?: BigIntFilter<"KlineHistoricalData"> | bigint | number
    timestampIst?: StringFilter<"KlineHistoricalData"> | string
    createdAt?: DateTimeFilter<"KlineHistoricalData"> | Date | string
    createdBy?: IntFilter<"KlineHistoricalData"> | number
    updatedAt?: DateTimeFilter<"KlineHistoricalData"> | Date | string
    updatedBy?: IntFilter<"KlineHistoricalData"> | number
  }

  export type KlineHistoricalDataOrderByWithRelationInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    interval?: SortOrder
    ohlc?: SortOrder
    conversionRate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    timestampIst?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type KlineHistoricalDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KlineHistoricalDataWhereInput | KlineHistoricalDataWhereInput[]
    OR?: KlineHistoricalDataWhereInput[]
    NOT?: KlineHistoricalDataWhereInput | KlineHistoricalDataWhereInput[]
    contractSymbol?: StringFilter<"KlineHistoricalData"> | string
    displayName?: StringFilter<"KlineHistoricalData"> | string
    interval?: EnumIntervalFilter<"KlineHistoricalData"> | $Enums.Interval
    ohlc?: JsonFilter<"KlineHistoricalData">
    conversionRate?: StringFilter<"KlineHistoricalData"> | string
    startTime?: BigIntFilter<"KlineHistoricalData"> | bigint | number
    endTime?: BigIntFilter<"KlineHistoricalData"> | bigint | number
    timestampIst?: StringFilter<"KlineHistoricalData"> | string
    createdAt?: DateTimeFilter<"KlineHistoricalData"> | Date | string
    createdBy?: IntFilter<"KlineHistoricalData"> | number
    updatedAt?: DateTimeFilter<"KlineHistoricalData"> | Date | string
    updatedBy?: IntFilter<"KlineHistoricalData"> | number
  }, "id" | "id">

  export type KlineHistoricalDataOrderByWithAggregationInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    interval?: SortOrder
    ohlc?: SortOrder
    conversionRate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    timestampIst?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: KlineHistoricalDataCountOrderByAggregateInput
    _avg?: KlineHistoricalDataAvgOrderByAggregateInput
    _max?: KlineHistoricalDataMaxOrderByAggregateInput
    _min?: KlineHistoricalDataMinOrderByAggregateInput
    _sum?: KlineHistoricalDataSumOrderByAggregateInput
  }

  export type KlineHistoricalDataScalarWhereWithAggregatesInput = {
    AND?: KlineHistoricalDataScalarWhereWithAggregatesInput | KlineHistoricalDataScalarWhereWithAggregatesInput[]
    OR?: KlineHistoricalDataScalarWhereWithAggregatesInput[]
    NOT?: KlineHistoricalDataScalarWhereWithAggregatesInput | KlineHistoricalDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KlineHistoricalData"> | number
    contractSymbol?: StringWithAggregatesFilter<"KlineHistoricalData"> | string
    displayName?: StringWithAggregatesFilter<"KlineHistoricalData"> | string
    interval?: EnumIntervalWithAggregatesFilter<"KlineHistoricalData"> | $Enums.Interval
    ohlc?: JsonWithAggregatesFilter<"KlineHistoricalData">
    conversionRate?: StringWithAggregatesFilter<"KlineHistoricalData"> | string
    startTime?: BigIntWithAggregatesFilter<"KlineHistoricalData"> | bigint | number
    endTime?: BigIntWithAggregatesFilter<"KlineHistoricalData"> | bigint | number
    timestampIst?: StringWithAggregatesFilter<"KlineHistoricalData"> | string
    createdAt?: DateTimeWithAggregatesFilter<"KlineHistoricalData"> | Date | string
    createdBy?: IntWithAggregatesFilter<"KlineHistoricalData"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"KlineHistoricalData"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"KlineHistoricalData"> | number
  }

  export type UserOrderHistoryWhereInput = {
    AND?: UserOrderHistoryWhereInput | UserOrderHistoryWhereInput[]
    OR?: UserOrderHistoryWhereInput[]
    NOT?: UserOrderHistoryWhereInput | UserOrderHistoryWhereInput[]
    id?: IntFilter<"UserOrderHistory"> | number
    createdAt?: DateTimeFilter<"UserOrderHistory"> | Date | string
    createdBy?: IntFilter<"UserOrderHistory"> | number
    updatedAt?: DateTimeFilter<"UserOrderHistory"> | Date | string
    updatedBy?: IntFilter<"UserOrderHistory"> | number
  }

  export type UserOrderHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserOrderHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserOrderHistoryWhereInput | UserOrderHistoryWhereInput[]
    OR?: UserOrderHistoryWhereInput[]
    NOT?: UserOrderHistoryWhereInput | UserOrderHistoryWhereInput[]
    createdAt?: DateTimeFilter<"UserOrderHistory"> | Date | string
    createdBy?: IntFilter<"UserOrderHistory"> | number
    updatedAt?: DateTimeFilter<"UserOrderHistory"> | Date | string
    updatedBy?: IntFilter<"UserOrderHistory"> | number
  }, "id" | "id">

  export type UserOrderHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: UserOrderHistoryCountOrderByAggregateInput
    _avg?: UserOrderHistoryAvgOrderByAggregateInput
    _max?: UserOrderHistoryMaxOrderByAggregateInput
    _min?: UserOrderHistoryMinOrderByAggregateInput
    _sum?: UserOrderHistorySumOrderByAggregateInput
  }

  export type UserOrderHistoryScalarWhereWithAggregatesInput = {
    AND?: UserOrderHistoryScalarWhereWithAggregatesInput | UserOrderHistoryScalarWhereWithAggregatesInput[]
    OR?: UserOrderHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserOrderHistoryScalarWhereWithAggregatesInput | UserOrderHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserOrderHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserOrderHistory"> | Date | string
    createdBy?: IntWithAggregatesFilter<"UserOrderHistory"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"UserOrderHistory"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"UserOrderHistory"> | number
  }

  export type UserTradeHistoryWhereInput = {
    AND?: UserTradeHistoryWhereInput | UserTradeHistoryWhereInput[]
    OR?: UserTradeHistoryWhereInput[]
    NOT?: UserTradeHistoryWhereInput | UserTradeHistoryWhereInput[]
    id?: IntFilter<"UserTradeHistory"> | number
    createdAt?: DateTimeFilter<"UserTradeHistory"> | Date | string
    createdBy?: IntFilter<"UserTradeHistory"> | number
    updatedAt?: DateTimeFilter<"UserTradeHistory"> | Date | string
    updatedBy?: IntFilter<"UserTradeHistory"> | number
  }

  export type UserTradeHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserTradeHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserTradeHistoryWhereInput | UserTradeHistoryWhereInput[]
    OR?: UserTradeHistoryWhereInput[]
    NOT?: UserTradeHistoryWhereInput | UserTradeHistoryWhereInput[]
    createdAt?: DateTimeFilter<"UserTradeHistory"> | Date | string
    createdBy?: IntFilter<"UserTradeHistory"> | number
    updatedAt?: DateTimeFilter<"UserTradeHistory"> | Date | string
    updatedBy?: IntFilter<"UserTradeHistory"> | number
  }, "id" | "id">

  export type UserTradeHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: UserTradeHistoryCountOrderByAggregateInput
    _avg?: UserTradeHistoryAvgOrderByAggregateInput
    _max?: UserTradeHistoryMaxOrderByAggregateInput
    _min?: UserTradeHistoryMinOrderByAggregateInput
    _sum?: UserTradeHistorySumOrderByAggregateInput
  }

  export type UserTradeHistoryScalarWhereWithAggregatesInput = {
    AND?: UserTradeHistoryScalarWhereWithAggregatesInput | UserTradeHistoryScalarWhereWithAggregatesInput[]
    OR?: UserTradeHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserTradeHistoryScalarWhereWithAggregatesInput | UserTradeHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserTradeHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserTradeHistory"> | Date | string
    createdBy?: IntWithAggregatesFilter<"UserTradeHistory"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"UserTradeHistory"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"UserTradeHistory"> | number
  }

  export type UserPositionHistoryWhereInput = {
    AND?: UserPositionHistoryWhereInput | UserPositionHistoryWhereInput[]
    OR?: UserPositionHistoryWhereInput[]
    NOT?: UserPositionHistoryWhereInput | UserPositionHistoryWhereInput[]
    id?: IntFilter<"UserPositionHistory"> | number
    createdAt?: DateTimeFilter<"UserPositionHistory"> | Date | string
    createdBy?: IntFilter<"UserPositionHistory"> | number
    updatedAt?: DateTimeFilter<"UserPositionHistory"> | Date | string
    updatedBy?: IntFilter<"UserPositionHistory"> | number
  }

  export type UserPositionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserPositionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserPositionHistoryWhereInput | UserPositionHistoryWhereInput[]
    OR?: UserPositionHistoryWhereInput[]
    NOT?: UserPositionHistoryWhereInput | UserPositionHistoryWhereInput[]
    createdAt?: DateTimeFilter<"UserPositionHistory"> | Date | string
    createdBy?: IntFilter<"UserPositionHistory"> | number
    updatedAt?: DateTimeFilter<"UserPositionHistory"> | Date | string
    updatedBy?: IntFilter<"UserPositionHistory"> | number
  }, "id" | "id">

  export type UserPositionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: UserPositionHistoryCountOrderByAggregateInput
    _avg?: UserPositionHistoryAvgOrderByAggregateInput
    _max?: UserPositionHistoryMaxOrderByAggregateInput
    _min?: UserPositionHistoryMinOrderByAggregateInput
    _sum?: UserPositionHistorySumOrderByAggregateInput
  }

  export type UserPositionHistoryScalarWhereWithAggregatesInput = {
    AND?: UserPositionHistoryScalarWhereWithAggregatesInput | UserPositionHistoryScalarWhereWithAggregatesInput[]
    OR?: UserPositionHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserPositionHistoryScalarWhereWithAggregatesInput | UserPositionHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPositionHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserPositionHistory"> | Date | string
    createdBy?: IntWithAggregatesFilter<"UserPositionHistory"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"UserPositionHistory"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"UserPositionHistory"> | number
  }

  export type BinanceOrderHistoryWhereInput = {
    AND?: BinanceOrderHistoryWhereInput | BinanceOrderHistoryWhereInput[]
    OR?: BinanceOrderHistoryWhereInput[]
    NOT?: BinanceOrderHistoryWhereInput | BinanceOrderHistoryWhereInput[]
    id?: IntFilter<"BinanceOrderHistory"> | number
    createdAt?: DateTimeFilter<"BinanceOrderHistory"> | Date | string
    createdBy?: IntFilter<"BinanceOrderHistory"> | number
    updatedAt?: DateTimeFilter<"BinanceOrderHistory"> | Date | string
    updatedBy?: IntFilter<"BinanceOrderHistory"> | number
  }

  export type BinanceOrderHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceOrderHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BinanceOrderHistoryWhereInput | BinanceOrderHistoryWhereInput[]
    OR?: BinanceOrderHistoryWhereInput[]
    NOT?: BinanceOrderHistoryWhereInput | BinanceOrderHistoryWhereInput[]
    createdAt?: DateTimeFilter<"BinanceOrderHistory"> | Date | string
    createdBy?: IntFilter<"BinanceOrderHistory"> | number
    updatedAt?: DateTimeFilter<"BinanceOrderHistory"> | Date | string
    updatedBy?: IntFilter<"BinanceOrderHistory"> | number
  }, "id" | "id">

  export type BinanceOrderHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: BinanceOrderHistoryCountOrderByAggregateInput
    _avg?: BinanceOrderHistoryAvgOrderByAggregateInput
    _max?: BinanceOrderHistoryMaxOrderByAggregateInput
    _min?: BinanceOrderHistoryMinOrderByAggregateInput
    _sum?: BinanceOrderHistorySumOrderByAggregateInput
  }

  export type BinanceOrderHistoryScalarWhereWithAggregatesInput = {
    AND?: BinanceOrderHistoryScalarWhereWithAggregatesInput | BinanceOrderHistoryScalarWhereWithAggregatesInput[]
    OR?: BinanceOrderHistoryScalarWhereWithAggregatesInput[]
    NOT?: BinanceOrderHistoryScalarWhereWithAggregatesInput | BinanceOrderHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BinanceOrderHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BinanceOrderHistory"> | Date | string
    createdBy?: IntWithAggregatesFilter<"BinanceOrderHistory"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"BinanceOrderHistory"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"BinanceOrderHistory"> | number
  }

  export type BinanceTradeHistoryWhereInput = {
    AND?: BinanceTradeHistoryWhereInput | BinanceTradeHistoryWhereInput[]
    OR?: BinanceTradeHistoryWhereInput[]
    NOT?: BinanceTradeHistoryWhereInput | BinanceTradeHistoryWhereInput[]
    id?: IntFilter<"BinanceTradeHistory"> | number
    createdAt?: DateTimeFilter<"BinanceTradeHistory"> | Date | string
    createdBy?: IntFilter<"BinanceTradeHistory"> | number
    updatedAt?: DateTimeFilter<"BinanceTradeHistory"> | Date | string
    updatedBy?: IntFilter<"BinanceTradeHistory"> | number
  }

  export type BinanceTradeHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceTradeHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BinanceTradeHistoryWhereInput | BinanceTradeHistoryWhereInput[]
    OR?: BinanceTradeHistoryWhereInput[]
    NOT?: BinanceTradeHistoryWhereInput | BinanceTradeHistoryWhereInput[]
    createdAt?: DateTimeFilter<"BinanceTradeHistory"> | Date | string
    createdBy?: IntFilter<"BinanceTradeHistory"> | number
    updatedAt?: DateTimeFilter<"BinanceTradeHistory"> | Date | string
    updatedBy?: IntFilter<"BinanceTradeHistory"> | number
  }, "id" | "id">

  export type BinanceTradeHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: BinanceTradeHistoryCountOrderByAggregateInput
    _avg?: BinanceTradeHistoryAvgOrderByAggregateInput
    _max?: BinanceTradeHistoryMaxOrderByAggregateInput
    _min?: BinanceTradeHistoryMinOrderByAggregateInput
    _sum?: BinanceTradeHistorySumOrderByAggregateInput
  }

  export type BinanceTradeHistoryScalarWhereWithAggregatesInput = {
    AND?: BinanceTradeHistoryScalarWhereWithAggregatesInput | BinanceTradeHistoryScalarWhereWithAggregatesInput[]
    OR?: BinanceTradeHistoryScalarWhereWithAggregatesInput[]
    NOT?: BinanceTradeHistoryScalarWhereWithAggregatesInput | BinanceTradeHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BinanceTradeHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BinanceTradeHistory"> | Date | string
    createdBy?: IntWithAggregatesFilter<"BinanceTradeHistory"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"BinanceTradeHistory"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"BinanceTradeHistory"> | number
  }

  export type CoinwiseTradeRecoincilliationWhereInput = {
    AND?: CoinwiseTradeRecoincilliationWhereInput | CoinwiseTradeRecoincilliationWhereInput[]
    OR?: CoinwiseTradeRecoincilliationWhereInput[]
    NOT?: CoinwiseTradeRecoincilliationWhereInput | CoinwiseTradeRecoincilliationWhereInput[]
    id?: IntFilter<"CoinwiseTradeRecoincilliation"> | number
    createdAt?: DateTimeFilter<"CoinwiseTradeRecoincilliation"> | Date | string
    createdBy?: IntFilter<"CoinwiseTradeRecoincilliation"> | number
    updatedAt?: DateTimeFilter<"CoinwiseTradeRecoincilliation"> | Date | string
    updatedBy?: IntFilter<"CoinwiseTradeRecoincilliation"> | number
  }

  export type CoinwiseTradeRecoincilliationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwiseTradeRecoincilliationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CoinwiseTradeRecoincilliationWhereInput | CoinwiseTradeRecoincilliationWhereInput[]
    OR?: CoinwiseTradeRecoincilliationWhereInput[]
    NOT?: CoinwiseTradeRecoincilliationWhereInput | CoinwiseTradeRecoincilliationWhereInput[]
    createdAt?: DateTimeFilter<"CoinwiseTradeRecoincilliation"> | Date | string
    createdBy?: IntFilter<"CoinwiseTradeRecoincilliation"> | number
    updatedAt?: DateTimeFilter<"CoinwiseTradeRecoincilliation"> | Date | string
    updatedBy?: IntFilter<"CoinwiseTradeRecoincilliation"> | number
  }, "id" | "id">

  export type CoinwiseTradeRecoincilliationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: CoinwiseTradeRecoincilliationCountOrderByAggregateInput
    _avg?: CoinwiseTradeRecoincilliationAvgOrderByAggregateInput
    _max?: CoinwiseTradeRecoincilliationMaxOrderByAggregateInput
    _min?: CoinwiseTradeRecoincilliationMinOrderByAggregateInput
    _sum?: CoinwiseTradeRecoincilliationSumOrderByAggregateInput
  }

  export type CoinwiseTradeRecoincilliationScalarWhereWithAggregatesInput = {
    AND?: CoinwiseTradeRecoincilliationScalarWhereWithAggregatesInput | CoinwiseTradeRecoincilliationScalarWhereWithAggregatesInput[]
    OR?: CoinwiseTradeRecoincilliationScalarWhereWithAggregatesInput[]
    NOT?: CoinwiseTradeRecoincilliationScalarWhereWithAggregatesInput | CoinwiseTradeRecoincilliationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CoinwiseTradeRecoincilliation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CoinwiseTradeRecoincilliation"> | Date | string
    createdBy?: IntWithAggregatesFilter<"CoinwiseTradeRecoincilliation"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CoinwiseTradeRecoincilliation"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"CoinwiseTradeRecoincilliation"> | number
  }

  export type CoinwisePositionRecoincilliationWhereInput = {
    AND?: CoinwisePositionRecoincilliationWhereInput | CoinwisePositionRecoincilliationWhereInput[]
    OR?: CoinwisePositionRecoincilliationWhereInput[]
    NOT?: CoinwisePositionRecoincilliationWhereInput | CoinwisePositionRecoincilliationWhereInput[]
    id?: IntFilter<"CoinwisePositionRecoincilliation"> | number
    createdAt?: DateTimeFilter<"CoinwisePositionRecoincilliation"> | Date | string
    createdBy?: IntFilter<"CoinwisePositionRecoincilliation"> | number
    updatedAt?: DateTimeFilter<"CoinwisePositionRecoincilliation"> | Date | string
    updatedBy?: IntFilter<"CoinwisePositionRecoincilliation"> | number
  }

  export type CoinwisePositionRecoincilliationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwisePositionRecoincilliationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CoinwisePositionRecoincilliationWhereInput | CoinwisePositionRecoincilliationWhereInput[]
    OR?: CoinwisePositionRecoincilliationWhereInput[]
    NOT?: CoinwisePositionRecoincilliationWhereInput | CoinwisePositionRecoincilliationWhereInput[]
    createdAt?: DateTimeFilter<"CoinwisePositionRecoincilliation"> | Date | string
    createdBy?: IntFilter<"CoinwisePositionRecoincilliation"> | number
    updatedAt?: DateTimeFilter<"CoinwisePositionRecoincilliation"> | Date | string
    updatedBy?: IntFilter<"CoinwisePositionRecoincilliation"> | number
  }, "id" | "id">

  export type CoinwisePositionRecoincilliationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: CoinwisePositionRecoincilliationCountOrderByAggregateInput
    _avg?: CoinwisePositionRecoincilliationAvgOrderByAggregateInput
    _max?: CoinwisePositionRecoincilliationMaxOrderByAggregateInput
    _min?: CoinwisePositionRecoincilliationMinOrderByAggregateInput
    _sum?: CoinwisePositionRecoincilliationSumOrderByAggregateInput
  }

  export type CoinwisePositionRecoincilliationScalarWhereWithAggregatesInput = {
    AND?: CoinwisePositionRecoincilliationScalarWhereWithAggregatesInput | CoinwisePositionRecoincilliationScalarWhereWithAggregatesInput[]
    OR?: CoinwisePositionRecoincilliationScalarWhereWithAggregatesInput[]
    NOT?: CoinwisePositionRecoincilliationScalarWhereWithAggregatesInput | CoinwisePositionRecoincilliationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CoinwisePositionRecoincilliation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CoinwisePositionRecoincilliation"> | Date | string
    createdBy?: IntWithAggregatesFilter<"CoinwisePositionRecoincilliation"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CoinwisePositionRecoincilliation"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"CoinwisePositionRecoincilliation"> | number
  }

  export type InvoicesWhereInput = {
    AND?: InvoicesWhereInput | InvoicesWhereInput[]
    OR?: InvoicesWhereInput[]
    NOT?: InvoicesWhereInput | InvoicesWhereInput[]
    id?: IntFilter<"Invoices"> | number
    createdAt?: DateTimeFilter<"Invoices"> | Date | string
    createdBy?: IntFilter<"Invoices"> | number
    updatedAt?: DateTimeFilter<"Invoices"> | Date | string
    updatedBy?: IntFilter<"Invoices"> | number
  }

  export type InvoicesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoicesWhereInput | InvoicesWhereInput[]
    OR?: InvoicesWhereInput[]
    NOT?: InvoicesWhereInput | InvoicesWhereInput[]
    createdAt?: DateTimeFilter<"Invoices"> | Date | string
    createdBy?: IntFilter<"Invoices"> | number
    updatedAt?: DateTimeFilter<"Invoices"> | Date | string
    updatedBy?: IntFilter<"Invoices"> | number
  }, "id" | "id">

  export type InvoicesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: InvoicesCountOrderByAggregateInput
    _avg?: InvoicesAvgOrderByAggregateInput
    _max?: InvoicesMaxOrderByAggregateInput
    _min?: InvoicesMinOrderByAggregateInput
    _sum?: InvoicesSumOrderByAggregateInput
  }

  export type InvoicesScalarWhereWithAggregatesInput = {
    AND?: InvoicesScalarWhereWithAggregatesInput | InvoicesScalarWhereWithAggregatesInput[]
    OR?: InvoicesScalarWhereWithAggregatesInput[]
    NOT?: InvoicesScalarWhereWithAggregatesInput | InvoicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoices"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Invoices"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Invoices"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Invoices"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"Invoices"> | number
  }

  export type ReportsWhereInput = {
    AND?: ReportsWhereInput | ReportsWhereInput[]
    OR?: ReportsWhereInput[]
    NOT?: ReportsWhereInput | ReportsWhereInput[]
    id?: IntFilter<"Reports"> | number
    createdAt?: DateTimeFilter<"Reports"> | Date | string
    createdBy?: IntFilter<"Reports"> | number
    updatedAt?: DateTimeFilter<"Reports"> | Date | string
    updatedBy?: IntFilter<"Reports"> | number
  }

  export type ReportsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ReportsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportsWhereInput | ReportsWhereInput[]
    OR?: ReportsWhereInput[]
    NOT?: ReportsWhereInput | ReportsWhereInput[]
    createdAt?: DateTimeFilter<"Reports"> | Date | string
    createdBy?: IntFilter<"Reports"> | number
    updatedAt?: DateTimeFilter<"Reports"> | Date | string
    updatedBy?: IntFilter<"Reports"> | number
  }, "id" | "id">

  export type ReportsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ReportsCountOrderByAggregateInput
    _avg?: ReportsAvgOrderByAggregateInput
    _max?: ReportsMaxOrderByAggregateInput
    _min?: ReportsMinOrderByAggregateInput
    _sum?: ReportsSumOrderByAggregateInput
  }

  export type ReportsScalarWhereWithAggregatesInput = {
    AND?: ReportsScalarWhereWithAggregatesInput | ReportsScalarWhereWithAggregatesInput[]
    OR?: ReportsScalarWhereWithAggregatesInput[]
    NOT?: ReportsScalarWhereWithAggregatesInput | ReportsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reports"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Reports"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Reports"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Reports"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"Reports"> | number
  }

  export type UserAccountCreateInput = {
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel: UserCreateNestedOneWithoutUserAccountRelInput
    InrLedgerRel?: InrLedgerCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUncheckedCreateInput = {
    id?: number
    userId: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    InrLedgerRel?: InrLedgerUncheckedCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerUncheckedCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerUncheckedCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletUncheckedCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletUncheckedCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUpdateInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUpdateOneRequiredWithoutUserAccountRelNestedInput
    InrLedgerRel?: InrLedgerUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    InrLedgerRel?: InrLedgerUncheckedUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUncheckedUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUncheckedUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUncheckedUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUncheckedUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountCreateManyInput = {
    id?: number
    userId: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type UserAccountUpdateManyMutationInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserKycRel?: UserKycCreateNestedOneWithoutUserRelInput
    BankDetailRel?: UserBankDetailsCreateNestedOneWithoutUserRelInput
    UserBankDetailsRel?: UserBankDetailsCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    kycId?: number | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    bankDetailsId?: number | null
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountUncheckedCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFAUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserKycRel?: UserKycUpdateOneWithoutUserRelNestedInput
    BankDetailRel?: UserBankDetailsUpdateOneWithoutUserRelNestedInput
    UserBankDetailsRel?: UserBankDetailsUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    kycId?: NullableIntFieldUpdateOperationsInput | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    bankDetailsId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUncheckedUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    kycId?: number | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    bankDetailsId?: number | null
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type UserUpdateManyMutationInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    kycId?: NullableIntFieldUpdateOperationsInput | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    bankDetailsId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DepositWithdrawLimitsCreateInput = {
    userType?: $Enums.UserType
    fiatDepositLimit: number
    fiatWithdrawLimit: number
    cryptoDepositLimit?: number | null
    cryptoWithdrawLimit?: number | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type DepositWithdrawLimitsUncheckedCreateInput = {
    id?: number
    userType?: $Enums.UserType
    fiatDepositLimit: number
    fiatWithdrawLimit: number
    cryptoDepositLimit?: number | null
    cryptoWithdrawLimit?: number | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type DepositWithdrawLimitsUpdateInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fiatDepositLimit?: FloatFieldUpdateOperationsInput | number
    fiatWithdrawLimit?: FloatFieldUpdateOperationsInput | number
    cryptoDepositLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    cryptoWithdrawLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DepositWithdrawLimitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fiatDepositLimit?: FloatFieldUpdateOperationsInput | number
    fiatWithdrawLimit?: FloatFieldUpdateOperationsInput | number
    cryptoDepositLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    cryptoWithdrawLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DepositWithdrawLimitsCreateManyInput = {
    id?: number
    userType?: $Enums.UserType
    fiatDepositLimit: number
    fiatWithdrawLimit: number
    cryptoDepositLimit?: number | null
    cryptoWithdrawLimit?: number | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type DepositWithdrawLimitsUpdateManyMutationInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fiatDepositLimit?: FloatFieldUpdateOperationsInput | number
    fiatWithdrawLimit?: FloatFieldUpdateOperationsInput | number
    cryptoDepositLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    cryptoWithdrawLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DepositWithdrawLimitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fiatDepositLimit?: FloatFieldUpdateOperationsInput | number
    fiatWithdrawLimit?: FloatFieldUpdateOperationsInput | number
    cryptoDepositLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    cryptoWithdrawLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TwoFACreateInput = {
    email: string
    phone?: string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    status?: $Enums.TwoFAStatus
    reason: $Enums.Reason
    expiryTime: number
    mobileVerifiedAtleastOnce: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    User: UserCreateNestedOneWithoutTwoFARelInput
  }

  export type TwoFAUncheckedCreateInput = {
    id?: number
    userId: number
    email: string
    phone?: string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    status?: $Enums.TwoFAStatus
    reason: $Enums.Reason
    expiryTime: number
    mobileVerifiedAtleastOnce: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type TwoFAUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTwoFAStatusFieldUpdateOperationsInput | $Enums.TwoFAStatus
    reason?: EnumReasonFieldUpdateOperationsInput | $Enums.Reason
    expiryTime?: IntFieldUpdateOperationsInput | number
    mobileVerifiedAtleastOnce?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutTwoFARelNestedInput
  }

  export type TwoFAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTwoFAStatusFieldUpdateOperationsInput | $Enums.TwoFAStatus
    reason?: EnumReasonFieldUpdateOperationsInput | $Enums.Reason
    expiryTime?: IntFieldUpdateOperationsInput | number
    mobileVerifiedAtleastOnce?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TwoFACreateManyInput = {
    id?: number
    userId: number
    email: string
    phone?: string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    status?: $Enums.TwoFAStatus
    reason: $Enums.Reason
    expiryTime: number
    mobileVerifiedAtleastOnce: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type TwoFAUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTwoFAStatusFieldUpdateOperationsInput | $Enums.TwoFAStatus
    reason?: EnumReasonFieldUpdateOperationsInput | $Enums.Reason
    expiryTime?: IntFieldUpdateOperationsInput | number
    mobileVerifiedAtleastOnce?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TwoFAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTwoFAStatusFieldUpdateOperationsInput | $Enums.TwoFAStatus
    reason?: EnumReasonFieldUpdateOperationsInput | $Enums.Reason
    expiryTime?: IntFieldUpdateOperationsInput | number
    mobileVerifiedAtleastOnce?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserKycCreateInput = {
    fullName?: string | null
    gender?: $Enums.Gender | null
    dob?: string | null
    address?: string | null
    fatherName?: string | null
    kycType: $Enums.KycType
    kycStatus?: $Enums.UserKycStatus
    hyperVergeStatus?: $Enums.HypervergeStatus | null
    panStatus?: $Enums.UserKycStatus
    aadharFrontStatus?: $Enums.UserKycStatus
    aadharBackStatus?: $Enums.UserKycStatus
    selfieStatus?: $Enums.UserKycStatus
    aadharPanNameMatchStatus?: $Enums.UserKycStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    EncryptedUserDataRel?: EncryptedUserDataCreateNestedOneWithoutUserKycInput
    UserRel?: UserCreateNestedOneWithoutUserKycRelInput
  }

  export type UserKycUncheckedCreateInput = {
    id?: number
    encryptedUserDataId?: number | null
    fullName?: string | null
    gender?: $Enums.Gender | null
    dob?: string | null
    address?: string | null
    fatherName?: string | null
    kycType: $Enums.KycType
    kycStatus?: $Enums.UserKycStatus
    hyperVergeStatus?: $Enums.HypervergeStatus | null
    panStatus?: $Enums.UserKycStatus
    aadharFrontStatus?: $Enums.UserKycStatus
    aadharBackStatus?: $Enums.UserKycStatus
    selfieStatus?: $Enums.UserKycStatus
    aadharPanNameMatchStatus?: $Enums.UserKycStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel?: UserUncheckedCreateNestedOneWithoutUserKycRelInput
  }

  export type UserKycUpdateInput = {
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    kycType?: EnumKycTypeFieldUpdateOperationsInput | $Enums.KycType
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    hyperVergeStatus?: NullableEnumHypervergeStatusFieldUpdateOperationsInput | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    EncryptedUserDataRel?: EncryptedUserDataUpdateOneWithoutUserKycNestedInput
    UserRel?: UserUpdateOneWithoutUserKycRelNestedInput
  }

  export type UserKycUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encryptedUserDataId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    kycType?: EnumKycTypeFieldUpdateOperationsInput | $Enums.KycType
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    hyperVergeStatus?: NullableEnumHypervergeStatusFieldUpdateOperationsInput | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUncheckedUpdateOneWithoutUserKycRelNestedInput
  }

  export type UserKycCreateManyInput = {
    id?: number
    encryptedUserDataId?: number | null
    fullName?: string | null
    gender?: $Enums.Gender | null
    dob?: string | null
    address?: string | null
    fatherName?: string | null
    kycType: $Enums.KycType
    kycStatus?: $Enums.UserKycStatus
    hyperVergeStatus?: $Enums.HypervergeStatus | null
    panStatus?: $Enums.UserKycStatus
    aadharFrontStatus?: $Enums.UserKycStatus
    aadharBackStatus?: $Enums.UserKycStatus
    selfieStatus?: $Enums.UserKycStatus
    aadharPanNameMatchStatus?: $Enums.UserKycStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type UserKycUpdateManyMutationInput = {
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    kycType?: EnumKycTypeFieldUpdateOperationsInput | $Enums.KycType
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    hyperVergeStatus?: NullableEnumHypervergeStatusFieldUpdateOperationsInput | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserKycUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encryptedUserDataId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    kycType?: EnumKycTypeFieldUpdateOperationsInput | $Enums.KycType
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    hyperVergeStatus?: NullableEnumHypervergeStatusFieldUpdateOperationsInput | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EncryptedUserDataCreateInput = {
    panNumber?: string | null
    aadharNumber?: string | null
    userId: number
    fileKey?: string | null
    bucketName?: string | null
    initVector?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserKyc?: UserKycCreateNestedOneWithoutEncryptedUserDataRelInput
  }

  export type EncryptedUserDataUncheckedCreateInput = {
    id?: number
    panNumber?: string | null
    aadharNumber?: string | null
    userId: number
    fileKey?: string | null
    bucketName?: string | null
    initVector?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserKyc?: UserKycUncheckedCreateNestedOneWithoutEncryptedUserDataRelInput
  }

  export type EncryptedUserDataUpdateInput = {
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserKyc?: UserKycUpdateOneWithoutEncryptedUserDataRelNestedInput
  }

  export type EncryptedUserDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserKyc?: UserKycUncheckedUpdateOneWithoutEncryptedUserDataRelNestedInput
  }

  export type EncryptedUserDataCreateManyInput = {
    id?: number
    panNumber?: string | null
    aadharNumber?: string | null
    userId: number
    fileKey?: string | null
    bucketName?: string | null
    initVector?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type EncryptedUserDataUpdateManyMutationInput = {
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EncryptedUserDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserBankDetailsCreateInput = {
    bankDetailsType?: $Enums.BankDetailsType
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    userRel?: UserCreateNestedOneWithoutUserBankDetailsRelInput
    UserBankRel?: FiatPaymentsCreateNestedManyWithoutUserBankRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutSystemBankRelInput
    UserRel?: UserCreateNestedManyWithoutBankDetailRelInput
  }

  export type UserBankDetailsUncheckedCreateInput = {
    id?: number
    bankDetailsType?: $Enums.BankDetailsType
    userId?: number | null
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserBankRelInput
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutSystemBankRelInput
    UserRel?: UserUncheckedCreateNestedManyWithoutBankDetailRelInput
  }

  export type UserBankDetailsUpdateInput = {
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    userRel?: UserUpdateOneWithoutUserBankDetailsRelNestedInput
    UserBankRel?: FiatPaymentsUpdateManyWithoutUserBankRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutSystemBankRelNestedInput
    UserRel?: UserUpdateManyWithoutBankDetailRelNestedInput
  }

  export type UserBankDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankRel?: FiatPaymentsUncheckedUpdateManyWithoutUserBankRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutSystemBankRelNestedInput
    UserRel?: UserUncheckedUpdateManyWithoutBankDetailRelNestedInput
  }

  export type UserBankDetailsCreateManyInput = {
    id?: number
    bankDetailsType?: $Enums.BankDetailsType
    userId?: number | null
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type UserBankDetailsUpdateManyMutationInput = {
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserBankDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FiatPaymentsCreateInput = {
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    user?: UserCreateNestedOneWithoutFiatPaymentsRelInput
    systemBankRel?: UserBankDetailsCreateNestedOneWithoutFiatPaymentsRelInput
    userBankRel?: UserBankDetailsCreateNestedOneWithoutUserBankRelInput
    BankFeedRel?: BankFeedCreateNestedOneWithoutFiatPaymentInput
  }

  export type FiatPaymentsUncheckedCreateInput = {
    id?: number
    userId: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemBankId: number
    userBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    BankFeedRel?: BankFeedUncheckedCreateNestedOneWithoutFiatPaymentInput
  }

  export type FiatPaymentsUpdateInput = {
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutFiatPaymentsRelNestedInput
    systemBankRel?: UserBankDetailsUpdateOneWithoutFiatPaymentsRelNestedInput
    userBankRel?: UserBankDetailsUpdateOneWithoutUserBankRelNestedInput
    BankFeedRel?: BankFeedUpdateOneWithoutFiatPaymentNestedInput
  }

  export type FiatPaymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemBankId?: IntFieldUpdateOperationsInput | number
    userBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    BankFeedRel?: BankFeedUncheckedUpdateOneWithoutFiatPaymentNestedInput
  }

  export type FiatPaymentsCreateManyInput = {
    id?: number
    userId: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemBankId: number
    userBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type FiatPaymentsUpdateManyMutationInput = {
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type FiatPaymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemBankId?: IntFieldUpdateOperationsInput | number
    userBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoDepositCreateInput = {
    accountId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee?: string | null
    effectiveChange?: string | null
    runningBalance?: string | null
    externalAddress?: string | null
    effectiveChangeUsd?: string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: string | null
    explorerLink?: string | null
    inputs?: CryptoDepositCreateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositCreateoutputsInput | InputJsonValue[]
    sequenceId?: string | null
    type?: string | null
    conversionRate?: string | null
    isConverted?: boolean | null
    conversionTimestamp?: Date | string | null
    inrCreditStatus?: $Enums.InrCreditStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    cryptoWallet?: CryptoWalletCreateNestedOneWithoutCryptoDepositInput
    inrConvHistRel?: InrConversionHistoryCreateNestedManyWithoutCryptoDepositInput
  }

  export type CryptoDepositUncheckedCreateInput = {
    id?: number
    accountId: number
    cryptoWalletId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee?: string | null
    effectiveChange?: string | null
    runningBalance?: string | null
    externalAddress?: string | null
    effectiveChangeUsd?: string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: string | null
    explorerLink?: string | null
    inputs?: CryptoDepositCreateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositCreateoutputsInput | InputJsonValue[]
    sequenceId?: string | null
    type?: string | null
    conversionRate?: string | null
    isConverted?: boolean | null
    conversionTimestamp?: Date | string | null
    inrCreditStatus?: $Enums.InrCreditStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    inrConvHistRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutCryptoDepositInput
  }

  export type CryptoDepositUpdateInput = {
    accountId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    cryptoWallet?: CryptoWalletUpdateOneWithoutCryptoDepositNestedInput
    inrConvHistRel?: InrConversionHistoryUpdateManyWithoutCryptoDepositNestedInput
  }

  export type CryptoDepositUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    cryptoWalletId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    inrConvHistRel?: InrConversionHistoryUncheckedUpdateManyWithoutCryptoDepositNestedInput
  }

  export type CryptoDepositCreateManyInput = {
    id?: number
    accountId: number
    cryptoWalletId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee?: string | null
    effectiveChange?: string | null
    runningBalance?: string | null
    externalAddress?: string | null
    effectiveChangeUsd?: string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: string | null
    explorerLink?: string | null
    inputs?: CryptoDepositCreateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositCreateoutputsInput | InputJsonValue[]
    sequenceId?: string | null
    type?: string | null
    conversionRate?: string | null
    isConverted?: boolean | null
    conversionTimestamp?: Date | string | null
    inrCreditStatus?: $Enums.InrCreditStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoDepositUpdateManyMutationInput = {
    accountId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoDepositUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    cryptoWalletId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrConversionHistoryCreateInput = {
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    cryptoDeposit?: CryptoDepositCreateNestedOneWithoutInrConvHistRelInput
    account: UserAccountCreateNestedOneWithoutInrConvRelInput
  }

  export type InrConversionHistoryUncheckedCreateInput = {
    id?: number
    cryptoDepositId?: number | null
    accountId: number
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrConversionHistoryUpdateInput = {
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    cryptoDeposit?: CryptoDepositUpdateOneWithoutInrConvHistRelNestedInput
    account?: UserAccountUpdateOneRequiredWithoutInrConvRelNestedInput
  }

  export type InrConversionHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cryptoDepositId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrConversionHistoryCreateManyInput = {
    id?: number
    cryptoDepositId?: number | null
    accountId: number
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrConversionHistoryUpdateManyMutationInput = {
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrConversionHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cryptoDepositId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BankFeedCreateInput = {
    serialNumber: number
    amount: string
    fee: string
    bankName: string
    bankRefId: string
    processStatus: $Enums.ProcessStatus
    userRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    fiatPayment?: FiatPaymentsCreateNestedOneWithoutBankFeedRelInput
  }

  export type BankFeedUncheckedCreateInput = {
    id?: number
    paymentId?: number | null
    serialNumber: number
    amount: string
    fee: string
    bankName: string
    bankRefId: string
    processStatus: $Enums.ProcessStatus
    userRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BankFeedUpdateInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    amount?: StringFieldUpdateOperationsInput | string
    fee?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankRefId?: StringFieldUpdateOperationsInput | string
    processStatus?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    fiatPayment?: FiatPaymentsUpdateOneWithoutBankFeedRelNestedInput
  }

  export type BankFeedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    amount?: StringFieldUpdateOperationsInput | string
    fee?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankRefId?: StringFieldUpdateOperationsInput | string
    processStatus?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BankFeedCreateManyInput = {
    id?: number
    paymentId?: number | null
    serialNumber: number
    amount: string
    fee: string
    bankName: string
    bankRefId: string
    processStatus: $Enums.ProcessStatus
    userRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BankFeedUpdateManyMutationInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    amount?: StringFieldUpdateOperationsInput | string
    fee?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankRefId?: StringFieldUpdateOperationsInput | string
    processStatus?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BankFeedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    amount?: StringFieldUpdateOperationsInput | string
    fee?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankRefId?: StringFieldUpdateOperationsInput | string
    processStatus?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrLedgerCreateInput = {
    change: number
    operation: $Enums.InrOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    account?: UserAccountCreateNestedOneWithoutInrLedgerRelInput
  }

  export type InrLedgerUncheckedCreateInput = {
    id?: number
    accountId: number
    change: number
    operation: $Enums.InrOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrLedgerUpdateInput = {
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumInrOperationFieldUpdateOperationsInput | $Enums.InrOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    account?: UserAccountUpdateOneWithoutInrLedgerRelNestedInput
  }

  export type InrLedgerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumInrOperationFieldUpdateOperationsInput | $Enums.InrOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrLedgerCreateManyInput = {
    id?: number
    accountId: number
    change: number
    operation: $Enums.InrOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrLedgerUpdateManyMutationInput = {
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumInrOperationFieldUpdateOperationsInput | $Enums.InrOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrLedgerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumInrOperationFieldUpdateOperationsInput | $Enums.InrOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoLedgerCreateInput = {
    coin: string
    change: number
    operation: $Enums.CryptoOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    account?: UserAccountCreateNestedOneWithoutCryptoLedgerRelInput
  }

  export type CryptoLedgerUncheckedCreateInput = {
    id?: number
    accountId: number
    coin: string
    change: number
    operation: $Enums.CryptoOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoLedgerUpdateInput = {
    coin?: StringFieldUpdateOperationsInput | string
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumCryptoOperationFieldUpdateOperationsInput | $Enums.CryptoOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    account?: UserAccountUpdateOneWithoutCryptoLedgerRelNestedInput
  }

  export type CryptoLedgerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    coin?: StringFieldUpdateOperationsInput | string
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumCryptoOperationFieldUpdateOperationsInput | $Enums.CryptoOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoLedgerCreateManyInput = {
    id?: number
    accountId: number
    coin: string
    change: number
    operation: $Enums.CryptoOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoLedgerUpdateManyMutationInput = {
    coin?: StringFieldUpdateOperationsInput | string
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumCryptoOperationFieldUpdateOperationsInput | $Enums.CryptoOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoLedgerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    coin?: StringFieldUpdateOperationsInput | string
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumCryptoOperationFieldUpdateOperationsInput | $Enums.CryptoOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type TradeLedgerCreateInput = {
    change: string
    tradeId: string
    positionType: $Enums.PositionType
    operation: $Enums.TradeOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    account?: UserAccountCreateNestedOneWithoutTradeLedgerRelInput
  }

  export type TradeLedgerUncheckedCreateInput = {
    id?: number
    accountId: number
    change: string
    tradeId: string
    positionType: $Enums.PositionType
    operation: $Enums.TradeOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type TradeLedgerUpdateInput = {
    change?: StringFieldUpdateOperationsInput | string
    tradeId?: StringFieldUpdateOperationsInput | string
    positionType?: EnumPositionTypeFieldUpdateOperationsInput | $Enums.PositionType
    operation?: EnumTradeOperationFieldUpdateOperationsInput | $Enums.TradeOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    account?: UserAccountUpdateOneWithoutTradeLedgerRelNestedInput
  }

  export type TradeLedgerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    change?: StringFieldUpdateOperationsInput | string
    tradeId?: StringFieldUpdateOperationsInput | string
    positionType?: EnumPositionTypeFieldUpdateOperationsInput | $Enums.PositionType
    operation?: EnumTradeOperationFieldUpdateOperationsInput | $Enums.TradeOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type TradeLedgerCreateManyInput = {
    id?: number
    accountId: number
    change: string
    tradeId: string
    positionType: $Enums.PositionType
    operation: $Enums.TradeOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type TradeLedgerUpdateManyMutationInput = {
    change?: StringFieldUpdateOperationsInput | string
    tradeId?: StringFieldUpdateOperationsInput | string
    positionType?: EnumPositionTypeFieldUpdateOperationsInput | $Enums.PositionType
    operation?: EnumTradeOperationFieldUpdateOperationsInput | $Enums.TradeOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type TradeLedgerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    change?: StringFieldUpdateOperationsInput | string
    tradeId?: StringFieldUpdateOperationsInput | string
    positionType?: EnumPositionTypeFieldUpdateOperationsInput | $Enums.PositionType
    operation?: EnumTradeOperationFieldUpdateOperationsInput | $Enums.TradeOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SystemConfigForDashboardCreateInput = {
    parameterGroup?: $Enums.ParameterGroup
    parameterName: string
    parameterType: $Enums.ParamType
    isRanged: boolean
    parameterValue?: string | null
    symbol?: string | null
    rangeStart?: string | null
    rangeEnd?: string | null
    roleBasedAccess: boolean
    role: $Enums.Role
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type SystemConfigForDashboardUncheckedCreateInput = {
    id?: number
    parameterGroup?: $Enums.ParameterGroup
    parameterName: string
    parameterType: $Enums.ParamType
    isRanged: boolean
    parameterValue?: string | null
    symbol?: string | null
    rangeStart?: string | null
    rangeEnd?: string | null
    roleBasedAccess: boolean
    role: $Enums.Role
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type SystemConfigForDashboardUpdateInput = {
    parameterGroup?: EnumParameterGroupFieldUpdateOperationsInput | $Enums.ParameterGroup
    parameterName?: StringFieldUpdateOperationsInput | string
    parameterType?: EnumParamTypeFieldUpdateOperationsInput | $Enums.ParamType
    isRanged?: BoolFieldUpdateOperationsInput | boolean
    parameterValue?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    rangeStart?: NullableStringFieldUpdateOperationsInput | string | null
    rangeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    roleBasedAccess?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SystemConfigForDashboardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parameterGroup?: EnumParameterGroupFieldUpdateOperationsInput | $Enums.ParameterGroup
    parameterName?: StringFieldUpdateOperationsInput | string
    parameterType?: EnumParamTypeFieldUpdateOperationsInput | $Enums.ParamType
    isRanged?: BoolFieldUpdateOperationsInput | boolean
    parameterValue?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    rangeStart?: NullableStringFieldUpdateOperationsInput | string | null
    rangeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    roleBasedAccess?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SystemConfigForDashboardCreateManyInput = {
    id?: number
    parameterGroup?: $Enums.ParameterGroup
    parameterName: string
    parameterType: $Enums.ParamType
    isRanged: boolean
    parameterValue?: string | null
    symbol?: string | null
    rangeStart?: string | null
    rangeEnd?: string | null
    roleBasedAccess: boolean
    role: $Enums.Role
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type SystemConfigForDashboardUpdateManyMutationInput = {
    parameterGroup?: EnumParameterGroupFieldUpdateOperationsInput | $Enums.ParameterGroup
    parameterName?: StringFieldUpdateOperationsInput | string
    parameterType?: EnumParamTypeFieldUpdateOperationsInput | $Enums.ParamType
    isRanged?: BoolFieldUpdateOperationsInput | boolean
    parameterValue?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    rangeStart?: NullableStringFieldUpdateOperationsInput | string | null
    rangeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    roleBasedAccess?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SystemConfigForDashboardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parameterGroup?: EnumParameterGroupFieldUpdateOperationsInput | $Enums.ParameterGroup
    parameterName?: StringFieldUpdateOperationsInput | string
    parameterType?: EnumParamTypeFieldUpdateOperationsInput | $Enums.ParamType
    isRanged?: BoolFieldUpdateOperationsInput | boolean
    parameterValue?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    rangeStart?: NullableStringFieldUpdateOperationsInput | string | null
    rangeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    roleBasedAccess?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SystemConfigChangeLogCreateInput = {
    timestamp: Date | string
    userId: number
    parameterName: string
    parameterValue?: string | null
    isRanged: boolean
    rangeStart?: string | null
    rangeEnd?: string | null
    userType: string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type SystemConfigChangeLogUncheckedCreateInput = {
    id?: number
    timestamp: Date | string
    userId: number
    parameterName: string
    parameterValue?: string | null
    isRanged: boolean
    rangeStart?: string | null
    rangeEnd?: string | null
    userType: string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type SystemConfigChangeLogUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    parameterName?: StringFieldUpdateOperationsInput | string
    parameterValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRanged?: BoolFieldUpdateOperationsInput | boolean
    rangeStart?: NullableStringFieldUpdateOperationsInput | string | null
    rangeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SystemConfigChangeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    parameterName?: StringFieldUpdateOperationsInput | string
    parameterValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRanged?: BoolFieldUpdateOperationsInput | boolean
    rangeStart?: NullableStringFieldUpdateOperationsInput | string | null
    rangeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SystemConfigChangeLogCreateManyInput = {
    id?: number
    timestamp: Date | string
    userId: number
    parameterName: string
    parameterValue?: string | null
    isRanged: boolean
    rangeStart?: string | null
    rangeEnd?: string | null
    userType: string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type SystemConfigChangeLogUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    parameterName?: StringFieldUpdateOperationsInput | string
    parameterValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRanged?: BoolFieldUpdateOperationsInput | boolean
    rangeStart?: NullableStringFieldUpdateOperationsInput | string | null
    rangeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SystemConfigChangeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    parameterName?: StringFieldUpdateOperationsInput | string
    parameterValue?: NullableStringFieldUpdateOperationsInput | string | null
    isRanged?: BoolFieldUpdateOperationsInput | boolean
    rangeStart?: NullableStringFieldUpdateOperationsInput | string | null
    rangeEnd?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrWalletCreateInput = {
    walletBalance?: number
    amountAvailable?: number
    amountLocked?: number
    unrealizedPnl?: number
    last24hourChange?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    Account?: UserAccountCreateNestedOneWithoutInrWalletRelInput
  }

  export type InrWalletUncheckedCreateInput = {
    id?: number
    accountId: number
    walletBalance?: number
    amountAvailable?: number
    amountLocked?: number
    unrealizedPnl?: number
    last24hourChange?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrWalletUpdateInput = {
    walletBalance?: FloatFieldUpdateOperationsInput | number
    amountAvailable?: FloatFieldUpdateOperationsInput | number
    amountLocked?: FloatFieldUpdateOperationsInput | number
    unrealizedPnl?: FloatFieldUpdateOperationsInput | number
    last24hourChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    Account?: UserAccountUpdateOneWithoutInrWalletRelNestedInput
  }

  export type InrWalletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    walletBalance?: FloatFieldUpdateOperationsInput | number
    amountAvailable?: FloatFieldUpdateOperationsInput | number
    amountLocked?: FloatFieldUpdateOperationsInput | number
    unrealizedPnl?: FloatFieldUpdateOperationsInput | number
    last24hourChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrWalletCreateManyInput = {
    id?: number
    accountId: number
    walletBalance?: number
    amountAvailable?: number
    amountLocked?: number
    unrealizedPnl?: number
    last24hourChange?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrWalletUpdateManyMutationInput = {
    walletBalance?: FloatFieldUpdateOperationsInput | number
    amountAvailable?: FloatFieldUpdateOperationsInput | number
    amountLocked?: FloatFieldUpdateOperationsInput | number
    unrealizedPnl?: FloatFieldUpdateOperationsInput | number
    last24hourChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrWalletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    walletBalance?: FloatFieldUpdateOperationsInput | number
    amountAvailable?: FloatFieldUpdateOperationsInput | number
    amountLocked?: FloatFieldUpdateOperationsInput | number
    unrealizedPnl?: FloatFieldUpdateOperationsInput | number
    last24hourChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ParentWalletCreateInput = {
    walletId: number
    walletAddress: string
    chain: string
    coin: string
    parentChain: string
    type: string
    subType: $Enums.ParentWalletType
    lastUsedIndex: number
    displayName?: string | null
    toBeDisplayed?: boolean
    parentChainIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childCryptoWallet?: CryptoWalletCreateNestedManyWithoutParentWalletInput
    parentWallet?: StableCoinCreateNestedManyWithoutParentWalletInput
  }

  export type ParentWalletUncheckedCreateInput = {
    id?: number
    walletId: number
    walletAddress: string
    chain: string
    coin: string
    parentChain: string
    type: string
    subType: $Enums.ParentWalletType
    lastUsedIndex: number
    displayName?: string | null
    toBeDisplayed?: boolean
    parentChainIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childCryptoWallet?: CryptoWalletUncheckedCreateNestedManyWithoutParentWalletInput
    parentWallet?: StableCoinUncheckedCreateNestedManyWithoutParentWalletInput
  }

  export type ParentWalletUpdateInput = {
    walletId?: IntFieldUpdateOperationsInput | number
    walletAddress?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: EnumParentWalletTypeFieldUpdateOperationsInput | $Enums.ParentWalletType
    lastUsedIndex?: IntFieldUpdateOperationsInput | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    toBeDisplayed?: BoolFieldUpdateOperationsInput | boolean
    parentChainIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childCryptoWallet?: CryptoWalletUpdateManyWithoutParentWalletNestedInput
    parentWallet?: StableCoinUpdateManyWithoutParentWalletNestedInput
  }

  export type ParentWalletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    walletAddress?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: EnumParentWalletTypeFieldUpdateOperationsInput | $Enums.ParentWalletType
    lastUsedIndex?: IntFieldUpdateOperationsInput | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    toBeDisplayed?: BoolFieldUpdateOperationsInput | boolean
    parentChainIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childCryptoWallet?: CryptoWalletUncheckedUpdateManyWithoutParentWalletNestedInput
    parentWallet?: StableCoinUncheckedUpdateManyWithoutParentWalletNestedInput
  }

  export type ParentWalletCreateManyInput = {
    id?: number
    walletId: number
    walletAddress: string
    chain: string
    coin: string
    parentChain: string
    type: string
    subType: $Enums.ParentWalletType
    lastUsedIndex: number
    displayName?: string | null
    toBeDisplayed?: boolean
    parentChainIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentWalletUpdateManyMutationInput = {
    walletId?: IntFieldUpdateOperationsInput | number
    walletAddress?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: EnumParentWalletTypeFieldUpdateOperationsInput | $Enums.ParentWalletType
    lastUsedIndex?: IntFieldUpdateOperationsInput | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    toBeDisplayed?: BoolFieldUpdateOperationsInput | boolean
    parentChainIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentWalletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    walletAddress?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: EnumParentWalletTypeFieldUpdateOperationsInput | $Enums.ParentWalletType
    lastUsedIndex?: IntFieldUpdateOperationsInput | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    toBeDisplayed?: BoolFieldUpdateOperationsInput | boolean
    parentChainIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StableCoinCreateInput = {
    token: string
    parentChain: string
    tokenIconUrl?: string | null
    parentWallet: ParentWalletCreateNestedOneWithoutParentWalletInput
  }

  export type StableCoinUncheckedCreateInput = {
    id?: number
    parentWalletId: number
    token: string
    parentChain: string
    tokenIconUrl?: string | null
  }

  export type StableCoinUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    tokenIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    parentWallet?: ParentWalletUpdateOneRequiredWithoutParentWalletNestedInput
  }

  export type StableCoinUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentWalletId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    tokenIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StableCoinCreateManyInput = {
    id?: number
    parentWalletId: number
    token: string
    parentChain: string
    tokenIconUrl?: string | null
  }

  export type StableCoinUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    tokenIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StableCoinUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentWalletId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    tokenIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CryptoWalletCreateInput = {
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    account?: UserAccountCreateNestedOneWithoutCryptoWalletRelInput
    parentWallet: ParentWalletCreateNestedOneWithoutChildCryptoWalletInput
    cryptoDeposit?: CryptoDepositCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletUncheckedCreateInput = {
    id?: number
    accountId?: number | null
    parentWalletId: number
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    cryptoDeposit?: CryptoDepositUncheckedCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletUpdateInput = {
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    account?: UserAccountUpdateOneWithoutCryptoWalletRelNestedInput
    parentWallet?: ParentWalletUpdateOneRequiredWithoutChildCryptoWalletNestedInput
    cryptoDeposit?: CryptoDepositUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    parentWalletId?: IntFieldUpdateOperationsInput | number
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    cryptoDeposit?: CryptoDepositUncheckedUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletCreateManyInput = {
    id?: number
    accountId?: number | null
    parentWalletId: number
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoWalletUpdateManyMutationInput = {
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoWalletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    parentWalletId?: IntFieldUpdateOperationsInput | number
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type PerpetualContractsCreateInput = {
    contractSymbol: string
    displayName: string
    systemConfig: JsonNullValueInput | InputJsonValue
    exchangeConfig: JsonNullValueInput | InputJsonValue
    isActive: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type PerpetualContractsUncheckedCreateInput = {
    id?: number
    contractSymbol: string
    displayName: string
    systemConfig: JsonNullValueInput | InputJsonValue
    exchangeConfig: JsonNullValueInput | InputJsonValue
    isActive: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type PerpetualContractsUpdateInput = {
    contractSymbol?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    systemConfig?: JsonNullValueInput | InputJsonValue
    exchangeConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type PerpetualContractsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractSymbol?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    systemConfig?: JsonNullValueInput | InputJsonValue
    exchangeConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type PerpetualContractsCreateManyInput = {
    id?: number
    contractSymbol: string
    displayName: string
    systemConfig: JsonNullValueInput | InputJsonValue
    exchangeConfig: JsonNullValueInput | InputJsonValue
    isActive: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type PerpetualContractsUpdateManyMutationInput = {
    contractSymbol?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    systemConfig?: JsonNullValueInput | InputJsonValue
    exchangeConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type PerpetualContractsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractSymbol?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    systemConfig?: JsonNullValueInput | InputJsonValue
    exchangeConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type KlineHistoricalDataCreateInput = {
    contractSymbol: string
    displayName: string
    interval: $Enums.Interval
    ohlc: JsonNullValueInput | InputJsonValue
    conversionRate: string
    startTime: bigint | number
    endTime: bigint | number
    timestampIst: string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type KlineHistoricalDataUncheckedCreateInput = {
    id?: number
    contractSymbol: string
    displayName: string
    interval: $Enums.Interval
    ohlc: JsonNullValueInput | InputJsonValue
    conversionRate: string
    startTime: bigint | number
    endTime: bigint | number
    timestampIst: string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type KlineHistoricalDataUpdateInput = {
    contractSymbol?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    interval?: EnumIntervalFieldUpdateOperationsInput | $Enums.Interval
    ohlc?: JsonNullValueInput | InputJsonValue
    conversionRate?: StringFieldUpdateOperationsInput | string
    startTime?: BigIntFieldUpdateOperationsInput | bigint | number
    endTime?: BigIntFieldUpdateOperationsInput | bigint | number
    timestampIst?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type KlineHistoricalDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractSymbol?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    interval?: EnumIntervalFieldUpdateOperationsInput | $Enums.Interval
    ohlc?: JsonNullValueInput | InputJsonValue
    conversionRate?: StringFieldUpdateOperationsInput | string
    startTime?: BigIntFieldUpdateOperationsInput | bigint | number
    endTime?: BigIntFieldUpdateOperationsInput | bigint | number
    timestampIst?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type KlineHistoricalDataCreateManyInput = {
    id?: number
    contractSymbol: string
    displayName: string
    interval: $Enums.Interval
    ohlc: JsonNullValueInput | InputJsonValue
    conversionRate: string
    startTime: bigint | number
    endTime: bigint | number
    timestampIst: string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type KlineHistoricalDataUpdateManyMutationInput = {
    contractSymbol?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    interval?: EnumIntervalFieldUpdateOperationsInput | $Enums.Interval
    ohlc?: JsonNullValueInput | InputJsonValue
    conversionRate?: StringFieldUpdateOperationsInput | string
    startTime?: BigIntFieldUpdateOperationsInput | bigint | number
    endTime?: BigIntFieldUpdateOperationsInput | bigint | number
    timestampIst?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type KlineHistoricalDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractSymbol?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    interval?: EnumIntervalFieldUpdateOperationsInput | $Enums.Interval
    ohlc?: JsonNullValueInput | InputJsonValue
    conversionRate?: StringFieldUpdateOperationsInput | string
    startTime?: BigIntFieldUpdateOperationsInput | bigint | number
    endTime?: BigIntFieldUpdateOperationsInput | bigint | number
    timestampIst?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserOrderHistoryCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserOrderHistoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserOrderHistoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserOrderHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserOrderHistoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserOrderHistoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserOrderHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserTradeHistoryCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserTradeHistoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserTradeHistoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserTradeHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserTradeHistoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserTradeHistoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserTradeHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserPositionHistoryCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserPositionHistoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserPositionHistoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserPositionHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserPositionHistoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserPositionHistoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserPositionHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BinanceOrderHistoryCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BinanceOrderHistoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BinanceOrderHistoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BinanceOrderHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BinanceOrderHistoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BinanceOrderHistoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BinanceOrderHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BinanceTradeHistoryCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BinanceTradeHistoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BinanceTradeHistoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BinanceTradeHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BinanceTradeHistoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BinanceTradeHistoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BinanceTradeHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CoinwiseTradeRecoincilliationCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CoinwiseTradeRecoincilliationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CoinwiseTradeRecoincilliationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CoinwiseTradeRecoincilliationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CoinwiseTradeRecoincilliationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CoinwiseTradeRecoincilliationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CoinwiseTradeRecoincilliationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CoinwisePositionRecoincilliationCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CoinwisePositionRecoincilliationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CoinwisePositionRecoincilliationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CoinwisePositionRecoincilliationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CoinwisePositionRecoincilliationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CoinwisePositionRecoincilliationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CoinwisePositionRecoincilliationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InvoicesCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InvoicesUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InvoicesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InvoicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InvoicesCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InvoicesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InvoicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ReportsCreateInput = {
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type ReportsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type ReportsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ReportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ReportsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type ReportsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ReportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumUserAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAccountType | EnumUserAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserAccountType[] | ListEnumUserAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserAccountType[] | ListEnumUserAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserAccountTypeFilter<$PrismaModel> | $Enums.UserAccountType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InrLedgerListRelationFilter = {
    every?: InrLedgerWhereInput
    some?: InrLedgerWhereInput
    none?: InrLedgerWhereInput
  }

  export type CryptoLedgerListRelationFilter = {
    every?: CryptoLedgerWhereInput
    some?: CryptoLedgerWhereInput
    none?: CryptoLedgerWhereInput
  }

  export type TradeLedgerListRelationFilter = {
    every?: TradeLedgerWhereInput
    some?: TradeLedgerWhereInput
    none?: TradeLedgerWhereInput
  }

  export type InrWalletNullableRelationFilter = {
    is?: InrWalletWhereInput | null
    isNot?: InrWalletWhereInput | null
  }

  export type CryptoWalletListRelationFilter = {
    every?: CryptoWalletWhereInput
    some?: CryptoWalletWhereInput
    none?: CryptoWalletWhereInput
  }

  export type InrConversionHistoryListRelationFilter = {
    every?: InrConversionHistoryWhereInput
    some?: InrConversionHistoryWhereInput
    none?: InrConversionHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InrLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoWalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InrConversionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentAccount?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentAccount?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentAccount?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentAccount?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserAccountSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentAccount?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumUserAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAccountType | EnumUserAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserAccountType[] | ListEnumUserAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserAccountType[] | ListEnumUserAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserAccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumUserAccountTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type EnumSignUpTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SignUpType | EnumSignUpTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SignUpType[] | ListEnumSignUpTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SignUpType[] | ListEnumSignUpTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSignUpTypeNullableFilter<$PrismaModel> | $Enums.SignUpType | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserKycStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserKycStatus | EnumUserKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserKycStatus[] | ListEnumUserKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserKycStatus[] | ListEnumUserKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserKycStatusFilter<$PrismaModel> | $Enums.UserKycStatus
  }

  export type EnumBankVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BankVerificationStatus | EnumBankVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BankVerificationStatus[] | ListEnumBankVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankVerificationStatus[] | ListEnumBankVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBankVerificationStatusFilter<$PrismaModel> | $Enums.BankVerificationStatus
  }

  export type UserKycNullableRelationFilter = {
    is?: UserKycWhereInput | null
    isNot?: UserKycWhereInput | null
  }

  export type UserBankDetailsNullableRelationFilter = {
    is?: UserBankDetailsWhereInput | null
    isNot?: UserBankDetailsWhereInput | null
  }

  export type UserBankDetailsListRelationFilter = {
    every?: UserBankDetailsWhereInput
    some?: UserBankDetailsWhereInput
    none?: UserBankDetailsWhereInput
  }

  export type FiatPaymentsListRelationFilter = {
    every?: FiatPaymentsWhereInput
    some?: FiatPaymentsWhereInput
    none?: FiatPaymentsWhereInput
  }

  export type UserAccountNullableRelationFilter = {
    is?: UserAccountWhereInput | null
    isNot?: UserAccountWhereInput | null
  }

  export type TwoFAListRelationFilter = {
    every?: TwoFAWhereInput
    some?: TwoFAWhereInput
    none?: TwoFAWhereInput
  }

  export type UserBankDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FiatPaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwoFAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    signupType?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneCountryCode?: SortOrder
    initVector?: SortOrder
    password?: SortOrder
    passwordUpdatedAt?: SortOrder
    kycStatus?: SortOrder
    kycId?: SortOrder
    bankVerificationStatus?: SortOrder
    bankDetailsId?: SortOrder
    isActive?: SortOrder
    inrDepositEnabled?: SortOrder
    cryptoDepositEnabled?: SortOrder
    inrWithdrawEnabled?: SortOrder
    cryptoWithdrawEnabled?: SortOrder
    tradeEnabled?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    kycId?: SortOrder
    bankDetailsId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    signupType?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneCountryCode?: SortOrder
    initVector?: SortOrder
    password?: SortOrder
    passwordUpdatedAt?: SortOrder
    kycStatus?: SortOrder
    kycId?: SortOrder
    bankVerificationStatus?: SortOrder
    bankDetailsId?: SortOrder
    isActive?: SortOrder
    inrDepositEnabled?: SortOrder
    cryptoDepositEnabled?: SortOrder
    inrWithdrawEnabled?: SortOrder
    cryptoWithdrawEnabled?: SortOrder
    tradeEnabled?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    signupType?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneCountryCode?: SortOrder
    initVector?: SortOrder
    password?: SortOrder
    passwordUpdatedAt?: SortOrder
    kycStatus?: SortOrder
    kycId?: SortOrder
    bankVerificationStatus?: SortOrder
    bankDetailsId?: SortOrder
    isActive?: SortOrder
    inrDepositEnabled?: SortOrder
    cryptoDepositEnabled?: SortOrder
    inrWithdrawEnabled?: SortOrder
    cryptoWithdrawEnabled?: SortOrder
    tradeEnabled?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    kycId?: SortOrder
    bankDetailsId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type EnumSignUpTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignUpType | EnumSignUpTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SignUpType[] | ListEnumSignUpTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SignUpType[] | ListEnumSignUpTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSignUpTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SignUpType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSignUpTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSignUpTypeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserKycStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserKycStatus | EnumUserKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserKycStatus[] | ListEnumUserKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserKycStatus[] | ListEnumUserKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserKycStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserKycStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserKycStatusFilter<$PrismaModel>
    _max?: NestedEnumUserKycStatusFilter<$PrismaModel>
  }

  export type EnumBankVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BankVerificationStatus | EnumBankVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BankVerificationStatus[] | ListEnumBankVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankVerificationStatus[] | ListEnumBankVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBankVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.BankVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBankVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumBankVerificationStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DepositWithdrawLimitsCountOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    fiatDepositLimit?: SortOrder
    fiatWithdrawLimit?: SortOrder
    cryptoDepositLimit?: SortOrder
    cryptoWithdrawLimit?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DepositWithdrawLimitsAvgOrderByAggregateInput = {
    id?: SortOrder
    fiatDepositLimit?: SortOrder
    fiatWithdrawLimit?: SortOrder
    cryptoDepositLimit?: SortOrder
    cryptoWithdrawLimit?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type DepositWithdrawLimitsMaxOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    fiatDepositLimit?: SortOrder
    fiatWithdrawLimit?: SortOrder
    cryptoDepositLimit?: SortOrder
    cryptoWithdrawLimit?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DepositWithdrawLimitsMinOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    fiatDepositLimit?: SortOrder
    fiatWithdrawLimit?: SortOrder
    cryptoDepositLimit?: SortOrder
    cryptoWithdrawLimit?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DepositWithdrawLimitsSumOrderByAggregateInput = {
    id?: SortOrder
    fiatDepositLimit?: SortOrder
    fiatWithdrawLimit?: SortOrder
    cryptoDepositLimit?: SortOrder
    cryptoWithdrawLimit?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTwoFAStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TwoFAStatus | EnumTwoFAStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TwoFAStatus[] | ListEnumTwoFAStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TwoFAStatus[] | ListEnumTwoFAStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTwoFAStatusFilter<$PrismaModel> | $Enums.TwoFAStatus
  }

  export type EnumReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.Reason | EnumReasonFieldRefInput<$PrismaModel>
    in?: $Enums.Reason[] | ListEnumReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.Reason[] | ListEnumReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReasonFilter<$PrismaModel> | $Enums.Reason
  }

  export type TwoFACountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    expiryTime?: SortOrder
    mobileVerifiedAtleastOnce?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TwoFAAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiryTime?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type TwoFAMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    expiryTime?: SortOrder
    mobileVerifiedAtleastOnce?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TwoFAMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    expiryTime?: SortOrder
    mobileVerifiedAtleastOnce?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TwoFASumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiryTime?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumTwoFAStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TwoFAStatus | EnumTwoFAStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TwoFAStatus[] | ListEnumTwoFAStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TwoFAStatus[] | ListEnumTwoFAStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTwoFAStatusWithAggregatesFilter<$PrismaModel> | $Enums.TwoFAStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTwoFAStatusFilter<$PrismaModel>
    _max?: NestedEnumTwoFAStatusFilter<$PrismaModel>
  }

  export type EnumReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Reason | EnumReasonFieldRefInput<$PrismaModel>
    in?: $Enums.Reason[] | ListEnumReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.Reason[] | ListEnumReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReasonWithAggregatesFilter<$PrismaModel> | $Enums.Reason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReasonFilter<$PrismaModel>
    _max?: NestedEnumReasonFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumKycTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KycType | EnumKycTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KycType[] | ListEnumKycTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycType[] | ListEnumKycTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKycTypeFilter<$PrismaModel> | $Enums.KycType
  }

  export type EnumHypervergeStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HypervergeStatus | EnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.HypervergeStatus[] | ListEnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HypervergeStatus[] | ListEnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHypervergeStatusNullableFilter<$PrismaModel> | $Enums.HypervergeStatus | null
  }

  export type EncryptedUserDataNullableRelationFilter = {
    is?: EncryptedUserDataWhereInput | null
    isNot?: EncryptedUserDataWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserKycCountOrderByAggregateInput = {
    id?: SortOrder
    encryptedUserDataId?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    address?: SortOrder
    fatherName?: SortOrder
    kycType?: SortOrder
    kycStatus?: SortOrder
    hyperVergeStatus?: SortOrder
    panStatus?: SortOrder
    aadharFrontStatus?: SortOrder
    aadharBackStatus?: SortOrder
    selfieStatus?: SortOrder
    aadharPanNameMatchStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserKycAvgOrderByAggregateInput = {
    id?: SortOrder
    encryptedUserDataId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserKycMaxOrderByAggregateInput = {
    id?: SortOrder
    encryptedUserDataId?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    address?: SortOrder
    fatherName?: SortOrder
    kycType?: SortOrder
    kycStatus?: SortOrder
    hyperVergeStatus?: SortOrder
    panStatus?: SortOrder
    aadharFrontStatus?: SortOrder
    aadharBackStatus?: SortOrder
    selfieStatus?: SortOrder
    aadharPanNameMatchStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserKycMinOrderByAggregateInput = {
    id?: SortOrder
    encryptedUserDataId?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    address?: SortOrder
    fatherName?: SortOrder
    kycType?: SortOrder
    kycStatus?: SortOrder
    hyperVergeStatus?: SortOrder
    panStatus?: SortOrder
    aadharFrontStatus?: SortOrder
    aadharBackStatus?: SortOrder
    selfieStatus?: SortOrder
    aadharPanNameMatchStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserKycSumOrderByAggregateInput = {
    id?: SortOrder
    encryptedUserDataId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumKycTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KycType | EnumKycTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KycType[] | ListEnumKycTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycType[] | ListEnumKycTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKycTypeWithAggregatesFilter<$PrismaModel> | $Enums.KycType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKycTypeFilter<$PrismaModel>
    _max?: NestedEnumKycTypeFilter<$PrismaModel>
  }

  export type EnumHypervergeStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HypervergeStatus | EnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.HypervergeStatus[] | ListEnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HypervergeStatus[] | ListEnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHypervergeStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.HypervergeStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHypervergeStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumHypervergeStatusNullableFilter<$PrismaModel>
  }

  export type EncryptedUserDataCountOrderByAggregateInput = {
    id?: SortOrder
    panNumber?: SortOrder
    aadharNumber?: SortOrder
    userId?: SortOrder
    fileKey?: SortOrder
    bucketName?: SortOrder
    initVector?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EncryptedUserDataAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EncryptedUserDataMaxOrderByAggregateInput = {
    id?: SortOrder
    panNumber?: SortOrder
    aadharNumber?: SortOrder
    userId?: SortOrder
    fileKey?: SortOrder
    bucketName?: SortOrder
    initVector?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EncryptedUserDataMinOrderByAggregateInput = {
    id?: SortOrder
    panNumber?: SortOrder
    aadharNumber?: SortOrder
    userId?: SortOrder
    fileKey?: SortOrder
    bucketName?: SortOrder
    initVector?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EncryptedUserDataSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumBankDetailsTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BankDetailsType | EnumBankDetailsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BankDetailsType[] | ListEnumBankDetailsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankDetailsType[] | ListEnumBankDetailsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBankDetailsTypeFilter<$PrismaModel> | $Enums.BankDetailsType
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBankDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    bankDetailsType?: SortOrder
    userId?: SortOrder
    bankAccountNumber?: SortOrder
    bankName?: SortOrder
    accountHolderName?: SortOrder
    ifsc?: SortOrder
    bankVerificationStatus?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserBankDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserBankDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    bankDetailsType?: SortOrder
    userId?: SortOrder
    bankAccountNumber?: SortOrder
    bankName?: SortOrder
    accountHolderName?: SortOrder
    ifsc?: SortOrder
    bankVerificationStatus?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserBankDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    bankDetailsType?: SortOrder
    userId?: SortOrder
    bankAccountNumber?: SortOrder
    bankName?: SortOrder
    accountHolderName?: SortOrder
    ifsc?: SortOrder
    bankVerificationStatus?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserBankDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumBankDetailsTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BankDetailsType | EnumBankDetailsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BankDetailsType[] | ListEnumBankDetailsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankDetailsType[] | ListEnumBankDetailsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBankDetailsTypeWithAggregatesFilter<$PrismaModel> | $Enums.BankDetailsType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBankDetailsTypeFilter<$PrismaModel>
    _max?: NestedEnumBankDetailsTypeFilter<$PrismaModel>
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type BankFeedNullableRelationFilter = {
    is?: BankFeedWhereInput | null
    isNot?: BankFeedWhereInput | null
  }

  export type FiatPaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    systemBankId?: SortOrder
    userBankId?: SortOrder
    systemAccountNumber?: SortOrder
    userAccountNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    amountCredited?: SortOrder
    amountDebited?: SortOrder
    bankProofUrl?: SortOrder
    receiptNumber?: SortOrder
    userRemarks?: SortOrder
    adminRemarks?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type FiatPaymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    systemBankId?: SortOrder
    userBankId?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    amountCredited?: SortOrder
    amountDebited?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type FiatPaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    systemBankId?: SortOrder
    userBankId?: SortOrder
    systemAccountNumber?: SortOrder
    userAccountNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    amountCredited?: SortOrder
    amountDebited?: SortOrder
    bankProofUrl?: SortOrder
    receiptNumber?: SortOrder
    userRemarks?: SortOrder
    adminRemarks?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type FiatPaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    systemBankId?: SortOrder
    userBankId?: SortOrder
    systemAccountNumber?: SortOrder
    userAccountNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    amountCredited?: SortOrder
    amountDebited?: SortOrder
    bankProofUrl?: SortOrder
    receiptNumber?: SortOrder
    userRemarks?: SortOrder
    adminRemarks?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type FiatPaymentsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    systemBankId?: SortOrder
    userBankId?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    amountCredited?: SortOrder
    amountDebited?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumInrCreditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InrCreditStatus | EnumInrCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InrCreditStatus[] | ListEnumInrCreditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InrCreditStatus[] | ListEnumInrCreditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInrCreditStatusFilter<$PrismaModel> | $Enums.InrCreditStatus
  }

  export type CryptoWalletNullableRelationFilter = {
    is?: CryptoWalletWhereInput | null
    isNot?: CryptoWalletWhereInput | null
  }

  export type CryptoDepositCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    cryptoWalletId?: SortOrder
    liminalTxnRefId?: SortOrder
    coin?: SortOrder
    walletId?: SortOrder
    timestamp?: SortOrder
    fee?: SortOrder
    effectiveChange?: SortOrder
    runningBalance?: SortOrder
    externalAddress?: SortOrder
    effectiveChangeUsd?: SortOrder
    wallet?: SortOrder
    tokenContractAddress?: SortOrder
    explorerLink?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    sequenceId?: SortOrder
    type?: SortOrder
    conversionRate?: SortOrder
    isConverted?: SortOrder
    conversionTimestamp?: SortOrder
    inrCreditStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoDepositAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    cryptoWalletId?: SortOrder
    walletId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoDepositMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    cryptoWalletId?: SortOrder
    liminalTxnRefId?: SortOrder
    coin?: SortOrder
    walletId?: SortOrder
    timestamp?: SortOrder
    fee?: SortOrder
    effectiveChange?: SortOrder
    runningBalance?: SortOrder
    externalAddress?: SortOrder
    effectiveChangeUsd?: SortOrder
    tokenContractAddress?: SortOrder
    explorerLink?: SortOrder
    sequenceId?: SortOrder
    type?: SortOrder
    conversionRate?: SortOrder
    isConverted?: SortOrder
    conversionTimestamp?: SortOrder
    inrCreditStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoDepositMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    cryptoWalletId?: SortOrder
    liminalTxnRefId?: SortOrder
    coin?: SortOrder
    walletId?: SortOrder
    timestamp?: SortOrder
    fee?: SortOrder
    effectiveChange?: SortOrder
    runningBalance?: SortOrder
    externalAddress?: SortOrder
    effectiveChangeUsd?: SortOrder
    tokenContractAddress?: SortOrder
    explorerLink?: SortOrder
    sequenceId?: SortOrder
    type?: SortOrder
    conversionRate?: SortOrder
    isConverted?: SortOrder
    conversionTimestamp?: SortOrder
    inrCreditStatus?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoDepositSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    cryptoWalletId?: SortOrder
    walletId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumInrCreditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InrCreditStatus | EnumInrCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InrCreditStatus[] | ListEnumInrCreditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InrCreditStatus[] | ListEnumInrCreditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInrCreditStatusWithAggregatesFilter<$PrismaModel> | $Enums.InrCreditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInrCreditStatusFilter<$PrismaModel>
    _max?: NestedEnumInrCreditStatusFilter<$PrismaModel>
  }

  export type CryptoDepositNullableRelationFilter = {
    is?: CryptoDepositWhereInput | null
    isNot?: CryptoDepositWhereInput | null
  }

  export type UserAccountRelationFilter = {
    is?: UserAccountWhereInput
    isNot?: UserAccountWhereInput
  }

  export type InrConversionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    cryptoDepositId?: SortOrder
    accountId?: SortOrder
    baseToken?: SortOrder
    baseTokenQuantity?: SortOrder
    inrValue?: SortOrder
    inrValAfterDeduction?: SortOrder
    gst?: SortOrder
    txnFee?: SortOrder
    tds?: SortOrder
    coinConversionRate?: SortOrder
    receivingAddress?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrConversionHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    cryptoDepositId?: SortOrder
    accountId?: SortOrder
    baseTokenQuantity?: SortOrder
    inrValue?: SortOrder
    inrValAfterDeduction?: SortOrder
    gst?: SortOrder
    txnFee?: SortOrder
    tds?: SortOrder
    coinConversionRate?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrConversionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    cryptoDepositId?: SortOrder
    accountId?: SortOrder
    baseToken?: SortOrder
    baseTokenQuantity?: SortOrder
    inrValue?: SortOrder
    inrValAfterDeduction?: SortOrder
    gst?: SortOrder
    txnFee?: SortOrder
    tds?: SortOrder
    coinConversionRate?: SortOrder
    receivingAddress?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrConversionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    cryptoDepositId?: SortOrder
    accountId?: SortOrder
    baseToken?: SortOrder
    baseTokenQuantity?: SortOrder
    inrValue?: SortOrder
    inrValAfterDeduction?: SortOrder
    gst?: SortOrder
    txnFee?: SortOrder
    tds?: SortOrder
    coinConversionRate?: SortOrder
    receivingAddress?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrConversionHistorySumOrderByAggregateInput = {
    id?: SortOrder
    cryptoDepositId?: SortOrder
    accountId?: SortOrder
    baseTokenQuantity?: SortOrder
    inrValue?: SortOrder
    inrValAfterDeduction?: SortOrder
    gst?: SortOrder
    txnFee?: SortOrder
    tds?: SortOrder
    coinConversionRate?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumProcessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusFilter<$PrismaModel> | $Enums.ProcessStatus
  }

  export type FiatPaymentsNullableRelationFilter = {
    is?: FiatPaymentsWhereInput | null
    isNot?: FiatPaymentsWhereInput | null
  }

  export type BankFeedCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    serialNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    bankName?: SortOrder
    bankRefId?: SortOrder
    processStatus?: SortOrder
    userRemarks?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BankFeedAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    serialNumber?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type BankFeedMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    serialNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    bankName?: SortOrder
    bankRefId?: SortOrder
    processStatus?: SortOrder
    userRemarks?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BankFeedMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    serialNumber?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    bankName?: SortOrder
    bankRefId?: SortOrder
    processStatus?: SortOrder
    userRemarks?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BankFeedSumOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    serialNumber?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumProcessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessStatusFilter<$PrismaModel>
  }

  export type EnumInrOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.InrOperation | EnumInrOperationFieldRefInput<$PrismaModel>
    in?: $Enums.InrOperation[] | ListEnumInrOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.InrOperation[] | ListEnumInrOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumInrOperationFilter<$PrismaModel> | $Enums.InrOperation
  }

  export type InrLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrLedgerAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrLedgerSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumInrOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InrOperation | EnumInrOperationFieldRefInput<$PrismaModel>
    in?: $Enums.InrOperation[] | ListEnumInrOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.InrOperation[] | ListEnumInrOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumInrOperationWithAggregatesFilter<$PrismaModel> | $Enums.InrOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInrOperationFilter<$PrismaModel>
    _max?: NestedEnumInrOperationFilter<$PrismaModel>
  }

  export type EnumCryptoOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoOperation | EnumCryptoOperationFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoOperation[] | ListEnumCryptoOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoOperation[] | ListEnumCryptoOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoOperationFilter<$PrismaModel> | $Enums.CryptoOperation
  }

  export type CryptoLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    coin?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoLedgerAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    coin?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    coin?: SortOrder
    change?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoLedgerSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumCryptoOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoOperation | EnumCryptoOperationFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoOperation[] | ListEnumCryptoOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoOperation[] | ListEnumCryptoOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoOperationWithAggregatesFilter<$PrismaModel> | $Enums.CryptoOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCryptoOperationFilter<$PrismaModel>
    _max?: NestedEnumCryptoOperationFilter<$PrismaModel>
  }

  export type EnumPositionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PositionType | EnumPositionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PositionType[] | ListEnumPositionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PositionType[] | ListEnumPositionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionTypeFilter<$PrismaModel> | $Enums.PositionType
  }

  export type EnumTradeOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeOperation | EnumTradeOperationFieldRefInput<$PrismaModel>
    in?: $Enums.TradeOperation[] | ListEnumTradeOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeOperation[] | ListEnumTradeOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeOperationFilter<$PrismaModel> | $Enums.TradeOperation
  }

  export type TradeLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    tradeId?: SortOrder
    positionType?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TradeLedgerAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type TradeLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    tradeId?: SortOrder
    positionType?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TradeLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    change?: SortOrder
    tradeId?: SortOrder
    positionType?: SortOrder
    operation?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TradeLedgerSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumPositionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PositionType | EnumPositionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PositionType[] | ListEnumPositionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PositionType[] | ListEnumPositionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PositionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionTypeFilter<$PrismaModel>
    _max?: NestedEnumPositionTypeFilter<$PrismaModel>
  }

  export type EnumTradeOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeOperation | EnumTradeOperationFieldRefInput<$PrismaModel>
    in?: $Enums.TradeOperation[] | ListEnumTradeOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeOperation[] | ListEnumTradeOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeOperationWithAggregatesFilter<$PrismaModel> | $Enums.TradeOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeOperationFilter<$PrismaModel>
    _max?: NestedEnumTradeOperationFilter<$PrismaModel>
  }

  export type EnumParameterGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterGroup | EnumParameterGroupFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterGroup[] | ListEnumParameterGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterGroup[] | ListEnumParameterGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterGroupFilter<$PrismaModel> | $Enums.ParameterGroup
  }

  export type EnumParamTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParamType | EnumParamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParamType[] | ListEnumParamTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParamType[] | ListEnumParamTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParamTypeFilter<$PrismaModel> | $Enums.ParamType
  }

  export type SystemConfigForDashboardCountOrderByAggregateInput = {
    id?: SortOrder
    parameterGroup?: SortOrder
    parameterName?: SortOrder
    parameterType?: SortOrder
    isRanged?: SortOrder
    parameterValue?: SortOrder
    symbol?: SortOrder
    rangeStart?: SortOrder
    rangeEnd?: SortOrder
    roleBasedAccess?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigForDashboardAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigForDashboardMaxOrderByAggregateInput = {
    id?: SortOrder
    parameterGroup?: SortOrder
    parameterName?: SortOrder
    parameterType?: SortOrder
    isRanged?: SortOrder
    parameterValue?: SortOrder
    symbol?: SortOrder
    rangeStart?: SortOrder
    rangeEnd?: SortOrder
    roleBasedAccess?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigForDashboardMinOrderByAggregateInput = {
    id?: SortOrder
    parameterGroup?: SortOrder
    parameterName?: SortOrder
    parameterType?: SortOrder
    isRanged?: SortOrder
    parameterValue?: SortOrder
    symbol?: SortOrder
    rangeStart?: SortOrder
    rangeEnd?: SortOrder
    roleBasedAccess?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigForDashboardSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumParameterGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterGroup | EnumParameterGroupFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterGroup[] | ListEnumParameterGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterGroup[] | ListEnumParameterGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterGroupWithAggregatesFilter<$PrismaModel> | $Enums.ParameterGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParameterGroupFilter<$PrismaModel>
    _max?: NestedEnumParameterGroupFilter<$PrismaModel>
  }

  export type EnumParamTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParamType | EnumParamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParamType[] | ListEnumParamTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParamType[] | ListEnumParamTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParamTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParamType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParamTypeFilter<$PrismaModel>
    _max?: NestedEnumParamTypeFilter<$PrismaModel>
  }

  export type SystemConfigChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    parameterName?: SortOrder
    parameterValue?: SortOrder
    isRanged?: SortOrder
    rangeStart?: SortOrder
    rangeEnd?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigChangeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    parameterName?: SortOrder
    parameterValue?: SortOrder
    isRanged?: SortOrder
    rangeStart?: SortOrder
    rangeEnd?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    parameterName?: SortOrder
    parameterValue?: SortOrder
    isRanged?: SortOrder
    rangeStart?: SortOrder
    rangeEnd?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemConfigChangeLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrWalletCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    walletBalance?: SortOrder
    amountAvailable?: SortOrder
    amountLocked?: SortOrder
    unrealizedPnl?: SortOrder
    last24hourChange?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrWalletAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    walletBalance?: SortOrder
    amountAvailable?: SortOrder
    amountLocked?: SortOrder
    unrealizedPnl?: SortOrder
    last24hourChange?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    walletBalance?: SortOrder
    amountAvailable?: SortOrder
    amountLocked?: SortOrder
    unrealizedPnl?: SortOrder
    last24hourChange?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrWalletMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    walletBalance?: SortOrder
    amountAvailable?: SortOrder
    amountLocked?: SortOrder
    unrealizedPnl?: SortOrder
    last24hourChange?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InrWalletSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    walletBalance?: SortOrder
    amountAvailable?: SortOrder
    amountLocked?: SortOrder
    unrealizedPnl?: SortOrder
    last24hourChange?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumParentWalletTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParentWalletType | EnumParentWalletTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParentWalletType[] | ListEnumParentWalletTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParentWalletType[] | ListEnumParentWalletTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParentWalletTypeFilter<$PrismaModel> | $Enums.ParentWalletType
  }

  export type StableCoinListRelationFilter = {
    every?: StableCoinWhereInput
    some?: StableCoinWhereInput
    none?: StableCoinWhereInput
  }

  export type StableCoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentWalletCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    walletAddress?: SortOrder
    chain?: SortOrder
    coin?: SortOrder
    parentChain?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    lastUsedIndex?: SortOrder
    displayName?: SortOrder
    toBeDisplayed?: SortOrder
    parentChainIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentWalletAvgOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    lastUsedIndex?: SortOrder
  }

  export type ParentWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    walletAddress?: SortOrder
    chain?: SortOrder
    coin?: SortOrder
    parentChain?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    lastUsedIndex?: SortOrder
    displayName?: SortOrder
    toBeDisplayed?: SortOrder
    parentChainIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentWalletMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    walletAddress?: SortOrder
    chain?: SortOrder
    coin?: SortOrder
    parentChain?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    lastUsedIndex?: SortOrder
    displayName?: SortOrder
    toBeDisplayed?: SortOrder
    parentChainIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentWalletSumOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    lastUsedIndex?: SortOrder
  }

  export type EnumParentWalletTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParentWalletType | EnumParentWalletTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParentWalletType[] | ListEnumParentWalletTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParentWalletType[] | ListEnumParentWalletTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParentWalletTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParentWalletType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParentWalletTypeFilter<$PrismaModel>
    _max?: NestedEnumParentWalletTypeFilter<$PrismaModel>
  }

  export type ParentWalletRelationFilter = {
    is?: ParentWalletWhereInput
    isNot?: ParentWalletWhereInput
  }

  export type StableCoinParentWalletIdTokenCompoundUniqueInput = {
    parentWalletId: number
    token: string
  }

  export type StableCoinCountOrderByAggregateInput = {
    id?: SortOrder
    parentWalletId?: SortOrder
    token?: SortOrder
    parentChain?: SortOrder
    tokenIconUrl?: SortOrder
  }

  export type StableCoinAvgOrderByAggregateInput = {
    id?: SortOrder
    parentWalletId?: SortOrder
  }

  export type StableCoinMaxOrderByAggregateInput = {
    id?: SortOrder
    parentWalletId?: SortOrder
    token?: SortOrder
    parentChain?: SortOrder
    tokenIconUrl?: SortOrder
  }

  export type StableCoinMinOrderByAggregateInput = {
    id?: SortOrder
    parentWalletId?: SortOrder
    token?: SortOrder
    parentChain?: SortOrder
    tokenIconUrl?: SortOrder
  }

  export type StableCoinSumOrderByAggregateInput = {
    id?: SortOrder
    parentWalletId?: SortOrder
  }

  export type CryptoDepositListRelationFilter = {
    every?: CryptoDepositWhereInput
    some?: CryptoDepositWhereInput
    none?: CryptoDepositWhereInput
  }

  export type CryptoDepositOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoWalletLiminalCoinPublicAddressCompoundUniqueInput = {
    liminalCoin: string
    publicAddress: string
  }

  export type CryptoWalletCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    parentWalletId?: SortOrder
    liminalRefId?: SortOrder
    liminalParentId?: SortOrder
    liminalCoin?: SortOrder
    liminalChain?: SortOrder
    publicAddress?: SortOrder
    balance?: SortOrder
    lastConversion?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoWalletAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    parentWalletId?: SortOrder
    liminalParentId?: SortOrder
    balance?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    parentWalletId?: SortOrder
    liminalRefId?: SortOrder
    liminalParentId?: SortOrder
    liminalCoin?: SortOrder
    liminalChain?: SortOrder
    publicAddress?: SortOrder
    balance?: SortOrder
    lastConversion?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoWalletMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    parentWalletId?: SortOrder
    liminalRefId?: SortOrder
    liminalParentId?: SortOrder
    liminalCoin?: SortOrder
    liminalChain?: SortOrder
    publicAddress?: SortOrder
    balance?: SortOrder
    lastConversion?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CryptoWalletSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    parentWalletId?: SortOrder
    liminalParentId?: SortOrder
    balance?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PerpetualContractsCountOrderByAggregateInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    systemConfig?: SortOrder
    exchangeConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PerpetualContractsAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PerpetualContractsMaxOrderByAggregateInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PerpetualContractsMinOrderByAggregateInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PerpetualContractsSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumIntervalFilter<$PrismaModel = never> = {
    equals?: $Enums.Interval | EnumIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.Interval[] | ListEnumIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.Interval[] | ListEnumIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumIntervalFilter<$PrismaModel> | $Enums.Interval
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type KlineHistoricalDataCountOrderByAggregateInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    interval?: SortOrder
    ohlc?: SortOrder
    conversionRate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    timestampIst?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type KlineHistoricalDataAvgOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type KlineHistoricalDataMaxOrderByAggregateInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    interval?: SortOrder
    conversionRate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    timestampIst?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type KlineHistoricalDataMinOrderByAggregateInput = {
    id?: SortOrder
    contractSymbol?: SortOrder
    displayName?: SortOrder
    interval?: SortOrder
    conversionRate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    timestampIst?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type KlineHistoricalDataSumOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Interval | EnumIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.Interval[] | ListEnumIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.Interval[] | ListEnumIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumIntervalWithAggregatesFilter<$PrismaModel> | $Enums.Interval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntervalFilter<$PrismaModel>
    _max?: NestedEnumIntervalFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UserOrderHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserOrderHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserOrderHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserOrderHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserOrderHistorySumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserTradeHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserTradeHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserTradeHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserTradeHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserTradeHistorySumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserPositionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserPositionHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserPositionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserPositionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserPositionHistorySumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceOrderHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceOrderHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceOrderHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceOrderHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceOrderHistorySumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceTradeHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceTradeHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceTradeHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceTradeHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BinanceTradeHistorySumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwiseTradeRecoincilliationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwiseTradeRecoincilliationAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwiseTradeRecoincilliationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwiseTradeRecoincilliationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwiseTradeRecoincilliationSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwisePositionRecoincilliationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwisePositionRecoincilliationAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwisePositionRecoincilliationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwisePositionRecoincilliationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type CoinwisePositionRecoincilliationSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoicesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoicesAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoicesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoicesSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ReportsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ReportsAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ReportsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ReportsSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserCreateNestedOneWithoutUserAccountRelInput = {
    create?: XOR<UserCreateWithoutUserAccountRelInput, UserUncheckedCreateWithoutUserAccountRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAccountRelInput
    connect?: UserWhereUniqueInput
  }

  export type InrLedgerCreateNestedManyWithoutAccountInput = {
    create?: XOR<InrLedgerCreateWithoutAccountInput, InrLedgerUncheckedCreateWithoutAccountInput> | InrLedgerCreateWithoutAccountInput[] | InrLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InrLedgerCreateOrConnectWithoutAccountInput | InrLedgerCreateOrConnectWithoutAccountInput[]
    createMany?: InrLedgerCreateManyAccountInputEnvelope
    connect?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
  }

  export type CryptoLedgerCreateNestedManyWithoutAccountInput = {
    create?: XOR<CryptoLedgerCreateWithoutAccountInput, CryptoLedgerUncheckedCreateWithoutAccountInput> | CryptoLedgerCreateWithoutAccountInput[] | CryptoLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CryptoLedgerCreateOrConnectWithoutAccountInput | CryptoLedgerCreateOrConnectWithoutAccountInput[]
    createMany?: CryptoLedgerCreateManyAccountInputEnvelope
    connect?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
  }

  export type TradeLedgerCreateNestedManyWithoutAccountInput = {
    create?: XOR<TradeLedgerCreateWithoutAccountInput, TradeLedgerUncheckedCreateWithoutAccountInput> | TradeLedgerCreateWithoutAccountInput[] | TradeLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TradeLedgerCreateOrConnectWithoutAccountInput | TradeLedgerCreateOrConnectWithoutAccountInput[]
    createMany?: TradeLedgerCreateManyAccountInputEnvelope
    connect?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
  }

  export type InrWalletCreateNestedOneWithoutAccountInput = {
    create?: XOR<InrWalletCreateWithoutAccountInput, InrWalletUncheckedCreateWithoutAccountInput>
    connectOrCreate?: InrWalletCreateOrConnectWithoutAccountInput
    connect?: InrWalletWhereUniqueInput
  }

  export type CryptoWalletCreateNestedManyWithoutAccountInput = {
    create?: XOR<CryptoWalletCreateWithoutAccountInput, CryptoWalletUncheckedCreateWithoutAccountInput> | CryptoWalletCreateWithoutAccountInput[] | CryptoWalletUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutAccountInput | CryptoWalletCreateOrConnectWithoutAccountInput[]
    createMany?: CryptoWalletCreateManyAccountInputEnvelope
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
  }

  export type InrConversionHistoryCreateNestedManyWithoutAccountInput = {
    create?: XOR<InrConversionHistoryCreateWithoutAccountInput, InrConversionHistoryUncheckedCreateWithoutAccountInput> | InrConversionHistoryCreateWithoutAccountInput[] | InrConversionHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InrConversionHistoryCreateOrConnectWithoutAccountInput | InrConversionHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: InrConversionHistoryCreateManyAccountInputEnvelope
    connect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
  }

  export type InrLedgerUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<InrLedgerCreateWithoutAccountInput, InrLedgerUncheckedCreateWithoutAccountInput> | InrLedgerCreateWithoutAccountInput[] | InrLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InrLedgerCreateOrConnectWithoutAccountInput | InrLedgerCreateOrConnectWithoutAccountInput[]
    createMany?: InrLedgerCreateManyAccountInputEnvelope
    connect?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
  }

  export type CryptoLedgerUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CryptoLedgerCreateWithoutAccountInput, CryptoLedgerUncheckedCreateWithoutAccountInput> | CryptoLedgerCreateWithoutAccountInput[] | CryptoLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CryptoLedgerCreateOrConnectWithoutAccountInput | CryptoLedgerCreateOrConnectWithoutAccountInput[]
    createMany?: CryptoLedgerCreateManyAccountInputEnvelope
    connect?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
  }

  export type TradeLedgerUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TradeLedgerCreateWithoutAccountInput, TradeLedgerUncheckedCreateWithoutAccountInput> | TradeLedgerCreateWithoutAccountInput[] | TradeLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TradeLedgerCreateOrConnectWithoutAccountInput | TradeLedgerCreateOrConnectWithoutAccountInput[]
    createMany?: TradeLedgerCreateManyAccountInputEnvelope
    connect?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
  }

  export type InrWalletUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<InrWalletCreateWithoutAccountInput, InrWalletUncheckedCreateWithoutAccountInput>
    connectOrCreate?: InrWalletCreateOrConnectWithoutAccountInput
    connect?: InrWalletWhereUniqueInput
  }

  export type CryptoWalletUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CryptoWalletCreateWithoutAccountInput, CryptoWalletUncheckedCreateWithoutAccountInput> | CryptoWalletCreateWithoutAccountInput[] | CryptoWalletUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutAccountInput | CryptoWalletCreateOrConnectWithoutAccountInput[]
    createMany?: CryptoWalletCreateManyAccountInputEnvelope
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
  }

  export type InrConversionHistoryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<InrConversionHistoryCreateWithoutAccountInput, InrConversionHistoryUncheckedCreateWithoutAccountInput> | InrConversionHistoryCreateWithoutAccountInput[] | InrConversionHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InrConversionHistoryCreateOrConnectWithoutAccountInput | InrConversionHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: InrConversionHistoryCreateManyAccountInputEnvelope
    connect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumUserAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserAccountType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutUserAccountRelNestedInput = {
    create?: XOR<UserCreateWithoutUserAccountRelInput, UserUncheckedCreateWithoutUserAccountRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAccountRelInput
    upsert?: UserUpsertWithoutUserAccountRelInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAccountRelInput, UserUpdateWithoutUserAccountRelInput>, UserUncheckedUpdateWithoutUserAccountRelInput>
  }

  export type InrLedgerUpdateManyWithoutAccountNestedInput = {
    create?: XOR<InrLedgerCreateWithoutAccountInput, InrLedgerUncheckedCreateWithoutAccountInput> | InrLedgerCreateWithoutAccountInput[] | InrLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InrLedgerCreateOrConnectWithoutAccountInput | InrLedgerCreateOrConnectWithoutAccountInput[]
    upsert?: InrLedgerUpsertWithWhereUniqueWithoutAccountInput | InrLedgerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: InrLedgerCreateManyAccountInputEnvelope
    set?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
    disconnect?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
    delete?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
    connect?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
    update?: InrLedgerUpdateWithWhereUniqueWithoutAccountInput | InrLedgerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: InrLedgerUpdateManyWithWhereWithoutAccountInput | InrLedgerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: InrLedgerScalarWhereInput | InrLedgerScalarWhereInput[]
  }

  export type CryptoLedgerUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CryptoLedgerCreateWithoutAccountInput, CryptoLedgerUncheckedCreateWithoutAccountInput> | CryptoLedgerCreateWithoutAccountInput[] | CryptoLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CryptoLedgerCreateOrConnectWithoutAccountInput | CryptoLedgerCreateOrConnectWithoutAccountInput[]
    upsert?: CryptoLedgerUpsertWithWhereUniqueWithoutAccountInput | CryptoLedgerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CryptoLedgerCreateManyAccountInputEnvelope
    set?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
    disconnect?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
    delete?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
    connect?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
    update?: CryptoLedgerUpdateWithWhereUniqueWithoutAccountInput | CryptoLedgerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CryptoLedgerUpdateManyWithWhereWithoutAccountInput | CryptoLedgerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CryptoLedgerScalarWhereInput | CryptoLedgerScalarWhereInput[]
  }

  export type TradeLedgerUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TradeLedgerCreateWithoutAccountInput, TradeLedgerUncheckedCreateWithoutAccountInput> | TradeLedgerCreateWithoutAccountInput[] | TradeLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TradeLedgerCreateOrConnectWithoutAccountInput | TradeLedgerCreateOrConnectWithoutAccountInput[]
    upsert?: TradeLedgerUpsertWithWhereUniqueWithoutAccountInput | TradeLedgerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TradeLedgerCreateManyAccountInputEnvelope
    set?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
    disconnect?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
    delete?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
    connect?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
    update?: TradeLedgerUpdateWithWhereUniqueWithoutAccountInput | TradeLedgerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TradeLedgerUpdateManyWithWhereWithoutAccountInput | TradeLedgerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TradeLedgerScalarWhereInput | TradeLedgerScalarWhereInput[]
  }

  export type InrWalletUpdateOneWithoutAccountNestedInput = {
    create?: XOR<InrWalletCreateWithoutAccountInput, InrWalletUncheckedCreateWithoutAccountInput>
    connectOrCreate?: InrWalletCreateOrConnectWithoutAccountInput
    upsert?: InrWalletUpsertWithoutAccountInput
    disconnect?: InrWalletWhereInput | boolean
    delete?: InrWalletWhereInput | boolean
    connect?: InrWalletWhereUniqueInput
    update?: XOR<XOR<InrWalletUpdateToOneWithWhereWithoutAccountInput, InrWalletUpdateWithoutAccountInput>, InrWalletUncheckedUpdateWithoutAccountInput>
  }

  export type CryptoWalletUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutAccountInput, CryptoWalletUncheckedCreateWithoutAccountInput> | CryptoWalletCreateWithoutAccountInput[] | CryptoWalletUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutAccountInput | CryptoWalletCreateOrConnectWithoutAccountInput[]
    upsert?: CryptoWalletUpsertWithWhereUniqueWithoutAccountInput | CryptoWalletUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CryptoWalletCreateManyAccountInputEnvelope
    set?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    disconnect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    delete?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    update?: CryptoWalletUpdateWithWhereUniqueWithoutAccountInput | CryptoWalletUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CryptoWalletUpdateManyWithWhereWithoutAccountInput | CryptoWalletUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
  }

  export type InrConversionHistoryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<InrConversionHistoryCreateWithoutAccountInput, InrConversionHistoryUncheckedCreateWithoutAccountInput> | InrConversionHistoryCreateWithoutAccountInput[] | InrConversionHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InrConversionHistoryCreateOrConnectWithoutAccountInput | InrConversionHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: InrConversionHistoryUpsertWithWhereUniqueWithoutAccountInput | InrConversionHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: InrConversionHistoryCreateManyAccountInputEnvelope
    set?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    disconnect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    delete?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    connect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    update?: InrConversionHistoryUpdateWithWhereUniqueWithoutAccountInput | InrConversionHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: InrConversionHistoryUpdateManyWithWhereWithoutAccountInput | InrConversionHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: InrConversionHistoryScalarWhereInput | InrConversionHistoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InrLedgerUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<InrLedgerCreateWithoutAccountInput, InrLedgerUncheckedCreateWithoutAccountInput> | InrLedgerCreateWithoutAccountInput[] | InrLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InrLedgerCreateOrConnectWithoutAccountInput | InrLedgerCreateOrConnectWithoutAccountInput[]
    upsert?: InrLedgerUpsertWithWhereUniqueWithoutAccountInput | InrLedgerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: InrLedgerCreateManyAccountInputEnvelope
    set?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
    disconnect?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
    delete?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
    connect?: InrLedgerWhereUniqueInput | InrLedgerWhereUniqueInput[]
    update?: InrLedgerUpdateWithWhereUniqueWithoutAccountInput | InrLedgerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: InrLedgerUpdateManyWithWhereWithoutAccountInput | InrLedgerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: InrLedgerScalarWhereInput | InrLedgerScalarWhereInput[]
  }

  export type CryptoLedgerUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CryptoLedgerCreateWithoutAccountInput, CryptoLedgerUncheckedCreateWithoutAccountInput> | CryptoLedgerCreateWithoutAccountInput[] | CryptoLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CryptoLedgerCreateOrConnectWithoutAccountInput | CryptoLedgerCreateOrConnectWithoutAccountInput[]
    upsert?: CryptoLedgerUpsertWithWhereUniqueWithoutAccountInput | CryptoLedgerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CryptoLedgerCreateManyAccountInputEnvelope
    set?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
    disconnect?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
    delete?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
    connect?: CryptoLedgerWhereUniqueInput | CryptoLedgerWhereUniqueInput[]
    update?: CryptoLedgerUpdateWithWhereUniqueWithoutAccountInput | CryptoLedgerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CryptoLedgerUpdateManyWithWhereWithoutAccountInput | CryptoLedgerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CryptoLedgerScalarWhereInput | CryptoLedgerScalarWhereInput[]
  }

  export type TradeLedgerUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TradeLedgerCreateWithoutAccountInput, TradeLedgerUncheckedCreateWithoutAccountInput> | TradeLedgerCreateWithoutAccountInput[] | TradeLedgerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TradeLedgerCreateOrConnectWithoutAccountInput | TradeLedgerCreateOrConnectWithoutAccountInput[]
    upsert?: TradeLedgerUpsertWithWhereUniqueWithoutAccountInput | TradeLedgerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TradeLedgerCreateManyAccountInputEnvelope
    set?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
    disconnect?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
    delete?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
    connect?: TradeLedgerWhereUniqueInput | TradeLedgerWhereUniqueInput[]
    update?: TradeLedgerUpdateWithWhereUniqueWithoutAccountInput | TradeLedgerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TradeLedgerUpdateManyWithWhereWithoutAccountInput | TradeLedgerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TradeLedgerScalarWhereInput | TradeLedgerScalarWhereInput[]
  }

  export type InrWalletUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<InrWalletCreateWithoutAccountInput, InrWalletUncheckedCreateWithoutAccountInput>
    connectOrCreate?: InrWalletCreateOrConnectWithoutAccountInput
    upsert?: InrWalletUpsertWithoutAccountInput
    disconnect?: InrWalletWhereInput | boolean
    delete?: InrWalletWhereInput | boolean
    connect?: InrWalletWhereUniqueInput
    update?: XOR<XOR<InrWalletUpdateToOneWithWhereWithoutAccountInput, InrWalletUpdateWithoutAccountInput>, InrWalletUncheckedUpdateWithoutAccountInput>
  }

  export type CryptoWalletUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutAccountInput, CryptoWalletUncheckedCreateWithoutAccountInput> | CryptoWalletCreateWithoutAccountInput[] | CryptoWalletUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutAccountInput | CryptoWalletCreateOrConnectWithoutAccountInput[]
    upsert?: CryptoWalletUpsertWithWhereUniqueWithoutAccountInput | CryptoWalletUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CryptoWalletCreateManyAccountInputEnvelope
    set?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    disconnect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    delete?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    update?: CryptoWalletUpdateWithWhereUniqueWithoutAccountInput | CryptoWalletUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CryptoWalletUpdateManyWithWhereWithoutAccountInput | CryptoWalletUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
  }

  export type InrConversionHistoryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<InrConversionHistoryCreateWithoutAccountInput, InrConversionHistoryUncheckedCreateWithoutAccountInput> | InrConversionHistoryCreateWithoutAccountInput[] | InrConversionHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InrConversionHistoryCreateOrConnectWithoutAccountInput | InrConversionHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: InrConversionHistoryUpsertWithWhereUniqueWithoutAccountInput | InrConversionHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: InrConversionHistoryCreateManyAccountInputEnvelope
    set?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    disconnect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    delete?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    connect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    update?: InrConversionHistoryUpdateWithWhereUniqueWithoutAccountInput | InrConversionHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: InrConversionHistoryUpdateManyWithWhereWithoutAccountInput | InrConversionHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: InrConversionHistoryScalarWhereInput | InrConversionHistoryScalarWhereInput[]
  }

  export type UserKycCreateNestedOneWithoutUserRelInput = {
    create?: XOR<UserKycCreateWithoutUserRelInput, UserKycUncheckedCreateWithoutUserRelInput>
    connectOrCreate?: UserKycCreateOrConnectWithoutUserRelInput
    connect?: UserKycWhereUniqueInput
  }

  export type UserBankDetailsCreateNestedOneWithoutUserRelInput = {
    create?: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput>
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutUserRelInput
    connect?: UserBankDetailsWhereUniqueInput
  }

  export type UserBankDetailsCreateNestedManyWithoutUserRelInput = {
    create?: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput> | UserBankDetailsCreateWithoutUserRelInput[] | UserBankDetailsUncheckedCreateWithoutUserRelInput[]
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutUserRelInput | UserBankDetailsCreateOrConnectWithoutUserRelInput[]
    createMany?: UserBankDetailsCreateManyUserRelInputEnvelope
    connect?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
  }

  export type FiatPaymentsCreateNestedManyWithoutUserInput = {
    create?: XOR<FiatPaymentsCreateWithoutUserInput, FiatPaymentsUncheckedCreateWithoutUserInput> | FiatPaymentsCreateWithoutUserInput[] | FiatPaymentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutUserInput | FiatPaymentsCreateOrConnectWithoutUserInput[]
    createMany?: FiatPaymentsCreateManyUserInputEnvelope
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
  }

  export type UserAccountCreateNestedOneWithoutUserRelInput = {
    create?: XOR<UserAccountCreateWithoutUserRelInput, UserAccountUncheckedCreateWithoutUserRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutUserRelInput
    connect?: UserAccountWhereUniqueInput
  }

  export type TwoFACreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFACreateWithoutUserInput, TwoFAUncheckedCreateWithoutUserInput> | TwoFACreateWithoutUserInput[] | TwoFAUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFACreateOrConnectWithoutUserInput | TwoFACreateOrConnectWithoutUserInput[]
    createMany?: TwoFACreateManyUserInputEnvelope
    connect?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
  }

  export type UserBankDetailsUncheckedCreateNestedManyWithoutUserRelInput = {
    create?: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput> | UserBankDetailsCreateWithoutUserRelInput[] | UserBankDetailsUncheckedCreateWithoutUserRelInput[]
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutUserRelInput | UserBankDetailsCreateOrConnectWithoutUserRelInput[]
    createMany?: UserBankDetailsCreateManyUserRelInputEnvelope
    connect?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
  }

  export type FiatPaymentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FiatPaymentsCreateWithoutUserInput, FiatPaymentsUncheckedCreateWithoutUserInput> | FiatPaymentsCreateWithoutUserInput[] | FiatPaymentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutUserInput | FiatPaymentsCreateOrConnectWithoutUserInput[]
    createMany?: FiatPaymentsCreateManyUserInputEnvelope
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
  }

  export type UserAccountUncheckedCreateNestedOneWithoutUserRelInput = {
    create?: XOR<UserAccountCreateWithoutUserRelInput, UserAccountUncheckedCreateWithoutUserRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutUserRelInput
    connect?: UserAccountWhereUniqueInput
  }

  export type TwoFAUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFACreateWithoutUserInput, TwoFAUncheckedCreateWithoutUserInput> | TwoFACreateWithoutUserInput[] | TwoFAUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFACreateOrConnectWithoutUserInput | TwoFACreateOrConnectWithoutUserInput[]
    createMany?: TwoFACreateManyUserInputEnvelope
    connect?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type NullableEnumSignUpTypeFieldUpdateOperationsInput = {
    set?: $Enums.SignUpType | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserKycStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserKycStatus
  }

  export type EnumBankVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.BankVerificationStatus
  }

  export type UserKycUpdateOneWithoutUserRelNestedInput = {
    create?: XOR<UserKycCreateWithoutUserRelInput, UserKycUncheckedCreateWithoutUserRelInput>
    connectOrCreate?: UserKycCreateOrConnectWithoutUserRelInput
    upsert?: UserKycUpsertWithoutUserRelInput
    disconnect?: UserKycWhereInput | boolean
    delete?: UserKycWhereInput | boolean
    connect?: UserKycWhereUniqueInput
    update?: XOR<XOR<UserKycUpdateToOneWithWhereWithoutUserRelInput, UserKycUpdateWithoutUserRelInput>, UserKycUncheckedUpdateWithoutUserRelInput>
  }

  export type UserBankDetailsUpdateOneWithoutUserRelNestedInput = {
    create?: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput>
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutUserRelInput
    upsert?: UserBankDetailsUpsertWithoutUserRelInput
    disconnect?: UserBankDetailsWhereInput | boolean
    delete?: UserBankDetailsWhereInput | boolean
    connect?: UserBankDetailsWhereUniqueInput
    update?: XOR<XOR<UserBankDetailsUpdateToOneWithWhereWithoutUserRelInput, UserBankDetailsUpdateWithoutUserRelInput>, UserBankDetailsUncheckedUpdateWithoutUserRelInput>
  }

  export type UserBankDetailsUpdateManyWithoutUserRelNestedInput = {
    create?: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput> | UserBankDetailsCreateWithoutUserRelInput[] | UserBankDetailsUncheckedCreateWithoutUserRelInput[]
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutUserRelInput | UserBankDetailsCreateOrConnectWithoutUserRelInput[]
    upsert?: UserBankDetailsUpsertWithWhereUniqueWithoutUserRelInput | UserBankDetailsUpsertWithWhereUniqueWithoutUserRelInput[]
    createMany?: UserBankDetailsCreateManyUserRelInputEnvelope
    set?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
    disconnect?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
    delete?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
    connect?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
    update?: UserBankDetailsUpdateWithWhereUniqueWithoutUserRelInput | UserBankDetailsUpdateWithWhereUniqueWithoutUserRelInput[]
    updateMany?: UserBankDetailsUpdateManyWithWhereWithoutUserRelInput | UserBankDetailsUpdateManyWithWhereWithoutUserRelInput[]
    deleteMany?: UserBankDetailsScalarWhereInput | UserBankDetailsScalarWhereInput[]
  }

  export type FiatPaymentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<FiatPaymentsCreateWithoutUserInput, FiatPaymentsUncheckedCreateWithoutUserInput> | FiatPaymentsCreateWithoutUserInput[] | FiatPaymentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutUserInput | FiatPaymentsCreateOrConnectWithoutUserInput[]
    upsert?: FiatPaymentsUpsertWithWhereUniqueWithoutUserInput | FiatPaymentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FiatPaymentsCreateManyUserInputEnvelope
    set?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    disconnect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    delete?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    update?: FiatPaymentsUpdateWithWhereUniqueWithoutUserInput | FiatPaymentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FiatPaymentsUpdateManyWithWhereWithoutUserInput | FiatPaymentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FiatPaymentsScalarWhereInput | FiatPaymentsScalarWhereInput[]
  }

  export type UserAccountUpdateOneWithoutUserRelNestedInput = {
    create?: XOR<UserAccountCreateWithoutUserRelInput, UserAccountUncheckedCreateWithoutUserRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutUserRelInput
    upsert?: UserAccountUpsertWithoutUserRelInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutUserRelInput, UserAccountUpdateWithoutUserRelInput>, UserAccountUncheckedUpdateWithoutUserRelInput>
  }

  export type TwoFAUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFACreateWithoutUserInput, TwoFAUncheckedCreateWithoutUserInput> | TwoFACreateWithoutUserInput[] | TwoFAUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFACreateOrConnectWithoutUserInput | TwoFACreateOrConnectWithoutUserInput[]
    upsert?: TwoFAUpsertWithWhereUniqueWithoutUserInput | TwoFAUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFACreateManyUserInputEnvelope
    set?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
    disconnect?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
    delete?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
    connect?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
    update?: TwoFAUpdateWithWhereUniqueWithoutUserInput | TwoFAUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFAUpdateManyWithWhereWithoutUserInput | TwoFAUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFAScalarWhereInput | TwoFAScalarWhereInput[]
  }

  export type UserBankDetailsUncheckedUpdateManyWithoutUserRelNestedInput = {
    create?: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput> | UserBankDetailsCreateWithoutUserRelInput[] | UserBankDetailsUncheckedCreateWithoutUserRelInput[]
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutUserRelInput | UserBankDetailsCreateOrConnectWithoutUserRelInput[]
    upsert?: UserBankDetailsUpsertWithWhereUniqueWithoutUserRelInput | UserBankDetailsUpsertWithWhereUniqueWithoutUserRelInput[]
    createMany?: UserBankDetailsCreateManyUserRelInputEnvelope
    set?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
    disconnect?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
    delete?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
    connect?: UserBankDetailsWhereUniqueInput | UserBankDetailsWhereUniqueInput[]
    update?: UserBankDetailsUpdateWithWhereUniqueWithoutUserRelInput | UserBankDetailsUpdateWithWhereUniqueWithoutUserRelInput[]
    updateMany?: UserBankDetailsUpdateManyWithWhereWithoutUserRelInput | UserBankDetailsUpdateManyWithWhereWithoutUserRelInput[]
    deleteMany?: UserBankDetailsScalarWhereInput | UserBankDetailsScalarWhereInput[]
  }

  export type FiatPaymentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FiatPaymentsCreateWithoutUserInput, FiatPaymentsUncheckedCreateWithoutUserInput> | FiatPaymentsCreateWithoutUserInput[] | FiatPaymentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutUserInput | FiatPaymentsCreateOrConnectWithoutUserInput[]
    upsert?: FiatPaymentsUpsertWithWhereUniqueWithoutUserInput | FiatPaymentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FiatPaymentsCreateManyUserInputEnvelope
    set?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    disconnect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    delete?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    update?: FiatPaymentsUpdateWithWhereUniqueWithoutUserInput | FiatPaymentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FiatPaymentsUpdateManyWithWhereWithoutUserInput | FiatPaymentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FiatPaymentsScalarWhereInput | FiatPaymentsScalarWhereInput[]
  }

  export type UserAccountUncheckedUpdateOneWithoutUserRelNestedInput = {
    create?: XOR<UserAccountCreateWithoutUserRelInput, UserAccountUncheckedCreateWithoutUserRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutUserRelInput
    upsert?: UserAccountUpsertWithoutUserRelInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutUserRelInput, UserAccountUpdateWithoutUserRelInput>, UserAccountUncheckedUpdateWithoutUserRelInput>
  }

  export type TwoFAUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFACreateWithoutUserInput, TwoFAUncheckedCreateWithoutUserInput> | TwoFACreateWithoutUserInput[] | TwoFAUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFACreateOrConnectWithoutUserInput | TwoFACreateOrConnectWithoutUserInput[]
    upsert?: TwoFAUpsertWithWhereUniqueWithoutUserInput | TwoFAUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFACreateManyUserInputEnvelope
    set?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
    disconnect?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
    delete?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
    connect?: TwoFAWhereUniqueInput | TwoFAWhereUniqueInput[]
    update?: TwoFAUpdateWithWhereUniqueWithoutUserInput | TwoFAUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFAUpdateManyWithWhereWithoutUserInput | TwoFAUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFAScalarWhereInput | TwoFAScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutTwoFARelInput = {
    create?: XOR<UserCreateWithoutTwoFARelInput, UserUncheckedCreateWithoutTwoFARelInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFARelInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTwoFAStatusFieldUpdateOperationsInput = {
    set?: $Enums.TwoFAStatus
  }

  export type EnumReasonFieldUpdateOperationsInput = {
    set?: $Enums.Reason
  }

  export type UserUpdateOneRequiredWithoutTwoFARelNestedInput = {
    create?: XOR<UserCreateWithoutTwoFARelInput, UserUncheckedCreateWithoutTwoFARelInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFARelInput
    upsert?: UserUpsertWithoutTwoFARelInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwoFARelInput, UserUpdateWithoutTwoFARelInput>, UserUncheckedUpdateWithoutTwoFARelInput>
  }

  export type EncryptedUserDataCreateNestedOneWithoutUserKycInput = {
    create?: XOR<EncryptedUserDataCreateWithoutUserKycInput, EncryptedUserDataUncheckedCreateWithoutUserKycInput>
    connectOrCreate?: EncryptedUserDataCreateOrConnectWithoutUserKycInput
    connect?: EncryptedUserDataWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserKycRelInput = {
    create?: XOR<UserCreateWithoutUserKycRelInput, UserUncheckedCreateWithoutUserKycRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserKycRelInput
    connect?: UserWhereUniqueInput
  }

  export type UserUncheckedCreateNestedOneWithoutUserKycRelInput = {
    create?: XOR<UserCreateWithoutUserKycRelInput, UserUncheckedCreateWithoutUserKycRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserKycRelInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type EnumKycTypeFieldUpdateOperationsInput = {
    set?: $Enums.KycType
  }

  export type NullableEnumHypervergeStatusFieldUpdateOperationsInput = {
    set?: $Enums.HypervergeStatus | null
  }

  export type EncryptedUserDataUpdateOneWithoutUserKycNestedInput = {
    create?: XOR<EncryptedUserDataCreateWithoutUserKycInput, EncryptedUserDataUncheckedCreateWithoutUserKycInput>
    connectOrCreate?: EncryptedUserDataCreateOrConnectWithoutUserKycInput
    upsert?: EncryptedUserDataUpsertWithoutUserKycInput
    disconnect?: EncryptedUserDataWhereInput | boolean
    delete?: EncryptedUserDataWhereInput | boolean
    connect?: EncryptedUserDataWhereUniqueInput
    update?: XOR<XOR<EncryptedUserDataUpdateToOneWithWhereWithoutUserKycInput, EncryptedUserDataUpdateWithoutUserKycInput>, EncryptedUserDataUncheckedUpdateWithoutUserKycInput>
  }

  export type UserUpdateOneWithoutUserKycRelNestedInput = {
    create?: XOR<UserCreateWithoutUserKycRelInput, UserUncheckedCreateWithoutUserKycRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserKycRelInput
    upsert?: UserUpsertWithoutUserKycRelInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserKycRelInput, UserUpdateWithoutUserKycRelInput>, UserUncheckedUpdateWithoutUserKycRelInput>
  }

  export type UserUncheckedUpdateOneWithoutUserKycRelNestedInput = {
    create?: XOR<UserCreateWithoutUserKycRelInput, UserUncheckedCreateWithoutUserKycRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserKycRelInput
    upsert?: UserUpsertWithoutUserKycRelInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserKycRelInput, UserUpdateWithoutUserKycRelInput>, UserUncheckedUpdateWithoutUserKycRelInput>
  }

  export type UserKycCreateNestedOneWithoutEncryptedUserDataRelInput = {
    create?: XOR<UserKycCreateWithoutEncryptedUserDataRelInput, UserKycUncheckedCreateWithoutEncryptedUserDataRelInput>
    connectOrCreate?: UserKycCreateOrConnectWithoutEncryptedUserDataRelInput
    connect?: UserKycWhereUniqueInput
  }

  export type UserKycUncheckedCreateNestedOneWithoutEncryptedUserDataRelInput = {
    create?: XOR<UserKycCreateWithoutEncryptedUserDataRelInput, UserKycUncheckedCreateWithoutEncryptedUserDataRelInput>
    connectOrCreate?: UserKycCreateOrConnectWithoutEncryptedUserDataRelInput
    connect?: UserKycWhereUniqueInput
  }

  export type UserKycUpdateOneWithoutEncryptedUserDataRelNestedInput = {
    create?: XOR<UserKycCreateWithoutEncryptedUserDataRelInput, UserKycUncheckedCreateWithoutEncryptedUserDataRelInput>
    connectOrCreate?: UserKycCreateOrConnectWithoutEncryptedUserDataRelInput
    upsert?: UserKycUpsertWithoutEncryptedUserDataRelInput
    disconnect?: UserKycWhereInput | boolean
    delete?: UserKycWhereInput | boolean
    connect?: UserKycWhereUniqueInput
    update?: XOR<XOR<UserKycUpdateToOneWithWhereWithoutEncryptedUserDataRelInput, UserKycUpdateWithoutEncryptedUserDataRelInput>, UserKycUncheckedUpdateWithoutEncryptedUserDataRelInput>
  }

  export type UserKycUncheckedUpdateOneWithoutEncryptedUserDataRelNestedInput = {
    create?: XOR<UserKycCreateWithoutEncryptedUserDataRelInput, UserKycUncheckedCreateWithoutEncryptedUserDataRelInput>
    connectOrCreate?: UserKycCreateOrConnectWithoutEncryptedUserDataRelInput
    upsert?: UserKycUpsertWithoutEncryptedUserDataRelInput
    disconnect?: UserKycWhereInput | boolean
    delete?: UserKycWhereInput | boolean
    connect?: UserKycWhereUniqueInput
    update?: XOR<XOR<UserKycUpdateToOneWithWhereWithoutEncryptedUserDataRelInput, UserKycUpdateWithoutEncryptedUserDataRelInput>, UserKycUncheckedUpdateWithoutEncryptedUserDataRelInput>
  }

  export type UserCreateNestedOneWithoutUserBankDetailsRelInput = {
    create?: XOR<UserCreateWithoutUserBankDetailsRelInput, UserUncheckedCreateWithoutUserBankDetailsRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBankDetailsRelInput
    connect?: UserWhereUniqueInput
  }

  export type FiatPaymentsCreateNestedManyWithoutUserBankRelInput = {
    create?: XOR<FiatPaymentsCreateWithoutUserBankRelInput, FiatPaymentsUncheckedCreateWithoutUserBankRelInput> | FiatPaymentsCreateWithoutUserBankRelInput[] | FiatPaymentsUncheckedCreateWithoutUserBankRelInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutUserBankRelInput | FiatPaymentsCreateOrConnectWithoutUserBankRelInput[]
    createMany?: FiatPaymentsCreateManyUserBankRelInputEnvelope
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
  }

  export type FiatPaymentsCreateNestedManyWithoutSystemBankRelInput = {
    create?: XOR<FiatPaymentsCreateWithoutSystemBankRelInput, FiatPaymentsUncheckedCreateWithoutSystemBankRelInput> | FiatPaymentsCreateWithoutSystemBankRelInput[] | FiatPaymentsUncheckedCreateWithoutSystemBankRelInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutSystemBankRelInput | FiatPaymentsCreateOrConnectWithoutSystemBankRelInput[]
    createMany?: FiatPaymentsCreateManySystemBankRelInputEnvelope
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBankDetailRelInput = {
    create?: XOR<UserCreateWithoutBankDetailRelInput, UserUncheckedCreateWithoutBankDetailRelInput> | UserCreateWithoutBankDetailRelInput[] | UserUncheckedCreateWithoutBankDetailRelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBankDetailRelInput | UserCreateOrConnectWithoutBankDetailRelInput[]
    createMany?: UserCreateManyBankDetailRelInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type FiatPaymentsUncheckedCreateNestedManyWithoutUserBankRelInput = {
    create?: XOR<FiatPaymentsCreateWithoutUserBankRelInput, FiatPaymentsUncheckedCreateWithoutUserBankRelInput> | FiatPaymentsCreateWithoutUserBankRelInput[] | FiatPaymentsUncheckedCreateWithoutUserBankRelInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutUserBankRelInput | FiatPaymentsCreateOrConnectWithoutUserBankRelInput[]
    createMany?: FiatPaymentsCreateManyUserBankRelInputEnvelope
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
  }

  export type FiatPaymentsUncheckedCreateNestedManyWithoutSystemBankRelInput = {
    create?: XOR<FiatPaymentsCreateWithoutSystemBankRelInput, FiatPaymentsUncheckedCreateWithoutSystemBankRelInput> | FiatPaymentsCreateWithoutSystemBankRelInput[] | FiatPaymentsUncheckedCreateWithoutSystemBankRelInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutSystemBankRelInput | FiatPaymentsCreateOrConnectWithoutSystemBankRelInput[]
    createMany?: FiatPaymentsCreateManySystemBankRelInputEnvelope
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBankDetailRelInput = {
    create?: XOR<UserCreateWithoutBankDetailRelInput, UserUncheckedCreateWithoutBankDetailRelInput> | UserCreateWithoutBankDetailRelInput[] | UserUncheckedCreateWithoutBankDetailRelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBankDetailRelInput | UserCreateOrConnectWithoutBankDetailRelInput[]
    createMany?: UserCreateManyBankDetailRelInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumBankDetailsTypeFieldUpdateOperationsInput = {
    set?: $Enums.BankDetailsType
  }

  export type UserUpdateOneWithoutUserBankDetailsRelNestedInput = {
    create?: XOR<UserCreateWithoutUserBankDetailsRelInput, UserUncheckedCreateWithoutUserBankDetailsRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBankDetailsRelInput
    upsert?: UserUpsertWithoutUserBankDetailsRelInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserBankDetailsRelInput, UserUpdateWithoutUserBankDetailsRelInput>, UserUncheckedUpdateWithoutUserBankDetailsRelInput>
  }

  export type FiatPaymentsUpdateManyWithoutUserBankRelNestedInput = {
    create?: XOR<FiatPaymentsCreateWithoutUserBankRelInput, FiatPaymentsUncheckedCreateWithoutUserBankRelInput> | FiatPaymentsCreateWithoutUserBankRelInput[] | FiatPaymentsUncheckedCreateWithoutUserBankRelInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutUserBankRelInput | FiatPaymentsCreateOrConnectWithoutUserBankRelInput[]
    upsert?: FiatPaymentsUpsertWithWhereUniqueWithoutUserBankRelInput | FiatPaymentsUpsertWithWhereUniqueWithoutUserBankRelInput[]
    createMany?: FiatPaymentsCreateManyUserBankRelInputEnvelope
    set?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    disconnect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    delete?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    update?: FiatPaymentsUpdateWithWhereUniqueWithoutUserBankRelInput | FiatPaymentsUpdateWithWhereUniqueWithoutUserBankRelInput[]
    updateMany?: FiatPaymentsUpdateManyWithWhereWithoutUserBankRelInput | FiatPaymentsUpdateManyWithWhereWithoutUserBankRelInput[]
    deleteMany?: FiatPaymentsScalarWhereInput | FiatPaymentsScalarWhereInput[]
  }

  export type FiatPaymentsUpdateManyWithoutSystemBankRelNestedInput = {
    create?: XOR<FiatPaymentsCreateWithoutSystemBankRelInput, FiatPaymentsUncheckedCreateWithoutSystemBankRelInput> | FiatPaymentsCreateWithoutSystemBankRelInput[] | FiatPaymentsUncheckedCreateWithoutSystemBankRelInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutSystemBankRelInput | FiatPaymentsCreateOrConnectWithoutSystemBankRelInput[]
    upsert?: FiatPaymentsUpsertWithWhereUniqueWithoutSystemBankRelInput | FiatPaymentsUpsertWithWhereUniqueWithoutSystemBankRelInput[]
    createMany?: FiatPaymentsCreateManySystemBankRelInputEnvelope
    set?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    disconnect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    delete?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    update?: FiatPaymentsUpdateWithWhereUniqueWithoutSystemBankRelInput | FiatPaymentsUpdateWithWhereUniqueWithoutSystemBankRelInput[]
    updateMany?: FiatPaymentsUpdateManyWithWhereWithoutSystemBankRelInput | FiatPaymentsUpdateManyWithWhereWithoutSystemBankRelInput[]
    deleteMany?: FiatPaymentsScalarWhereInput | FiatPaymentsScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBankDetailRelNestedInput = {
    create?: XOR<UserCreateWithoutBankDetailRelInput, UserUncheckedCreateWithoutBankDetailRelInput> | UserCreateWithoutBankDetailRelInput[] | UserUncheckedCreateWithoutBankDetailRelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBankDetailRelInput | UserCreateOrConnectWithoutBankDetailRelInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBankDetailRelInput | UserUpsertWithWhereUniqueWithoutBankDetailRelInput[]
    createMany?: UserCreateManyBankDetailRelInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBankDetailRelInput | UserUpdateWithWhereUniqueWithoutBankDetailRelInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBankDetailRelInput | UserUpdateManyWithWhereWithoutBankDetailRelInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type FiatPaymentsUncheckedUpdateManyWithoutUserBankRelNestedInput = {
    create?: XOR<FiatPaymentsCreateWithoutUserBankRelInput, FiatPaymentsUncheckedCreateWithoutUserBankRelInput> | FiatPaymentsCreateWithoutUserBankRelInput[] | FiatPaymentsUncheckedCreateWithoutUserBankRelInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutUserBankRelInput | FiatPaymentsCreateOrConnectWithoutUserBankRelInput[]
    upsert?: FiatPaymentsUpsertWithWhereUniqueWithoutUserBankRelInput | FiatPaymentsUpsertWithWhereUniqueWithoutUserBankRelInput[]
    createMany?: FiatPaymentsCreateManyUserBankRelInputEnvelope
    set?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    disconnect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    delete?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    update?: FiatPaymentsUpdateWithWhereUniqueWithoutUserBankRelInput | FiatPaymentsUpdateWithWhereUniqueWithoutUserBankRelInput[]
    updateMany?: FiatPaymentsUpdateManyWithWhereWithoutUserBankRelInput | FiatPaymentsUpdateManyWithWhereWithoutUserBankRelInput[]
    deleteMany?: FiatPaymentsScalarWhereInput | FiatPaymentsScalarWhereInput[]
  }

  export type FiatPaymentsUncheckedUpdateManyWithoutSystemBankRelNestedInput = {
    create?: XOR<FiatPaymentsCreateWithoutSystemBankRelInput, FiatPaymentsUncheckedCreateWithoutSystemBankRelInput> | FiatPaymentsCreateWithoutSystemBankRelInput[] | FiatPaymentsUncheckedCreateWithoutSystemBankRelInput[]
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutSystemBankRelInput | FiatPaymentsCreateOrConnectWithoutSystemBankRelInput[]
    upsert?: FiatPaymentsUpsertWithWhereUniqueWithoutSystemBankRelInput | FiatPaymentsUpsertWithWhereUniqueWithoutSystemBankRelInput[]
    createMany?: FiatPaymentsCreateManySystemBankRelInputEnvelope
    set?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    disconnect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    delete?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    connect?: FiatPaymentsWhereUniqueInput | FiatPaymentsWhereUniqueInput[]
    update?: FiatPaymentsUpdateWithWhereUniqueWithoutSystemBankRelInput | FiatPaymentsUpdateWithWhereUniqueWithoutSystemBankRelInput[]
    updateMany?: FiatPaymentsUpdateManyWithWhereWithoutSystemBankRelInput | FiatPaymentsUpdateManyWithWhereWithoutSystemBankRelInput[]
    deleteMany?: FiatPaymentsScalarWhereInput | FiatPaymentsScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBankDetailRelNestedInput = {
    create?: XOR<UserCreateWithoutBankDetailRelInput, UserUncheckedCreateWithoutBankDetailRelInput> | UserCreateWithoutBankDetailRelInput[] | UserUncheckedCreateWithoutBankDetailRelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBankDetailRelInput | UserCreateOrConnectWithoutBankDetailRelInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBankDetailRelInput | UserUpsertWithWhereUniqueWithoutBankDetailRelInput[]
    createMany?: UserCreateManyBankDetailRelInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBankDetailRelInput | UserUpdateWithWhereUniqueWithoutBankDetailRelInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBankDetailRelInput | UserUpdateManyWithWhereWithoutBankDetailRelInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFiatPaymentsRelInput = {
    create?: XOR<UserCreateWithoutFiatPaymentsRelInput, UserUncheckedCreateWithoutFiatPaymentsRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutFiatPaymentsRelInput
    connect?: UserWhereUniqueInput
  }

  export type UserBankDetailsCreateNestedOneWithoutFiatPaymentsRelInput = {
    create?: XOR<UserBankDetailsCreateWithoutFiatPaymentsRelInput, UserBankDetailsUncheckedCreateWithoutFiatPaymentsRelInput>
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutFiatPaymentsRelInput
    connect?: UserBankDetailsWhereUniqueInput
  }

  export type UserBankDetailsCreateNestedOneWithoutUserBankRelInput = {
    create?: XOR<UserBankDetailsCreateWithoutUserBankRelInput, UserBankDetailsUncheckedCreateWithoutUserBankRelInput>
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutUserBankRelInput
    connect?: UserBankDetailsWhereUniqueInput
  }

  export type BankFeedCreateNestedOneWithoutFiatPaymentInput = {
    create?: XOR<BankFeedCreateWithoutFiatPaymentInput, BankFeedUncheckedCreateWithoutFiatPaymentInput>
    connectOrCreate?: BankFeedCreateOrConnectWithoutFiatPaymentInput
    connect?: BankFeedWhereUniqueInput
  }

  export type BankFeedUncheckedCreateNestedOneWithoutFiatPaymentInput = {
    create?: XOR<BankFeedCreateWithoutFiatPaymentInput, BankFeedUncheckedCreateWithoutFiatPaymentInput>
    connectOrCreate?: BankFeedCreateOrConnectWithoutFiatPaymentInput
    connect?: BankFeedWhereUniqueInput
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type UserUpdateOneWithoutFiatPaymentsRelNestedInput = {
    create?: XOR<UserCreateWithoutFiatPaymentsRelInput, UserUncheckedCreateWithoutFiatPaymentsRelInput>
    connectOrCreate?: UserCreateOrConnectWithoutFiatPaymentsRelInput
    upsert?: UserUpsertWithoutFiatPaymentsRelInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFiatPaymentsRelInput, UserUpdateWithoutFiatPaymentsRelInput>, UserUncheckedUpdateWithoutFiatPaymentsRelInput>
  }

  export type UserBankDetailsUpdateOneWithoutFiatPaymentsRelNestedInput = {
    create?: XOR<UserBankDetailsCreateWithoutFiatPaymentsRelInput, UserBankDetailsUncheckedCreateWithoutFiatPaymentsRelInput>
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutFiatPaymentsRelInput
    upsert?: UserBankDetailsUpsertWithoutFiatPaymentsRelInput
    disconnect?: UserBankDetailsWhereInput | boolean
    delete?: UserBankDetailsWhereInput | boolean
    connect?: UserBankDetailsWhereUniqueInput
    update?: XOR<XOR<UserBankDetailsUpdateToOneWithWhereWithoutFiatPaymentsRelInput, UserBankDetailsUpdateWithoutFiatPaymentsRelInput>, UserBankDetailsUncheckedUpdateWithoutFiatPaymentsRelInput>
  }

  export type UserBankDetailsUpdateOneWithoutUserBankRelNestedInput = {
    create?: XOR<UserBankDetailsCreateWithoutUserBankRelInput, UserBankDetailsUncheckedCreateWithoutUserBankRelInput>
    connectOrCreate?: UserBankDetailsCreateOrConnectWithoutUserBankRelInput
    upsert?: UserBankDetailsUpsertWithoutUserBankRelInput
    disconnect?: UserBankDetailsWhereInput | boolean
    delete?: UserBankDetailsWhereInput | boolean
    connect?: UserBankDetailsWhereUniqueInput
    update?: XOR<XOR<UserBankDetailsUpdateToOneWithWhereWithoutUserBankRelInput, UserBankDetailsUpdateWithoutUserBankRelInput>, UserBankDetailsUncheckedUpdateWithoutUserBankRelInput>
  }

  export type BankFeedUpdateOneWithoutFiatPaymentNestedInput = {
    create?: XOR<BankFeedCreateWithoutFiatPaymentInput, BankFeedUncheckedCreateWithoutFiatPaymentInput>
    connectOrCreate?: BankFeedCreateOrConnectWithoutFiatPaymentInput
    upsert?: BankFeedUpsertWithoutFiatPaymentInput
    disconnect?: BankFeedWhereInput | boolean
    delete?: BankFeedWhereInput | boolean
    connect?: BankFeedWhereUniqueInput
    update?: XOR<XOR<BankFeedUpdateToOneWithWhereWithoutFiatPaymentInput, BankFeedUpdateWithoutFiatPaymentInput>, BankFeedUncheckedUpdateWithoutFiatPaymentInput>
  }

  export type BankFeedUncheckedUpdateOneWithoutFiatPaymentNestedInput = {
    create?: XOR<BankFeedCreateWithoutFiatPaymentInput, BankFeedUncheckedCreateWithoutFiatPaymentInput>
    connectOrCreate?: BankFeedCreateOrConnectWithoutFiatPaymentInput
    upsert?: BankFeedUpsertWithoutFiatPaymentInput
    disconnect?: BankFeedWhereInput | boolean
    delete?: BankFeedWhereInput | boolean
    connect?: BankFeedWhereUniqueInput
    update?: XOR<XOR<BankFeedUpdateToOneWithWhereWithoutFiatPaymentInput, BankFeedUpdateWithoutFiatPaymentInput>, BankFeedUncheckedUpdateWithoutFiatPaymentInput>
  }

  export type CryptoDepositCreateinputsInput = {
    set: InputJsonValue[]
  }

  export type CryptoDepositCreateoutputsInput = {
    set: InputJsonValue[]
  }

  export type CryptoWalletCreateNestedOneWithoutCryptoDepositInput = {
    create?: XOR<CryptoWalletCreateWithoutCryptoDepositInput, CryptoWalletUncheckedCreateWithoutCryptoDepositInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutCryptoDepositInput
    connect?: CryptoWalletWhereUniqueInput
  }

  export type InrConversionHistoryCreateNestedManyWithoutCryptoDepositInput = {
    create?: XOR<InrConversionHistoryCreateWithoutCryptoDepositInput, InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput> | InrConversionHistoryCreateWithoutCryptoDepositInput[] | InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput[]
    connectOrCreate?: InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput | InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput[]
    createMany?: InrConversionHistoryCreateManyCryptoDepositInputEnvelope
    connect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
  }

  export type InrConversionHistoryUncheckedCreateNestedManyWithoutCryptoDepositInput = {
    create?: XOR<InrConversionHistoryCreateWithoutCryptoDepositInput, InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput> | InrConversionHistoryCreateWithoutCryptoDepositInput[] | InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput[]
    connectOrCreate?: InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput | InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput[]
    createMany?: InrConversionHistoryCreateManyCryptoDepositInputEnvelope
    connect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
  }

  export type CryptoDepositUpdateinputsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type CryptoDepositUpdateoutputsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnumInrCreditStatusFieldUpdateOperationsInput = {
    set?: $Enums.InrCreditStatus
  }

  export type CryptoWalletUpdateOneWithoutCryptoDepositNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutCryptoDepositInput, CryptoWalletUncheckedCreateWithoutCryptoDepositInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutCryptoDepositInput
    upsert?: CryptoWalletUpsertWithoutCryptoDepositInput
    disconnect?: CryptoWalletWhereInput | boolean
    delete?: CryptoWalletWhereInput | boolean
    connect?: CryptoWalletWhereUniqueInput
    update?: XOR<XOR<CryptoWalletUpdateToOneWithWhereWithoutCryptoDepositInput, CryptoWalletUpdateWithoutCryptoDepositInput>, CryptoWalletUncheckedUpdateWithoutCryptoDepositInput>
  }

  export type InrConversionHistoryUpdateManyWithoutCryptoDepositNestedInput = {
    create?: XOR<InrConversionHistoryCreateWithoutCryptoDepositInput, InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput> | InrConversionHistoryCreateWithoutCryptoDepositInput[] | InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput[]
    connectOrCreate?: InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput | InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput[]
    upsert?: InrConversionHistoryUpsertWithWhereUniqueWithoutCryptoDepositInput | InrConversionHistoryUpsertWithWhereUniqueWithoutCryptoDepositInput[]
    createMany?: InrConversionHistoryCreateManyCryptoDepositInputEnvelope
    set?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    disconnect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    delete?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    connect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    update?: InrConversionHistoryUpdateWithWhereUniqueWithoutCryptoDepositInput | InrConversionHistoryUpdateWithWhereUniqueWithoutCryptoDepositInput[]
    updateMany?: InrConversionHistoryUpdateManyWithWhereWithoutCryptoDepositInput | InrConversionHistoryUpdateManyWithWhereWithoutCryptoDepositInput[]
    deleteMany?: InrConversionHistoryScalarWhereInput | InrConversionHistoryScalarWhereInput[]
  }

  export type InrConversionHistoryUncheckedUpdateManyWithoutCryptoDepositNestedInput = {
    create?: XOR<InrConversionHistoryCreateWithoutCryptoDepositInput, InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput> | InrConversionHistoryCreateWithoutCryptoDepositInput[] | InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput[]
    connectOrCreate?: InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput | InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput[]
    upsert?: InrConversionHistoryUpsertWithWhereUniqueWithoutCryptoDepositInput | InrConversionHistoryUpsertWithWhereUniqueWithoutCryptoDepositInput[]
    createMany?: InrConversionHistoryCreateManyCryptoDepositInputEnvelope
    set?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    disconnect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    delete?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    connect?: InrConversionHistoryWhereUniqueInput | InrConversionHistoryWhereUniqueInput[]
    update?: InrConversionHistoryUpdateWithWhereUniqueWithoutCryptoDepositInput | InrConversionHistoryUpdateWithWhereUniqueWithoutCryptoDepositInput[]
    updateMany?: InrConversionHistoryUpdateManyWithWhereWithoutCryptoDepositInput | InrConversionHistoryUpdateManyWithWhereWithoutCryptoDepositInput[]
    deleteMany?: InrConversionHistoryScalarWhereInput | InrConversionHistoryScalarWhereInput[]
  }

  export type CryptoDepositCreateNestedOneWithoutInrConvHistRelInput = {
    create?: XOR<CryptoDepositCreateWithoutInrConvHistRelInput, CryptoDepositUncheckedCreateWithoutInrConvHistRelInput>
    connectOrCreate?: CryptoDepositCreateOrConnectWithoutInrConvHistRelInput
    connect?: CryptoDepositWhereUniqueInput
  }

  export type UserAccountCreateNestedOneWithoutInrConvRelInput = {
    create?: XOR<UserAccountCreateWithoutInrConvRelInput, UserAccountUncheckedCreateWithoutInrConvRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutInrConvRelInput
    connect?: UserAccountWhereUniqueInput
  }

  export type CryptoDepositUpdateOneWithoutInrConvHistRelNestedInput = {
    create?: XOR<CryptoDepositCreateWithoutInrConvHistRelInput, CryptoDepositUncheckedCreateWithoutInrConvHistRelInput>
    connectOrCreate?: CryptoDepositCreateOrConnectWithoutInrConvHistRelInput
    upsert?: CryptoDepositUpsertWithoutInrConvHistRelInput
    disconnect?: CryptoDepositWhereInput | boolean
    delete?: CryptoDepositWhereInput | boolean
    connect?: CryptoDepositWhereUniqueInput
    update?: XOR<XOR<CryptoDepositUpdateToOneWithWhereWithoutInrConvHistRelInput, CryptoDepositUpdateWithoutInrConvHistRelInput>, CryptoDepositUncheckedUpdateWithoutInrConvHistRelInput>
  }

  export type UserAccountUpdateOneRequiredWithoutInrConvRelNestedInput = {
    create?: XOR<UserAccountCreateWithoutInrConvRelInput, UserAccountUncheckedCreateWithoutInrConvRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutInrConvRelInput
    upsert?: UserAccountUpsertWithoutInrConvRelInput
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutInrConvRelInput, UserAccountUpdateWithoutInrConvRelInput>, UserAccountUncheckedUpdateWithoutInrConvRelInput>
  }

  export type FiatPaymentsCreateNestedOneWithoutBankFeedRelInput = {
    create?: XOR<FiatPaymentsCreateWithoutBankFeedRelInput, FiatPaymentsUncheckedCreateWithoutBankFeedRelInput>
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutBankFeedRelInput
    connect?: FiatPaymentsWhereUniqueInput
  }

  export type EnumProcessStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessStatus
  }

  export type FiatPaymentsUpdateOneWithoutBankFeedRelNestedInput = {
    create?: XOR<FiatPaymentsCreateWithoutBankFeedRelInput, FiatPaymentsUncheckedCreateWithoutBankFeedRelInput>
    connectOrCreate?: FiatPaymentsCreateOrConnectWithoutBankFeedRelInput
    upsert?: FiatPaymentsUpsertWithoutBankFeedRelInput
    disconnect?: FiatPaymentsWhereInput | boolean
    delete?: FiatPaymentsWhereInput | boolean
    connect?: FiatPaymentsWhereUniqueInput
    update?: XOR<XOR<FiatPaymentsUpdateToOneWithWhereWithoutBankFeedRelInput, FiatPaymentsUpdateWithoutBankFeedRelInput>, FiatPaymentsUncheckedUpdateWithoutBankFeedRelInput>
  }

  export type UserAccountCreateNestedOneWithoutInrLedgerRelInput = {
    create?: XOR<UserAccountCreateWithoutInrLedgerRelInput, UserAccountUncheckedCreateWithoutInrLedgerRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutInrLedgerRelInput
    connect?: UserAccountWhereUniqueInput
  }

  export type EnumInrOperationFieldUpdateOperationsInput = {
    set?: $Enums.InrOperation
  }

  export type UserAccountUpdateOneWithoutInrLedgerRelNestedInput = {
    create?: XOR<UserAccountCreateWithoutInrLedgerRelInput, UserAccountUncheckedCreateWithoutInrLedgerRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutInrLedgerRelInput
    upsert?: UserAccountUpsertWithoutInrLedgerRelInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutInrLedgerRelInput, UserAccountUpdateWithoutInrLedgerRelInput>, UserAccountUncheckedUpdateWithoutInrLedgerRelInput>
  }

  export type UserAccountCreateNestedOneWithoutCryptoLedgerRelInput = {
    create?: XOR<UserAccountCreateWithoutCryptoLedgerRelInput, UserAccountUncheckedCreateWithoutCryptoLedgerRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutCryptoLedgerRelInput
    connect?: UserAccountWhereUniqueInput
  }

  export type EnumCryptoOperationFieldUpdateOperationsInput = {
    set?: $Enums.CryptoOperation
  }

  export type UserAccountUpdateOneWithoutCryptoLedgerRelNestedInput = {
    create?: XOR<UserAccountCreateWithoutCryptoLedgerRelInput, UserAccountUncheckedCreateWithoutCryptoLedgerRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutCryptoLedgerRelInput
    upsert?: UserAccountUpsertWithoutCryptoLedgerRelInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutCryptoLedgerRelInput, UserAccountUpdateWithoutCryptoLedgerRelInput>, UserAccountUncheckedUpdateWithoutCryptoLedgerRelInput>
  }

  export type UserAccountCreateNestedOneWithoutTradeLedgerRelInput = {
    create?: XOR<UserAccountCreateWithoutTradeLedgerRelInput, UserAccountUncheckedCreateWithoutTradeLedgerRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutTradeLedgerRelInput
    connect?: UserAccountWhereUniqueInput
  }

  export type EnumPositionTypeFieldUpdateOperationsInput = {
    set?: $Enums.PositionType
  }

  export type EnumTradeOperationFieldUpdateOperationsInput = {
    set?: $Enums.TradeOperation
  }

  export type UserAccountUpdateOneWithoutTradeLedgerRelNestedInput = {
    create?: XOR<UserAccountCreateWithoutTradeLedgerRelInput, UserAccountUncheckedCreateWithoutTradeLedgerRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutTradeLedgerRelInput
    upsert?: UserAccountUpsertWithoutTradeLedgerRelInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutTradeLedgerRelInput, UserAccountUpdateWithoutTradeLedgerRelInput>, UserAccountUncheckedUpdateWithoutTradeLedgerRelInput>
  }

  export type EnumParameterGroupFieldUpdateOperationsInput = {
    set?: $Enums.ParameterGroup
  }

  export type EnumParamTypeFieldUpdateOperationsInput = {
    set?: $Enums.ParamType
  }

  export type UserAccountCreateNestedOneWithoutInrWalletRelInput = {
    create?: XOR<UserAccountCreateWithoutInrWalletRelInput, UserAccountUncheckedCreateWithoutInrWalletRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutInrWalletRelInput
    connect?: UserAccountWhereUniqueInput
  }

  export type UserAccountUpdateOneWithoutInrWalletRelNestedInput = {
    create?: XOR<UserAccountCreateWithoutInrWalletRelInput, UserAccountUncheckedCreateWithoutInrWalletRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutInrWalletRelInput
    upsert?: UserAccountUpsertWithoutInrWalletRelInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutInrWalletRelInput, UserAccountUpdateWithoutInrWalletRelInput>, UserAccountUncheckedUpdateWithoutInrWalletRelInput>
  }

  export type CryptoWalletCreateNestedManyWithoutParentWalletInput = {
    create?: XOR<CryptoWalletCreateWithoutParentWalletInput, CryptoWalletUncheckedCreateWithoutParentWalletInput> | CryptoWalletCreateWithoutParentWalletInput[] | CryptoWalletUncheckedCreateWithoutParentWalletInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutParentWalletInput | CryptoWalletCreateOrConnectWithoutParentWalletInput[]
    createMany?: CryptoWalletCreateManyParentWalletInputEnvelope
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
  }

  export type StableCoinCreateNestedManyWithoutParentWalletInput = {
    create?: XOR<StableCoinCreateWithoutParentWalletInput, StableCoinUncheckedCreateWithoutParentWalletInput> | StableCoinCreateWithoutParentWalletInput[] | StableCoinUncheckedCreateWithoutParentWalletInput[]
    connectOrCreate?: StableCoinCreateOrConnectWithoutParentWalletInput | StableCoinCreateOrConnectWithoutParentWalletInput[]
    createMany?: StableCoinCreateManyParentWalletInputEnvelope
    connect?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
  }

  export type CryptoWalletUncheckedCreateNestedManyWithoutParentWalletInput = {
    create?: XOR<CryptoWalletCreateWithoutParentWalletInput, CryptoWalletUncheckedCreateWithoutParentWalletInput> | CryptoWalletCreateWithoutParentWalletInput[] | CryptoWalletUncheckedCreateWithoutParentWalletInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutParentWalletInput | CryptoWalletCreateOrConnectWithoutParentWalletInput[]
    createMany?: CryptoWalletCreateManyParentWalletInputEnvelope
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
  }

  export type StableCoinUncheckedCreateNestedManyWithoutParentWalletInput = {
    create?: XOR<StableCoinCreateWithoutParentWalletInput, StableCoinUncheckedCreateWithoutParentWalletInput> | StableCoinCreateWithoutParentWalletInput[] | StableCoinUncheckedCreateWithoutParentWalletInput[]
    connectOrCreate?: StableCoinCreateOrConnectWithoutParentWalletInput | StableCoinCreateOrConnectWithoutParentWalletInput[]
    createMany?: StableCoinCreateManyParentWalletInputEnvelope
    connect?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
  }

  export type EnumParentWalletTypeFieldUpdateOperationsInput = {
    set?: $Enums.ParentWalletType
  }

  export type CryptoWalletUpdateManyWithoutParentWalletNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutParentWalletInput, CryptoWalletUncheckedCreateWithoutParentWalletInput> | CryptoWalletCreateWithoutParentWalletInput[] | CryptoWalletUncheckedCreateWithoutParentWalletInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutParentWalletInput | CryptoWalletCreateOrConnectWithoutParentWalletInput[]
    upsert?: CryptoWalletUpsertWithWhereUniqueWithoutParentWalletInput | CryptoWalletUpsertWithWhereUniqueWithoutParentWalletInput[]
    createMany?: CryptoWalletCreateManyParentWalletInputEnvelope
    set?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    disconnect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    delete?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    update?: CryptoWalletUpdateWithWhereUniqueWithoutParentWalletInput | CryptoWalletUpdateWithWhereUniqueWithoutParentWalletInput[]
    updateMany?: CryptoWalletUpdateManyWithWhereWithoutParentWalletInput | CryptoWalletUpdateManyWithWhereWithoutParentWalletInput[]
    deleteMany?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
  }

  export type StableCoinUpdateManyWithoutParentWalletNestedInput = {
    create?: XOR<StableCoinCreateWithoutParentWalletInput, StableCoinUncheckedCreateWithoutParentWalletInput> | StableCoinCreateWithoutParentWalletInput[] | StableCoinUncheckedCreateWithoutParentWalletInput[]
    connectOrCreate?: StableCoinCreateOrConnectWithoutParentWalletInput | StableCoinCreateOrConnectWithoutParentWalletInput[]
    upsert?: StableCoinUpsertWithWhereUniqueWithoutParentWalletInput | StableCoinUpsertWithWhereUniqueWithoutParentWalletInput[]
    createMany?: StableCoinCreateManyParentWalletInputEnvelope
    set?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
    disconnect?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
    delete?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
    connect?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
    update?: StableCoinUpdateWithWhereUniqueWithoutParentWalletInput | StableCoinUpdateWithWhereUniqueWithoutParentWalletInput[]
    updateMany?: StableCoinUpdateManyWithWhereWithoutParentWalletInput | StableCoinUpdateManyWithWhereWithoutParentWalletInput[]
    deleteMany?: StableCoinScalarWhereInput | StableCoinScalarWhereInput[]
  }

  export type CryptoWalletUncheckedUpdateManyWithoutParentWalletNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutParentWalletInput, CryptoWalletUncheckedCreateWithoutParentWalletInput> | CryptoWalletCreateWithoutParentWalletInput[] | CryptoWalletUncheckedCreateWithoutParentWalletInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutParentWalletInput | CryptoWalletCreateOrConnectWithoutParentWalletInput[]
    upsert?: CryptoWalletUpsertWithWhereUniqueWithoutParentWalletInput | CryptoWalletUpsertWithWhereUniqueWithoutParentWalletInput[]
    createMany?: CryptoWalletCreateManyParentWalletInputEnvelope
    set?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    disconnect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    delete?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    update?: CryptoWalletUpdateWithWhereUniqueWithoutParentWalletInput | CryptoWalletUpdateWithWhereUniqueWithoutParentWalletInput[]
    updateMany?: CryptoWalletUpdateManyWithWhereWithoutParentWalletInput | CryptoWalletUpdateManyWithWhereWithoutParentWalletInput[]
    deleteMany?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
  }

  export type StableCoinUncheckedUpdateManyWithoutParentWalletNestedInput = {
    create?: XOR<StableCoinCreateWithoutParentWalletInput, StableCoinUncheckedCreateWithoutParentWalletInput> | StableCoinCreateWithoutParentWalletInput[] | StableCoinUncheckedCreateWithoutParentWalletInput[]
    connectOrCreate?: StableCoinCreateOrConnectWithoutParentWalletInput | StableCoinCreateOrConnectWithoutParentWalletInput[]
    upsert?: StableCoinUpsertWithWhereUniqueWithoutParentWalletInput | StableCoinUpsertWithWhereUniqueWithoutParentWalletInput[]
    createMany?: StableCoinCreateManyParentWalletInputEnvelope
    set?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
    disconnect?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
    delete?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
    connect?: StableCoinWhereUniqueInput | StableCoinWhereUniqueInput[]
    update?: StableCoinUpdateWithWhereUniqueWithoutParentWalletInput | StableCoinUpdateWithWhereUniqueWithoutParentWalletInput[]
    updateMany?: StableCoinUpdateManyWithWhereWithoutParentWalletInput | StableCoinUpdateManyWithWhereWithoutParentWalletInput[]
    deleteMany?: StableCoinScalarWhereInput | StableCoinScalarWhereInput[]
  }

  export type ParentWalletCreateNestedOneWithoutParentWalletInput = {
    create?: XOR<ParentWalletCreateWithoutParentWalletInput, ParentWalletUncheckedCreateWithoutParentWalletInput>
    connectOrCreate?: ParentWalletCreateOrConnectWithoutParentWalletInput
    connect?: ParentWalletWhereUniqueInput
  }

  export type ParentWalletUpdateOneRequiredWithoutParentWalletNestedInput = {
    create?: XOR<ParentWalletCreateWithoutParentWalletInput, ParentWalletUncheckedCreateWithoutParentWalletInput>
    connectOrCreate?: ParentWalletCreateOrConnectWithoutParentWalletInput
    upsert?: ParentWalletUpsertWithoutParentWalletInput
    connect?: ParentWalletWhereUniqueInput
    update?: XOR<XOR<ParentWalletUpdateToOneWithWhereWithoutParentWalletInput, ParentWalletUpdateWithoutParentWalletInput>, ParentWalletUncheckedUpdateWithoutParentWalletInput>
  }

  export type UserAccountCreateNestedOneWithoutCryptoWalletRelInput = {
    create?: XOR<UserAccountCreateWithoutCryptoWalletRelInput, UserAccountUncheckedCreateWithoutCryptoWalletRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutCryptoWalletRelInput
    connect?: UserAccountWhereUniqueInput
  }

  export type ParentWalletCreateNestedOneWithoutChildCryptoWalletInput = {
    create?: XOR<ParentWalletCreateWithoutChildCryptoWalletInput, ParentWalletUncheckedCreateWithoutChildCryptoWalletInput>
    connectOrCreate?: ParentWalletCreateOrConnectWithoutChildCryptoWalletInput
    connect?: ParentWalletWhereUniqueInput
  }

  export type CryptoDepositCreateNestedManyWithoutCryptoWalletInput = {
    create?: XOR<CryptoDepositCreateWithoutCryptoWalletInput, CryptoDepositUncheckedCreateWithoutCryptoWalletInput> | CryptoDepositCreateWithoutCryptoWalletInput[] | CryptoDepositUncheckedCreateWithoutCryptoWalletInput[]
    connectOrCreate?: CryptoDepositCreateOrConnectWithoutCryptoWalletInput | CryptoDepositCreateOrConnectWithoutCryptoWalletInput[]
    createMany?: CryptoDepositCreateManyCryptoWalletInputEnvelope
    connect?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
  }

  export type CryptoDepositUncheckedCreateNestedManyWithoutCryptoWalletInput = {
    create?: XOR<CryptoDepositCreateWithoutCryptoWalletInput, CryptoDepositUncheckedCreateWithoutCryptoWalletInput> | CryptoDepositCreateWithoutCryptoWalletInput[] | CryptoDepositUncheckedCreateWithoutCryptoWalletInput[]
    connectOrCreate?: CryptoDepositCreateOrConnectWithoutCryptoWalletInput | CryptoDepositCreateOrConnectWithoutCryptoWalletInput[]
    createMany?: CryptoDepositCreateManyCryptoWalletInputEnvelope
    connect?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
  }

  export type UserAccountUpdateOneWithoutCryptoWalletRelNestedInput = {
    create?: XOR<UserAccountCreateWithoutCryptoWalletRelInput, UserAccountUncheckedCreateWithoutCryptoWalletRelInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutCryptoWalletRelInput
    upsert?: UserAccountUpsertWithoutCryptoWalletRelInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutCryptoWalletRelInput, UserAccountUpdateWithoutCryptoWalletRelInput>, UserAccountUncheckedUpdateWithoutCryptoWalletRelInput>
  }

  export type ParentWalletUpdateOneRequiredWithoutChildCryptoWalletNestedInput = {
    create?: XOR<ParentWalletCreateWithoutChildCryptoWalletInput, ParentWalletUncheckedCreateWithoutChildCryptoWalletInput>
    connectOrCreate?: ParentWalletCreateOrConnectWithoutChildCryptoWalletInput
    upsert?: ParentWalletUpsertWithoutChildCryptoWalletInput
    connect?: ParentWalletWhereUniqueInput
    update?: XOR<XOR<ParentWalletUpdateToOneWithWhereWithoutChildCryptoWalletInput, ParentWalletUpdateWithoutChildCryptoWalletInput>, ParentWalletUncheckedUpdateWithoutChildCryptoWalletInput>
  }

  export type CryptoDepositUpdateManyWithoutCryptoWalletNestedInput = {
    create?: XOR<CryptoDepositCreateWithoutCryptoWalletInput, CryptoDepositUncheckedCreateWithoutCryptoWalletInput> | CryptoDepositCreateWithoutCryptoWalletInput[] | CryptoDepositUncheckedCreateWithoutCryptoWalletInput[]
    connectOrCreate?: CryptoDepositCreateOrConnectWithoutCryptoWalletInput | CryptoDepositCreateOrConnectWithoutCryptoWalletInput[]
    upsert?: CryptoDepositUpsertWithWhereUniqueWithoutCryptoWalletInput | CryptoDepositUpsertWithWhereUniqueWithoutCryptoWalletInput[]
    createMany?: CryptoDepositCreateManyCryptoWalletInputEnvelope
    set?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
    disconnect?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
    delete?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
    connect?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
    update?: CryptoDepositUpdateWithWhereUniqueWithoutCryptoWalletInput | CryptoDepositUpdateWithWhereUniqueWithoutCryptoWalletInput[]
    updateMany?: CryptoDepositUpdateManyWithWhereWithoutCryptoWalletInput | CryptoDepositUpdateManyWithWhereWithoutCryptoWalletInput[]
    deleteMany?: CryptoDepositScalarWhereInput | CryptoDepositScalarWhereInput[]
  }

  export type CryptoDepositUncheckedUpdateManyWithoutCryptoWalletNestedInput = {
    create?: XOR<CryptoDepositCreateWithoutCryptoWalletInput, CryptoDepositUncheckedCreateWithoutCryptoWalletInput> | CryptoDepositCreateWithoutCryptoWalletInput[] | CryptoDepositUncheckedCreateWithoutCryptoWalletInput[]
    connectOrCreate?: CryptoDepositCreateOrConnectWithoutCryptoWalletInput | CryptoDepositCreateOrConnectWithoutCryptoWalletInput[]
    upsert?: CryptoDepositUpsertWithWhereUniqueWithoutCryptoWalletInput | CryptoDepositUpsertWithWhereUniqueWithoutCryptoWalletInput[]
    createMany?: CryptoDepositCreateManyCryptoWalletInputEnvelope
    set?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
    disconnect?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
    delete?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
    connect?: CryptoDepositWhereUniqueInput | CryptoDepositWhereUniqueInput[]
    update?: CryptoDepositUpdateWithWhereUniqueWithoutCryptoWalletInput | CryptoDepositUpdateWithWhereUniqueWithoutCryptoWalletInput[]
    updateMany?: CryptoDepositUpdateManyWithWhereWithoutCryptoWalletInput | CryptoDepositUpdateManyWithWhereWithoutCryptoWalletInput[]
    deleteMany?: CryptoDepositScalarWhereInput | CryptoDepositScalarWhereInput[]
  }

  export type EnumIntervalFieldUpdateOperationsInput = {
    set?: $Enums.Interval
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAccountType | EnumUserAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserAccountType[] | ListEnumUserAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserAccountType[] | ListEnumUserAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserAccountTypeFilter<$PrismaModel> | $Enums.UserAccountType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAccountType | EnumUserAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserAccountType[] | ListEnumUserAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserAccountType[] | ListEnumUserAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserAccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumUserAccountTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedEnumSignUpTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SignUpType | EnumSignUpTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SignUpType[] | ListEnumSignUpTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SignUpType[] | ListEnumSignUpTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSignUpTypeNullableFilter<$PrismaModel> | $Enums.SignUpType | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserKycStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserKycStatus | EnumUserKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserKycStatus[] | ListEnumUserKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserKycStatus[] | ListEnumUserKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserKycStatusFilter<$PrismaModel> | $Enums.UserKycStatus
  }

  export type NestedEnumBankVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BankVerificationStatus | EnumBankVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BankVerificationStatus[] | ListEnumBankVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankVerificationStatus[] | ListEnumBankVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBankVerificationStatusFilter<$PrismaModel> | $Enums.BankVerificationStatus
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedEnumSignUpTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignUpType | EnumSignUpTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SignUpType[] | ListEnumSignUpTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SignUpType[] | ListEnumSignUpTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSignUpTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SignUpType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSignUpTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSignUpTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserKycStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserKycStatus | EnumUserKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserKycStatus[] | ListEnumUserKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserKycStatus[] | ListEnumUserKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserKycStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserKycStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserKycStatusFilter<$PrismaModel>
    _max?: NestedEnumUserKycStatusFilter<$PrismaModel>
  }

  export type NestedEnumBankVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BankVerificationStatus | EnumBankVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BankVerificationStatus[] | ListEnumBankVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankVerificationStatus[] | ListEnumBankVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBankVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.BankVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBankVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumBankVerificationStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTwoFAStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TwoFAStatus | EnumTwoFAStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TwoFAStatus[] | ListEnumTwoFAStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TwoFAStatus[] | ListEnumTwoFAStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTwoFAStatusFilter<$PrismaModel> | $Enums.TwoFAStatus
  }

  export type NestedEnumReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.Reason | EnumReasonFieldRefInput<$PrismaModel>
    in?: $Enums.Reason[] | ListEnumReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.Reason[] | ListEnumReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReasonFilter<$PrismaModel> | $Enums.Reason
  }

  export type NestedEnumTwoFAStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TwoFAStatus | EnumTwoFAStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TwoFAStatus[] | ListEnumTwoFAStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TwoFAStatus[] | ListEnumTwoFAStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTwoFAStatusWithAggregatesFilter<$PrismaModel> | $Enums.TwoFAStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTwoFAStatusFilter<$PrismaModel>
    _max?: NestedEnumTwoFAStatusFilter<$PrismaModel>
  }

  export type NestedEnumReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Reason | EnumReasonFieldRefInput<$PrismaModel>
    in?: $Enums.Reason[] | ListEnumReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.Reason[] | ListEnumReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReasonWithAggregatesFilter<$PrismaModel> | $Enums.Reason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReasonFilter<$PrismaModel>
    _max?: NestedEnumReasonFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumKycTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KycType | EnumKycTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KycType[] | ListEnumKycTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycType[] | ListEnumKycTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKycTypeFilter<$PrismaModel> | $Enums.KycType
  }

  export type NestedEnumHypervergeStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HypervergeStatus | EnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.HypervergeStatus[] | ListEnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HypervergeStatus[] | ListEnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHypervergeStatusNullableFilter<$PrismaModel> | $Enums.HypervergeStatus | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumKycTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KycType | EnumKycTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KycType[] | ListEnumKycTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycType[] | ListEnumKycTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKycTypeWithAggregatesFilter<$PrismaModel> | $Enums.KycType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKycTypeFilter<$PrismaModel>
    _max?: NestedEnumKycTypeFilter<$PrismaModel>
  }

  export type NestedEnumHypervergeStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HypervergeStatus | EnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.HypervergeStatus[] | ListEnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HypervergeStatus[] | ListEnumHypervergeStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHypervergeStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.HypervergeStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHypervergeStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumHypervergeStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumBankDetailsTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BankDetailsType | EnumBankDetailsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BankDetailsType[] | ListEnumBankDetailsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankDetailsType[] | ListEnumBankDetailsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBankDetailsTypeFilter<$PrismaModel> | $Enums.BankDetailsType
  }

  export type NestedEnumBankDetailsTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BankDetailsType | EnumBankDetailsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BankDetailsType[] | ListEnumBankDetailsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankDetailsType[] | ListEnumBankDetailsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBankDetailsTypeWithAggregatesFilter<$PrismaModel> | $Enums.BankDetailsType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBankDetailsTypeFilter<$PrismaModel>
    _max?: NestedEnumBankDetailsTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumInrCreditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InrCreditStatus | EnumInrCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InrCreditStatus[] | ListEnumInrCreditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InrCreditStatus[] | ListEnumInrCreditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInrCreditStatusFilter<$PrismaModel> | $Enums.InrCreditStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumInrCreditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InrCreditStatus | EnumInrCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InrCreditStatus[] | ListEnumInrCreditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InrCreditStatus[] | ListEnumInrCreditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInrCreditStatusWithAggregatesFilter<$PrismaModel> | $Enums.InrCreditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInrCreditStatusFilter<$PrismaModel>
    _max?: NestedEnumInrCreditStatusFilter<$PrismaModel>
  }

  export type NestedEnumProcessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusFilter<$PrismaModel> | $Enums.ProcessStatus
  }

  export type NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessStatusFilter<$PrismaModel>
  }

  export type NestedEnumInrOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.InrOperation | EnumInrOperationFieldRefInput<$PrismaModel>
    in?: $Enums.InrOperation[] | ListEnumInrOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.InrOperation[] | ListEnumInrOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumInrOperationFilter<$PrismaModel> | $Enums.InrOperation
  }

  export type NestedEnumInrOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InrOperation | EnumInrOperationFieldRefInput<$PrismaModel>
    in?: $Enums.InrOperation[] | ListEnumInrOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.InrOperation[] | ListEnumInrOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumInrOperationWithAggregatesFilter<$PrismaModel> | $Enums.InrOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInrOperationFilter<$PrismaModel>
    _max?: NestedEnumInrOperationFilter<$PrismaModel>
  }

  export type NestedEnumCryptoOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoOperation | EnumCryptoOperationFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoOperation[] | ListEnumCryptoOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoOperation[] | ListEnumCryptoOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoOperationFilter<$PrismaModel> | $Enums.CryptoOperation
  }

  export type NestedEnumCryptoOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoOperation | EnumCryptoOperationFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoOperation[] | ListEnumCryptoOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoOperation[] | ListEnumCryptoOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoOperationWithAggregatesFilter<$PrismaModel> | $Enums.CryptoOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCryptoOperationFilter<$PrismaModel>
    _max?: NestedEnumCryptoOperationFilter<$PrismaModel>
  }

  export type NestedEnumPositionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PositionType | EnumPositionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PositionType[] | ListEnumPositionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PositionType[] | ListEnumPositionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionTypeFilter<$PrismaModel> | $Enums.PositionType
  }

  export type NestedEnumTradeOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeOperation | EnumTradeOperationFieldRefInput<$PrismaModel>
    in?: $Enums.TradeOperation[] | ListEnumTradeOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeOperation[] | ListEnumTradeOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeOperationFilter<$PrismaModel> | $Enums.TradeOperation
  }

  export type NestedEnumPositionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PositionType | EnumPositionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PositionType[] | ListEnumPositionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PositionType[] | ListEnumPositionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PositionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionTypeFilter<$PrismaModel>
    _max?: NestedEnumPositionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTradeOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeOperation | EnumTradeOperationFieldRefInput<$PrismaModel>
    in?: $Enums.TradeOperation[] | ListEnumTradeOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeOperation[] | ListEnumTradeOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeOperationWithAggregatesFilter<$PrismaModel> | $Enums.TradeOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeOperationFilter<$PrismaModel>
    _max?: NestedEnumTradeOperationFilter<$PrismaModel>
  }

  export type NestedEnumParameterGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterGroup | EnumParameterGroupFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterGroup[] | ListEnumParameterGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterGroup[] | ListEnumParameterGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterGroupFilter<$PrismaModel> | $Enums.ParameterGroup
  }

  export type NestedEnumParamTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParamType | EnumParamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParamType[] | ListEnumParamTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParamType[] | ListEnumParamTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParamTypeFilter<$PrismaModel> | $Enums.ParamType
  }

  export type NestedEnumParameterGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterGroup | EnumParameterGroupFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterGroup[] | ListEnumParameterGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterGroup[] | ListEnumParameterGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterGroupWithAggregatesFilter<$PrismaModel> | $Enums.ParameterGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParameterGroupFilter<$PrismaModel>
    _max?: NestedEnumParameterGroupFilter<$PrismaModel>
  }

  export type NestedEnumParamTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParamType | EnumParamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParamType[] | ListEnumParamTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParamType[] | ListEnumParamTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParamTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParamType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParamTypeFilter<$PrismaModel>
    _max?: NestedEnumParamTypeFilter<$PrismaModel>
  }

  export type NestedEnumParentWalletTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParentWalletType | EnumParentWalletTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParentWalletType[] | ListEnumParentWalletTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParentWalletType[] | ListEnumParentWalletTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParentWalletTypeFilter<$PrismaModel> | $Enums.ParentWalletType
  }

  export type NestedEnumParentWalletTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParentWalletType | EnumParentWalletTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParentWalletType[] | ListEnumParentWalletTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParentWalletType[] | ListEnumParentWalletTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParentWalletTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParentWalletType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParentWalletTypeFilter<$PrismaModel>
    _max?: NestedEnumParentWalletTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumIntervalFilter<$PrismaModel = never> = {
    equals?: $Enums.Interval | EnumIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.Interval[] | ListEnumIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.Interval[] | ListEnumIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumIntervalFilter<$PrismaModel> | $Enums.Interval
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Interval | EnumIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.Interval[] | ListEnumIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.Interval[] | ListEnumIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumIntervalWithAggregatesFilter<$PrismaModel> | $Enums.Interval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntervalFilter<$PrismaModel>
    _max?: NestedEnumIntervalFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UserCreateWithoutUserAccountRelInput = {
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserKycRel?: UserKycCreateNestedOneWithoutUserRelInput
    BankDetailRel?: UserBankDetailsCreateNestedOneWithoutUserRelInput
    UserBankDetailsRel?: UserBankDetailsCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutUserInput
    TwoFARel?: TwoFACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAccountRelInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    kycId?: number | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    bankDetailsId?: number | null
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserInput
    TwoFARel?: TwoFAUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAccountRelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAccountRelInput, UserUncheckedCreateWithoutUserAccountRelInput>
  }

  export type InrLedgerCreateWithoutAccountInput = {
    change: number
    operation: $Enums.InrOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrLedgerUncheckedCreateWithoutAccountInput = {
    id?: number
    change: number
    operation: $Enums.InrOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrLedgerCreateOrConnectWithoutAccountInput = {
    where: InrLedgerWhereUniqueInput
    create: XOR<InrLedgerCreateWithoutAccountInput, InrLedgerUncheckedCreateWithoutAccountInput>
  }

  export type InrLedgerCreateManyAccountInputEnvelope = {
    data: InrLedgerCreateManyAccountInput | InrLedgerCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CryptoLedgerCreateWithoutAccountInput = {
    coin: string
    change: number
    operation: $Enums.CryptoOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoLedgerUncheckedCreateWithoutAccountInput = {
    id?: number
    coin: string
    change: number
    operation: $Enums.CryptoOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoLedgerCreateOrConnectWithoutAccountInput = {
    where: CryptoLedgerWhereUniqueInput
    create: XOR<CryptoLedgerCreateWithoutAccountInput, CryptoLedgerUncheckedCreateWithoutAccountInput>
  }

  export type CryptoLedgerCreateManyAccountInputEnvelope = {
    data: CryptoLedgerCreateManyAccountInput | CryptoLedgerCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type TradeLedgerCreateWithoutAccountInput = {
    change: string
    tradeId: string
    positionType: $Enums.PositionType
    operation: $Enums.TradeOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type TradeLedgerUncheckedCreateWithoutAccountInput = {
    id?: number
    change: string
    tradeId: string
    positionType: $Enums.PositionType
    operation: $Enums.TradeOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type TradeLedgerCreateOrConnectWithoutAccountInput = {
    where: TradeLedgerWhereUniqueInput
    create: XOR<TradeLedgerCreateWithoutAccountInput, TradeLedgerUncheckedCreateWithoutAccountInput>
  }

  export type TradeLedgerCreateManyAccountInputEnvelope = {
    data: TradeLedgerCreateManyAccountInput | TradeLedgerCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type InrWalletCreateWithoutAccountInput = {
    walletBalance?: number
    amountAvailable?: number
    amountLocked?: number
    unrealizedPnl?: number
    last24hourChange?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrWalletUncheckedCreateWithoutAccountInput = {
    id?: number
    walletBalance?: number
    amountAvailable?: number
    amountLocked?: number
    unrealizedPnl?: number
    last24hourChange?: number
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrWalletCreateOrConnectWithoutAccountInput = {
    where: InrWalletWhereUniqueInput
    create: XOR<InrWalletCreateWithoutAccountInput, InrWalletUncheckedCreateWithoutAccountInput>
  }

  export type CryptoWalletCreateWithoutAccountInput = {
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    parentWallet: ParentWalletCreateNestedOneWithoutChildCryptoWalletInput
    cryptoDeposit?: CryptoDepositCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletUncheckedCreateWithoutAccountInput = {
    id?: number
    parentWalletId: number
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    cryptoDeposit?: CryptoDepositUncheckedCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletCreateOrConnectWithoutAccountInput = {
    where: CryptoWalletWhereUniqueInput
    create: XOR<CryptoWalletCreateWithoutAccountInput, CryptoWalletUncheckedCreateWithoutAccountInput>
  }

  export type CryptoWalletCreateManyAccountInputEnvelope = {
    data: CryptoWalletCreateManyAccountInput | CryptoWalletCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type InrConversionHistoryCreateWithoutAccountInput = {
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    cryptoDeposit?: CryptoDepositCreateNestedOneWithoutInrConvHistRelInput
  }

  export type InrConversionHistoryUncheckedCreateWithoutAccountInput = {
    id?: number
    cryptoDepositId?: number | null
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrConversionHistoryCreateOrConnectWithoutAccountInput = {
    where: InrConversionHistoryWhereUniqueInput
    create: XOR<InrConversionHistoryCreateWithoutAccountInput, InrConversionHistoryUncheckedCreateWithoutAccountInput>
  }

  export type InrConversionHistoryCreateManyAccountInputEnvelope = {
    data: InrConversionHistoryCreateManyAccountInput | InrConversionHistoryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserAccountRelInput = {
    update: XOR<UserUpdateWithoutUserAccountRelInput, UserUncheckedUpdateWithoutUserAccountRelInput>
    create: XOR<UserCreateWithoutUserAccountRelInput, UserUncheckedCreateWithoutUserAccountRelInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAccountRelInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAccountRelInput, UserUncheckedUpdateWithoutUserAccountRelInput>
  }

  export type UserUpdateWithoutUserAccountRelInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserKycRel?: UserKycUpdateOneWithoutUserRelNestedInput
    BankDetailRel?: UserBankDetailsUpdateOneWithoutUserRelNestedInput
    UserBankDetailsRel?: UserBankDetailsUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutUserNestedInput
    TwoFARel?: TwoFAUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAccountRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    kycId?: NullableIntFieldUpdateOperationsInput | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    bankDetailsId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutUserNestedInput
    TwoFARel?: TwoFAUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InrLedgerUpsertWithWhereUniqueWithoutAccountInput = {
    where: InrLedgerWhereUniqueInput
    update: XOR<InrLedgerUpdateWithoutAccountInput, InrLedgerUncheckedUpdateWithoutAccountInput>
    create: XOR<InrLedgerCreateWithoutAccountInput, InrLedgerUncheckedCreateWithoutAccountInput>
  }

  export type InrLedgerUpdateWithWhereUniqueWithoutAccountInput = {
    where: InrLedgerWhereUniqueInput
    data: XOR<InrLedgerUpdateWithoutAccountInput, InrLedgerUncheckedUpdateWithoutAccountInput>
  }

  export type InrLedgerUpdateManyWithWhereWithoutAccountInput = {
    where: InrLedgerScalarWhereInput
    data: XOR<InrLedgerUpdateManyMutationInput, InrLedgerUncheckedUpdateManyWithoutAccountInput>
  }

  export type InrLedgerScalarWhereInput = {
    AND?: InrLedgerScalarWhereInput | InrLedgerScalarWhereInput[]
    OR?: InrLedgerScalarWhereInput[]
    NOT?: InrLedgerScalarWhereInput | InrLedgerScalarWhereInput[]
    id?: IntFilter<"InrLedger"> | number
    accountId?: IntFilter<"InrLedger"> | number
    change?: FloatFilter<"InrLedger"> | number
    operation?: EnumInrOperationFilter<"InrLedger"> | $Enums.InrOperation
    timestamp?: DateTimeFilter<"InrLedger"> | Date | string
    createdAt?: DateTimeFilter<"InrLedger"> | Date | string
    createdBy?: IntFilter<"InrLedger"> | number
    updatedAt?: DateTimeFilter<"InrLedger"> | Date | string
    updatedBy?: IntFilter<"InrLedger"> | number
  }

  export type CryptoLedgerUpsertWithWhereUniqueWithoutAccountInput = {
    where: CryptoLedgerWhereUniqueInput
    update: XOR<CryptoLedgerUpdateWithoutAccountInput, CryptoLedgerUncheckedUpdateWithoutAccountInput>
    create: XOR<CryptoLedgerCreateWithoutAccountInput, CryptoLedgerUncheckedCreateWithoutAccountInput>
  }

  export type CryptoLedgerUpdateWithWhereUniqueWithoutAccountInput = {
    where: CryptoLedgerWhereUniqueInput
    data: XOR<CryptoLedgerUpdateWithoutAccountInput, CryptoLedgerUncheckedUpdateWithoutAccountInput>
  }

  export type CryptoLedgerUpdateManyWithWhereWithoutAccountInput = {
    where: CryptoLedgerScalarWhereInput
    data: XOR<CryptoLedgerUpdateManyMutationInput, CryptoLedgerUncheckedUpdateManyWithoutAccountInput>
  }

  export type CryptoLedgerScalarWhereInput = {
    AND?: CryptoLedgerScalarWhereInput | CryptoLedgerScalarWhereInput[]
    OR?: CryptoLedgerScalarWhereInput[]
    NOT?: CryptoLedgerScalarWhereInput | CryptoLedgerScalarWhereInput[]
    id?: IntFilter<"CryptoLedger"> | number
    accountId?: IntFilter<"CryptoLedger"> | number
    coin?: StringFilter<"CryptoLedger"> | string
    change?: FloatFilter<"CryptoLedger"> | number
    operation?: EnumCryptoOperationFilter<"CryptoLedger"> | $Enums.CryptoOperation
    timestamp?: DateTimeFilter<"CryptoLedger"> | Date | string
    createdAt?: DateTimeFilter<"CryptoLedger"> | Date | string
    createdBy?: IntFilter<"CryptoLedger"> | number
    updatedAt?: DateTimeFilter<"CryptoLedger"> | Date | string
    updatedBy?: IntFilter<"CryptoLedger"> | number
  }

  export type TradeLedgerUpsertWithWhereUniqueWithoutAccountInput = {
    where: TradeLedgerWhereUniqueInput
    update: XOR<TradeLedgerUpdateWithoutAccountInput, TradeLedgerUncheckedUpdateWithoutAccountInput>
    create: XOR<TradeLedgerCreateWithoutAccountInput, TradeLedgerUncheckedCreateWithoutAccountInput>
  }

  export type TradeLedgerUpdateWithWhereUniqueWithoutAccountInput = {
    where: TradeLedgerWhereUniqueInput
    data: XOR<TradeLedgerUpdateWithoutAccountInput, TradeLedgerUncheckedUpdateWithoutAccountInput>
  }

  export type TradeLedgerUpdateManyWithWhereWithoutAccountInput = {
    where: TradeLedgerScalarWhereInput
    data: XOR<TradeLedgerUpdateManyMutationInput, TradeLedgerUncheckedUpdateManyWithoutAccountInput>
  }

  export type TradeLedgerScalarWhereInput = {
    AND?: TradeLedgerScalarWhereInput | TradeLedgerScalarWhereInput[]
    OR?: TradeLedgerScalarWhereInput[]
    NOT?: TradeLedgerScalarWhereInput | TradeLedgerScalarWhereInput[]
    id?: IntFilter<"TradeLedger"> | number
    accountId?: IntFilter<"TradeLedger"> | number
    change?: StringFilter<"TradeLedger"> | string
    tradeId?: StringFilter<"TradeLedger"> | string
    positionType?: EnumPositionTypeFilter<"TradeLedger"> | $Enums.PositionType
    operation?: EnumTradeOperationFilter<"TradeLedger"> | $Enums.TradeOperation
    timestamp?: DateTimeFilter<"TradeLedger"> | Date | string
    createdAt?: DateTimeFilter<"TradeLedger"> | Date | string
    createdBy?: IntFilter<"TradeLedger"> | number
    updatedAt?: DateTimeFilter<"TradeLedger"> | Date | string
    updatedBy?: IntFilter<"TradeLedger"> | number
  }

  export type InrWalletUpsertWithoutAccountInput = {
    update: XOR<InrWalletUpdateWithoutAccountInput, InrWalletUncheckedUpdateWithoutAccountInput>
    create: XOR<InrWalletCreateWithoutAccountInput, InrWalletUncheckedCreateWithoutAccountInput>
    where?: InrWalletWhereInput
  }

  export type InrWalletUpdateToOneWithWhereWithoutAccountInput = {
    where?: InrWalletWhereInput
    data: XOR<InrWalletUpdateWithoutAccountInput, InrWalletUncheckedUpdateWithoutAccountInput>
  }

  export type InrWalletUpdateWithoutAccountInput = {
    walletBalance?: FloatFieldUpdateOperationsInput | number
    amountAvailable?: FloatFieldUpdateOperationsInput | number
    amountLocked?: FloatFieldUpdateOperationsInput | number
    unrealizedPnl?: FloatFieldUpdateOperationsInput | number
    last24hourChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrWalletUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletBalance?: FloatFieldUpdateOperationsInput | number
    amountAvailable?: FloatFieldUpdateOperationsInput | number
    amountLocked?: FloatFieldUpdateOperationsInput | number
    unrealizedPnl?: FloatFieldUpdateOperationsInput | number
    last24hourChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoWalletUpsertWithWhereUniqueWithoutAccountInput = {
    where: CryptoWalletWhereUniqueInput
    update: XOR<CryptoWalletUpdateWithoutAccountInput, CryptoWalletUncheckedUpdateWithoutAccountInput>
    create: XOR<CryptoWalletCreateWithoutAccountInput, CryptoWalletUncheckedCreateWithoutAccountInput>
  }

  export type CryptoWalletUpdateWithWhereUniqueWithoutAccountInput = {
    where: CryptoWalletWhereUniqueInput
    data: XOR<CryptoWalletUpdateWithoutAccountInput, CryptoWalletUncheckedUpdateWithoutAccountInput>
  }

  export type CryptoWalletUpdateManyWithWhereWithoutAccountInput = {
    where: CryptoWalletScalarWhereInput
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyWithoutAccountInput>
  }

  export type CryptoWalletScalarWhereInput = {
    AND?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
    OR?: CryptoWalletScalarWhereInput[]
    NOT?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
    id?: IntFilter<"CryptoWallet"> | number
    accountId?: IntNullableFilter<"CryptoWallet"> | number | null
    parentWalletId?: IntFilter<"CryptoWallet"> | number
    liminalRefId?: StringFilter<"CryptoWallet"> | string
    liminalParentId?: IntFilter<"CryptoWallet"> | number
    liminalCoin?: StringFilter<"CryptoWallet"> | string
    liminalChain?: StringFilter<"CryptoWallet"> | string
    publicAddress?: StringFilter<"CryptoWallet"> | string
    balance?: FloatFilter<"CryptoWallet"> | number
    lastConversion?: DateTimeNullableFilter<"CryptoWallet"> | Date | string | null
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    createdBy?: IntFilter<"CryptoWallet"> | number
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedBy?: IntFilter<"CryptoWallet"> | number
  }

  export type InrConversionHistoryUpsertWithWhereUniqueWithoutAccountInput = {
    where: InrConversionHistoryWhereUniqueInput
    update: XOR<InrConversionHistoryUpdateWithoutAccountInput, InrConversionHistoryUncheckedUpdateWithoutAccountInput>
    create: XOR<InrConversionHistoryCreateWithoutAccountInput, InrConversionHistoryUncheckedCreateWithoutAccountInput>
  }

  export type InrConversionHistoryUpdateWithWhereUniqueWithoutAccountInput = {
    where: InrConversionHistoryWhereUniqueInput
    data: XOR<InrConversionHistoryUpdateWithoutAccountInput, InrConversionHistoryUncheckedUpdateWithoutAccountInput>
  }

  export type InrConversionHistoryUpdateManyWithWhereWithoutAccountInput = {
    where: InrConversionHistoryScalarWhereInput
    data: XOR<InrConversionHistoryUpdateManyMutationInput, InrConversionHistoryUncheckedUpdateManyWithoutAccountInput>
  }

  export type InrConversionHistoryScalarWhereInput = {
    AND?: InrConversionHistoryScalarWhereInput | InrConversionHistoryScalarWhereInput[]
    OR?: InrConversionHistoryScalarWhereInput[]
    NOT?: InrConversionHistoryScalarWhereInput | InrConversionHistoryScalarWhereInput[]
    id?: IntFilter<"InrConversionHistory"> | number
    cryptoDepositId?: IntNullableFilter<"InrConversionHistory"> | number | null
    accountId?: IntFilter<"InrConversionHistory"> | number
    baseToken?: StringFilter<"InrConversionHistory"> | string
    baseTokenQuantity?: FloatFilter<"InrConversionHistory"> | number
    inrValue?: FloatFilter<"InrConversionHistory"> | number
    inrValAfterDeduction?: FloatFilter<"InrConversionHistory"> | number
    gst?: FloatNullableFilter<"InrConversionHistory"> | number | null
    txnFee?: FloatNullableFilter<"InrConversionHistory"> | number | null
    tds?: FloatNullableFilter<"InrConversionHistory"> | number | null
    coinConversionRate?: FloatNullableFilter<"InrConversionHistory"> | number | null
    receivingAddress?: StringNullableFilter<"InrConversionHistory"> | string | null
    createdAt?: DateTimeFilter<"InrConversionHistory"> | Date | string
    createdBy?: IntFilter<"InrConversionHistory"> | number
    updatedAt?: DateTimeFilter<"InrConversionHistory"> | Date | string
    updatedBy?: IntFilter<"InrConversionHistory"> | number
  }

  export type UserKycCreateWithoutUserRelInput = {
    fullName?: string | null
    gender?: $Enums.Gender | null
    dob?: string | null
    address?: string | null
    fatherName?: string | null
    kycType: $Enums.KycType
    kycStatus?: $Enums.UserKycStatus
    hyperVergeStatus?: $Enums.HypervergeStatus | null
    panStatus?: $Enums.UserKycStatus
    aadharFrontStatus?: $Enums.UserKycStatus
    aadharBackStatus?: $Enums.UserKycStatus
    selfieStatus?: $Enums.UserKycStatus
    aadharPanNameMatchStatus?: $Enums.UserKycStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    EncryptedUserDataRel?: EncryptedUserDataCreateNestedOneWithoutUserKycInput
  }

  export type UserKycUncheckedCreateWithoutUserRelInput = {
    id?: number
    encryptedUserDataId?: number | null
    fullName?: string | null
    gender?: $Enums.Gender | null
    dob?: string | null
    address?: string | null
    fatherName?: string | null
    kycType: $Enums.KycType
    kycStatus?: $Enums.UserKycStatus
    hyperVergeStatus?: $Enums.HypervergeStatus | null
    panStatus?: $Enums.UserKycStatus
    aadharFrontStatus?: $Enums.UserKycStatus
    aadharBackStatus?: $Enums.UserKycStatus
    selfieStatus?: $Enums.UserKycStatus
    aadharPanNameMatchStatus?: $Enums.UserKycStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type UserKycCreateOrConnectWithoutUserRelInput = {
    where: UserKycWhereUniqueInput
    create: XOR<UserKycCreateWithoutUserRelInput, UserKycUncheckedCreateWithoutUserRelInput>
  }

  export type UserBankDetailsCreateWithoutUserRelInput = {
    bankDetailsType?: $Enums.BankDetailsType
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    userRel?: UserCreateNestedOneWithoutUserBankDetailsRelInput
    UserBankRel?: FiatPaymentsCreateNestedManyWithoutUserBankRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutSystemBankRelInput
  }

  export type UserBankDetailsUncheckedCreateWithoutUserRelInput = {
    id?: number
    bankDetailsType?: $Enums.BankDetailsType
    userId?: number | null
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserBankRelInput
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutSystemBankRelInput
  }

  export type UserBankDetailsCreateOrConnectWithoutUserRelInput = {
    where: UserBankDetailsWhereUniqueInput
    create: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput>
  }

  export type UserBankDetailsCreateWithoutUserRelInput = {
    bankDetailsType?: $Enums.BankDetailsType
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankRel?: FiatPaymentsCreateNestedManyWithoutUserBankRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutSystemBankRelInput
    UserRel?: UserCreateNestedManyWithoutBankDetailRelInput
  }

  export type UserBankDetailsUncheckedCreateWithoutUserRelInput = {
    id?: number
    bankDetailsType?: $Enums.BankDetailsType
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserBankRelInput
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutSystemBankRelInput
    UserRel?: UserUncheckedCreateNestedManyWithoutBankDetailRelInput
  }

  export type UserBankDetailsCreateManyUserRelInputEnvelope = {
    data: UserBankDetailsCreateManyUserRelInput | UserBankDetailsCreateManyUserRelInput[]
    skipDuplicates?: boolean
  }

  export type FiatPaymentsCreateWithoutUserInput = {
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    systemBankRel?: UserBankDetailsCreateNestedOneWithoutFiatPaymentsRelInput
    userBankRel?: UserBankDetailsCreateNestedOneWithoutUserBankRelInput
    BankFeedRel?: BankFeedCreateNestedOneWithoutFiatPaymentInput
  }

  export type FiatPaymentsUncheckedCreateWithoutUserInput = {
    id?: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemBankId: number
    userBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    BankFeedRel?: BankFeedUncheckedCreateNestedOneWithoutFiatPaymentInput
  }

  export type FiatPaymentsCreateOrConnectWithoutUserInput = {
    where: FiatPaymentsWhereUniqueInput
    create: XOR<FiatPaymentsCreateWithoutUserInput, FiatPaymentsUncheckedCreateWithoutUserInput>
  }

  export type FiatPaymentsCreateManyUserInputEnvelope = {
    data: FiatPaymentsCreateManyUserInput | FiatPaymentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAccountCreateWithoutUserRelInput = {
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    InrLedgerRel?: InrLedgerCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUncheckedCreateWithoutUserRelInput = {
    id?: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    InrLedgerRel?: InrLedgerUncheckedCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerUncheckedCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerUncheckedCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletUncheckedCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletUncheckedCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type UserAccountCreateOrConnectWithoutUserRelInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutUserRelInput, UserAccountUncheckedCreateWithoutUserRelInput>
  }

  export type TwoFACreateWithoutUserInput = {
    email: string
    phone?: string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    status?: $Enums.TwoFAStatus
    reason: $Enums.Reason
    expiryTime: number
    mobileVerifiedAtleastOnce: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type TwoFAUncheckedCreateWithoutUserInput = {
    id?: number
    email: string
    phone?: string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    status?: $Enums.TwoFAStatus
    reason: $Enums.Reason
    expiryTime: number
    mobileVerifiedAtleastOnce: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type TwoFACreateOrConnectWithoutUserInput = {
    where: TwoFAWhereUniqueInput
    create: XOR<TwoFACreateWithoutUserInput, TwoFAUncheckedCreateWithoutUserInput>
  }

  export type TwoFACreateManyUserInputEnvelope = {
    data: TwoFACreateManyUserInput | TwoFACreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserKycUpsertWithoutUserRelInput = {
    update: XOR<UserKycUpdateWithoutUserRelInput, UserKycUncheckedUpdateWithoutUserRelInput>
    create: XOR<UserKycCreateWithoutUserRelInput, UserKycUncheckedCreateWithoutUserRelInput>
    where?: UserKycWhereInput
  }

  export type UserKycUpdateToOneWithWhereWithoutUserRelInput = {
    where?: UserKycWhereInput
    data: XOR<UserKycUpdateWithoutUserRelInput, UserKycUncheckedUpdateWithoutUserRelInput>
  }

  export type UserKycUpdateWithoutUserRelInput = {
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    kycType?: EnumKycTypeFieldUpdateOperationsInput | $Enums.KycType
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    hyperVergeStatus?: NullableEnumHypervergeStatusFieldUpdateOperationsInput | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    EncryptedUserDataRel?: EncryptedUserDataUpdateOneWithoutUserKycNestedInput
  }

  export type UserKycUncheckedUpdateWithoutUserRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    encryptedUserDataId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    kycType?: EnumKycTypeFieldUpdateOperationsInput | $Enums.KycType
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    hyperVergeStatus?: NullableEnumHypervergeStatusFieldUpdateOperationsInput | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserBankDetailsUpsertWithoutUserRelInput = {
    update: XOR<UserBankDetailsUpdateWithoutUserRelInput, UserBankDetailsUncheckedUpdateWithoutUserRelInput>
    create: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput>
    where?: UserBankDetailsWhereInput
  }

  export type UserBankDetailsUpdateToOneWithWhereWithoutUserRelInput = {
    where?: UserBankDetailsWhereInput
    data: XOR<UserBankDetailsUpdateWithoutUserRelInput, UserBankDetailsUncheckedUpdateWithoutUserRelInput>
  }

  export type UserBankDetailsUpdateWithoutUserRelInput = {
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    userRel?: UserUpdateOneWithoutUserBankDetailsRelNestedInput
    UserBankRel?: FiatPaymentsUpdateManyWithoutUserBankRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutSystemBankRelNestedInput
  }

  export type UserBankDetailsUncheckedUpdateWithoutUserRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankRel?: FiatPaymentsUncheckedUpdateManyWithoutUserBankRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutSystemBankRelNestedInput
  }

  export type UserBankDetailsUpsertWithWhereUniqueWithoutUserRelInput = {
    where: UserBankDetailsWhereUniqueInput
    update: XOR<UserBankDetailsUpdateWithoutUserRelInput, UserBankDetailsUncheckedUpdateWithoutUserRelInput>
    create: XOR<UserBankDetailsCreateWithoutUserRelInput, UserBankDetailsUncheckedCreateWithoutUserRelInput>
  }

  export type UserBankDetailsUpdateWithWhereUniqueWithoutUserRelInput = {
    where: UserBankDetailsWhereUniqueInput
    data: XOR<UserBankDetailsUpdateWithoutUserRelInput, UserBankDetailsUncheckedUpdateWithoutUserRelInput>
  }

  export type UserBankDetailsUpdateManyWithWhereWithoutUserRelInput = {
    where: UserBankDetailsScalarWhereInput
    data: XOR<UserBankDetailsUpdateManyMutationInput, UserBankDetailsUncheckedUpdateManyWithoutUserRelInput>
  }

  export type UserBankDetailsScalarWhereInput = {
    AND?: UserBankDetailsScalarWhereInput | UserBankDetailsScalarWhereInput[]
    OR?: UserBankDetailsScalarWhereInput[]
    NOT?: UserBankDetailsScalarWhereInput | UserBankDetailsScalarWhereInput[]
    id?: IntFilter<"UserBankDetails"> | number
    bankDetailsType?: EnumBankDetailsTypeFilter<"UserBankDetails"> | $Enums.BankDetailsType
    userId?: IntNullableFilter<"UserBankDetails"> | number | null
    bankAccountNumber?: StringNullableFilter<"UserBankDetails"> | string | null
    bankName?: StringNullableFilter<"UserBankDetails"> | string | null
    accountHolderName?: StringNullableFilter<"UserBankDetails"> | string | null
    ifsc?: StringNullableFilter<"UserBankDetails"> | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFilter<"UserBankDetails"> | $Enums.BankVerificationStatus
    isActive?: BoolFilter<"UserBankDetails"> | boolean
    createdAt?: DateTimeFilter<"UserBankDetails"> | Date | string
    createdBy?: IntFilter<"UserBankDetails"> | number
    updatedAt?: DateTimeFilter<"UserBankDetails"> | Date | string
    updatedBy?: IntNullableFilter<"UserBankDetails"> | number | null
  }

  export type FiatPaymentsUpsertWithWhereUniqueWithoutUserInput = {
    where: FiatPaymentsWhereUniqueInput
    update: XOR<FiatPaymentsUpdateWithoutUserInput, FiatPaymentsUncheckedUpdateWithoutUserInput>
    create: XOR<FiatPaymentsCreateWithoutUserInput, FiatPaymentsUncheckedCreateWithoutUserInput>
  }

  export type FiatPaymentsUpdateWithWhereUniqueWithoutUserInput = {
    where: FiatPaymentsWhereUniqueInput
    data: XOR<FiatPaymentsUpdateWithoutUserInput, FiatPaymentsUncheckedUpdateWithoutUserInput>
  }

  export type FiatPaymentsUpdateManyWithWhereWithoutUserInput = {
    where: FiatPaymentsScalarWhereInput
    data: XOR<FiatPaymentsUpdateManyMutationInput, FiatPaymentsUncheckedUpdateManyWithoutUserInput>
  }

  export type FiatPaymentsScalarWhereInput = {
    AND?: FiatPaymentsScalarWhereInput | FiatPaymentsScalarWhereInput[]
    OR?: FiatPaymentsScalarWhereInput[]
    NOT?: FiatPaymentsScalarWhereInput | FiatPaymentsScalarWhereInput[]
    id?: IntFilter<"FiatPayments"> | number
    userId?: IntFilter<"FiatPayments"> | number
    paymentType?: EnumPaymentTypeFilter<"FiatPayments"> | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFilter<"FiatPayments"> | $Enums.PaymentStatus
    systemBankId?: IntFilter<"FiatPayments"> | number
    userBankId?: IntFilter<"FiatPayments"> | number
    systemAccountNumber?: StringFilter<"FiatPayments"> | string
    userAccountNumber?: StringFilter<"FiatPayments"> | string
    amount?: FloatFilter<"FiatPayments"> | number
    fee?: FloatFilter<"FiatPayments"> | number
    amountCredited?: FloatNullableFilter<"FiatPayments"> | number | null
    amountDebited?: FloatNullableFilter<"FiatPayments"> | number | null
    bankProofUrl?: StringNullableFilter<"FiatPayments"> | string | null
    receiptNumber?: StringNullableFilter<"FiatPayments"> | string | null
    userRemarks?: StringNullableFilter<"FiatPayments"> | string | null
    adminRemarks?: StringNullableFilter<"FiatPayments"> | string | null
    createdAt?: DateTimeFilter<"FiatPayments"> | Date | string
    createdBy?: IntFilter<"FiatPayments"> | number
    updatedAt?: DateTimeFilter<"FiatPayments"> | Date | string
    updatedBy?: IntFilter<"FiatPayments"> | number
  }

  export type UserAccountUpsertWithoutUserRelInput = {
    update: XOR<UserAccountUpdateWithoutUserRelInput, UserAccountUncheckedUpdateWithoutUserRelInput>
    create: XOR<UserAccountCreateWithoutUserRelInput, UserAccountUncheckedCreateWithoutUserRelInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutUserRelInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutUserRelInput, UserAccountUncheckedUpdateWithoutUserRelInput>
  }

  export type UserAccountUpdateWithoutUserRelInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    InrLedgerRel?: InrLedgerUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutUserRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    InrLedgerRel?: InrLedgerUncheckedUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUncheckedUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUncheckedUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUncheckedUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUncheckedUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type TwoFAUpsertWithWhereUniqueWithoutUserInput = {
    where: TwoFAWhereUniqueInput
    update: XOR<TwoFAUpdateWithoutUserInput, TwoFAUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFACreateWithoutUserInput, TwoFAUncheckedCreateWithoutUserInput>
  }

  export type TwoFAUpdateWithWhereUniqueWithoutUserInput = {
    where: TwoFAWhereUniqueInput
    data: XOR<TwoFAUpdateWithoutUserInput, TwoFAUncheckedUpdateWithoutUserInput>
  }

  export type TwoFAUpdateManyWithWhereWithoutUserInput = {
    where: TwoFAScalarWhereInput
    data: XOR<TwoFAUpdateManyMutationInput, TwoFAUncheckedUpdateManyWithoutUserInput>
  }

  export type TwoFAScalarWhereInput = {
    AND?: TwoFAScalarWhereInput | TwoFAScalarWhereInput[]
    OR?: TwoFAScalarWhereInput[]
    NOT?: TwoFAScalarWhereInput | TwoFAScalarWhereInput[]
    id?: IntFilter<"TwoFA"> | number
    userId?: IntFilter<"TwoFA"> | number
    email?: StringFilter<"TwoFA"> | string
    phone?: StringNullableFilter<"TwoFA"> | string | null
    emailVerified?: DateTimeNullableFilter<"TwoFA"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"TwoFA"> | Date | string | null
    status?: EnumTwoFAStatusFilter<"TwoFA"> | $Enums.TwoFAStatus
    reason?: EnumReasonFilter<"TwoFA"> | $Enums.Reason
    expiryTime?: IntFilter<"TwoFA"> | number
    mobileVerifiedAtleastOnce?: BoolFilter<"TwoFA"> | boolean
    createdAt?: DateTimeFilter<"TwoFA"> | Date | string
    createdBy?: IntFilter<"TwoFA"> | number
    updatedAt?: DateTimeFilter<"TwoFA"> | Date | string
    updatedBy?: IntNullableFilter<"TwoFA"> | number | null
  }

  export type UserCreateWithoutTwoFARelInput = {
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserKycRel?: UserKycCreateNestedOneWithoutUserRelInput
    BankDetailRel?: UserBankDetailsCreateNestedOneWithoutUserRelInput
    UserBankDetailsRel?: UserBankDetailsCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountCreateNestedOneWithoutUserRelInput
  }

  export type UserUncheckedCreateWithoutTwoFARelInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    kycId?: number | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    bankDetailsId?: number | null
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountUncheckedCreateNestedOneWithoutUserRelInput
  }

  export type UserCreateOrConnectWithoutTwoFARelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwoFARelInput, UserUncheckedCreateWithoutTwoFARelInput>
  }

  export type UserUpsertWithoutTwoFARelInput = {
    update: XOR<UserUpdateWithoutTwoFARelInput, UserUncheckedUpdateWithoutTwoFARelInput>
    create: XOR<UserCreateWithoutTwoFARelInput, UserUncheckedCreateWithoutTwoFARelInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwoFARelInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwoFARelInput, UserUncheckedUpdateWithoutTwoFARelInput>
  }

  export type UserUpdateWithoutTwoFARelInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserKycRel?: UserKycUpdateOneWithoutUserRelNestedInput
    BankDetailRel?: UserBankDetailsUpdateOneWithoutUserRelNestedInput
    UserBankDetailsRel?: UserBankDetailsUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUpdateOneWithoutUserRelNestedInput
  }

  export type UserUncheckedUpdateWithoutTwoFARelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    kycId?: NullableIntFieldUpdateOperationsInput | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    bankDetailsId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUncheckedUpdateOneWithoutUserRelNestedInput
  }

  export type EncryptedUserDataCreateWithoutUserKycInput = {
    panNumber?: string | null
    aadharNumber?: string | null
    userId: number
    fileKey?: string | null
    bucketName?: string | null
    initVector?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type EncryptedUserDataUncheckedCreateWithoutUserKycInput = {
    id?: number
    panNumber?: string | null
    aadharNumber?: string | null
    userId: number
    fileKey?: string | null
    bucketName?: string | null
    initVector?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type EncryptedUserDataCreateOrConnectWithoutUserKycInput = {
    where: EncryptedUserDataWhereUniqueInput
    create: XOR<EncryptedUserDataCreateWithoutUserKycInput, EncryptedUserDataUncheckedCreateWithoutUserKycInput>
  }

  export type UserCreateWithoutUserKycRelInput = {
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    BankDetailRel?: UserBankDetailsCreateNestedOneWithoutUserRelInput
    UserBankDetailsRel?: UserBankDetailsCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserKycRelInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    bankVerificationStatus?: $Enums.BankVerificationStatus
    bankDetailsId?: number | null
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountUncheckedCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFAUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserKycRelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserKycRelInput, UserUncheckedCreateWithoutUserKycRelInput>
  }

  export type EncryptedUserDataUpsertWithoutUserKycInput = {
    update: XOR<EncryptedUserDataUpdateWithoutUserKycInput, EncryptedUserDataUncheckedUpdateWithoutUserKycInput>
    create: XOR<EncryptedUserDataCreateWithoutUserKycInput, EncryptedUserDataUncheckedCreateWithoutUserKycInput>
    where?: EncryptedUserDataWhereInput
  }

  export type EncryptedUserDataUpdateToOneWithWhereWithoutUserKycInput = {
    where?: EncryptedUserDataWhereInput
    data: XOR<EncryptedUserDataUpdateWithoutUserKycInput, EncryptedUserDataUncheckedUpdateWithoutUserKycInput>
  }

  export type EncryptedUserDataUpdateWithoutUserKycInput = {
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EncryptedUserDataUncheckedUpdateWithoutUserKycInput = {
    id?: IntFieldUpdateOperationsInput | number
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpsertWithoutUserKycRelInput = {
    update: XOR<UserUpdateWithoutUserKycRelInput, UserUncheckedUpdateWithoutUserKycRelInput>
    create: XOR<UserCreateWithoutUserKycRelInput, UserUncheckedCreateWithoutUserKycRelInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserKycRelInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserKycRelInput, UserUncheckedUpdateWithoutUserKycRelInput>
  }

  export type UserUpdateWithoutUserKycRelInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    BankDetailRel?: UserBankDetailsUpdateOneWithoutUserRelNestedInput
    UserBankDetailsRel?: UserBankDetailsUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserKycRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    bankDetailsId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUncheckedUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserKycCreateWithoutEncryptedUserDataRelInput = {
    fullName?: string | null
    gender?: $Enums.Gender | null
    dob?: string | null
    address?: string | null
    fatherName?: string | null
    kycType: $Enums.KycType
    kycStatus?: $Enums.UserKycStatus
    hyperVergeStatus?: $Enums.HypervergeStatus | null
    panStatus?: $Enums.UserKycStatus
    aadharFrontStatus?: $Enums.UserKycStatus
    aadharBackStatus?: $Enums.UserKycStatus
    selfieStatus?: $Enums.UserKycStatus
    aadharPanNameMatchStatus?: $Enums.UserKycStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel?: UserCreateNestedOneWithoutUserKycRelInput
  }

  export type UserKycUncheckedCreateWithoutEncryptedUserDataRelInput = {
    id?: number
    fullName?: string | null
    gender?: $Enums.Gender | null
    dob?: string | null
    address?: string | null
    fatherName?: string | null
    kycType: $Enums.KycType
    kycStatus?: $Enums.UserKycStatus
    hyperVergeStatus?: $Enums.HypervergeStatus | null
    panStatus?: $Enums.UserKycStatus
    aadharFrontStatus?: $Enums.UserKycStatus
    aadharBackStatus?: $Enums.UserKycStatus
    selfieStatus?: $Enums.UserKycStatus
    aadharPanNameMatchStatus?: $Enums.UserKycStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel?: UserUncheckedCreateNestedOneWithoutUserKycRelInput
  }

  export type UserKycCreateOrConnectWithoutEncryptedUserDataRelInput = {
    where: UserKycWhereUniqueInput
    create: XOR<UserKycCreateWithoutEncryptedUserDataRelInput, UserKycUncheckedCreateWithoutEncryptedUserDataRelInput>
  }

  export type UserKycUpsertWithoutEncryptedUserDataRelInput = {
    update: XOR<UserKycUpdateWithoutEncryptedUserDataRelInput, UserKycUncheckedUpdateWithoutEncryptedUserDataRelInput>
    create: XOR<UserKycCreateWithoutEncryptedUserDataRelInput, UserKycUncheckedCreateWithoutEncryptedUserDataRelInput>
    where?: UserKycWhereInput
  }

  export type UserKycUpdateToOneWithWhereWithoutEncryptedUserDataRelInput = {
    where?: UserKycWhereInput
    data: XOR<UserKycUpdateWithoutEncryptedUserDataRelInput, UserKycUncheckedUpdateWithoutEncryptedUserDataRelInput>
  }

  export type UserKycUpdateWithoutEncryptedUserDataRelInput = {
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    kycType?: EnumKycTypeFieldUpdateOperationsInput | $Enums.KycType
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    hyperVergeStatus?: NullableEnumHypervergeStatusFieldUpdateOperationsInput | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUpdateOneWithoutUserKycRelNestedInput
  }

  export type UserKycUncheckedUpdateWithoutEncryptedUserDataRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null
    kycType?: EnumKycTypeFieldUpdateOperationsInput | $Enums.KycType
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    hyperVergeStatus?: NullableEnumHypervergeStatusFieldUpdateOperationsInput | $Enums.HypervergeStatus | null
    panStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharFrontStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharBackStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    selfieStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    aadharPanNameMatchStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUncheckedUpdateOneWithoutUserKycRelNestedInput
  }

  export type UserCreateWithoutUserBankDetailsRelInput = {
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserKycRel?: UserKycCreateNestedOneWithoutUserRelInput
    BankDetailRel?: UserBankDetailsCreateNestedOneWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserBankDetailsRelInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    kycId?: number | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    bankDetailsId?: number | null
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountUncheckedCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFAUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserBankDetailsRelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserBankDetailsRelInput, UserUncheckedCreateWithoutUserBankDetailsRelInput>
  }

  export type FiatPaymentsCreateWithoutUserBankRelInput = {
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    user?: UserCreateNestedOneWithoutFiatPaymentsRelInput
    systemBankRel?: UserBankDetailsCreateNestedOneWithoutFiatPaymentsRelInput
    BankFeedRel?: BankFeedCreateNestedOneWithoutFiatPaymentInput
  }

  export type FiatPaymentsUncheckedCreateWithoutUserBankRelInput = {
    id?: number
    userId: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    BankFeedRel?: BankFeedUncheckedCreateNestedOneWithoutFiatPaymentInput
  }

  export type FiatPaymentsCreateOrConnectWithoutUserBankRelInput = {
    where: FiatPaymentsWhereUniqueInput
    create: XOR<FiatPaymentsCreateWithoutUserBankRelInput, FiatPaymentsUncheckedCreateWithoutUserBankRelInput>
  }

  export type FiatPaymentsCreateManyUserBankRelInputEnvelope = {
    data: FiatPaymentsCreateManyUserBankRelInput | FiatPaymentsCreateManyUserBankRelInput[]
    skipDuplicates?: boolean
  }

  export type FiatPaymentsCreateWithoutSystemBankRelInput = {
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    user?: UserCreateNestedOneWithoutFiatPaymentsRelInput
    userBankRel?: UserBankDetailsCreateNestedOneWithoutUserBankRelInput
    BankFeedRel?: BankFeedCreateNestedOneWithoutFiatPaymentInput
  }

  export type FiatPaymentsUncheckedCreateWithoutSystemBankRelInput = {
    id?: number
    userId: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    userBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    BankFeedRel?: BankFeedUncheckedCreateNestedOneWithoutFiatPaymentInput
  }

  export type FiatPaymentsCreateOrConnectWithoutSystemBankRelInput = {
    where: FiatPaymentsWhereUniqueInput
    create: XOR<FiatPaymentsCreateWithoutSystemBankRelInput, FiatPaymentsUncheckedCreateWithoutSystemBankRelInput>
  }

  export type FiatPaymentsCreateManySystemBankRelInputEnvelope = {
    data: FiatPaymentsCreateManySystemBankRelInput | FiatPaymentsCreateManySystemBankRelInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBankDetailRelInput = {
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserKycRel?: UserKycCreateNestedOneWithoutUserRelInput
    UserBankDetailsRel?: UserBankDetailsCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBankDetailRelInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    kycId?: number | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedCreateNestedManyWithoutUserRelInput
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserInput
    UserAccountRel?: UserAccountUncheckedCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFAUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBankDetailRelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBankDetailRelInput, UserUncheckedCreateWithoutBankDetailRelInput>
  }

  export type UserCreateManyBankDetailRelInputEnvelope = {
    data: UserCreateManyBankDetailRelInput | UserCreateManyBankDetailRelInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserBankDetailsRelInput = {
    update: XOR<UserUpdateWithoutUserBankDetailsRelInput, UserUncheckedUpdateWithoutUserBankDetailsRelInput>
    create: XOR<UserCreateWithoutUserBankDetailsRelInput, UserUncheckedCreateWithoutUserBankDetailsRelInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserBankDetailsRelInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserBankDetailsRelInput, UserUncheckedUpdateWithoutUserBankDetailsRelInput>
  }

  export type UserUpdateWithoutUserBankDetailsRelInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserKycRel?: UserKycUpdateOneWithoutUserRelNestedInput
    BankDetailRel?: UserBankDetailsUpdateOneWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserBankDetailsRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    kycId?: NullableIntFieldUpdateOperationsInput | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    bankDetailsId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUncheckedUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FiatPaymentsUpsertWithWhereUniqueWithoutUserBankRelInput = {
    where: FiatPaymentsWhereUniqueInput
    update: XOR<FiatPaymentsUpdateWithoutUserBankRelInput, FiatPaymentsUncheckedUpdateWithoutUserBankRelInput>
    create: XOR<FiatPaymentsCreateWithoutUserBankRelInput, FiatPaymentsUncheckedCreateWithoutUserBankRelInput>
  }

  export type FiatPaymentsUpdateWithWhereUniqueWithoutUserBankRelInput = {
    where: FiatPaymentsWhereUniqueInput
    data: XOR<FiatPaymentsUpdateWithoutUserBankRelInput, FiatPaymentsUncheckedUpdateWithoutUserBankRelInput>
  }

  export type FiatPaymentsUpdateManyWithWhereWithoutUserBankRelInput = {
    where: FiatPaymentsScalarWhereInput
    data: XOR<FiatPaymentsUpdateManyMutationInput, FiatPaymentsUncheckedUpdateManyWithoutUserBankRelInput>
  }

  export type FiatPaymentsUpsertWithWhereUniqueWithoutSystemBankRelInput = {
    where: FiatPaymentsWhereUniqueInput
    update: XOR<FiatPaymentsUpdateWithoutSystemBankRelInput, FiatPaymentsUncheckedUpdateWithoutSystemBankRelInput>
    create: XOR<FiatPaymentsCreateWithoutSystemBankRelInput, FiatPaymentsUncheckedCreateWithoutSystemBankRelInput>
  }

  export type FiatPaymentsUpdateWithWhereUniqueWithoutSystemBankRelInput = {
    where: FiatPaymentsWhereUniqueInput
    data: XOR<FiatPaymentsUpdateWithoutSystemBankRelInput, FiatPaymentsUncheckedUpdateWithoutSystemBankRelInput>
  }

  export type FiatPaymentsUpdateManyWithWhereWithoutSystemBankRelInput = {
    where: FiatPaymentsScalarWhereInput
    data: XOR<FiatPaymentsUpdateManyMutationInput, FiatPaymentsUncheckedUpdateManyWithoutSystemBankRelInput>
  }

  export type UserUpsertWithWhereUniqueWithoutBankDetailRelInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBankDetailRelInput, UserUncheckedUpdateWithoutBankDetailRelInput>
    create: XOR<UserCreateWithoutBankDetailRelInput, UserUncheckedCreateWithoutBankDetailRelInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBankDetailRelInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBankDetailRelInput, UserUncheckedUpdateWithoutBankDetailRelInput>
  }

  export type UserUpdateManyWithWhereWithoutBankDetailRelInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBankDetailRelInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    signupType?: EnumSignUpTypeNullableFilter<"User"> | $Enums.SignUpType | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phoneCountryCode?: StringFilter<"User"> | string
    initVector?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    passwordUpdatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    kycStatus?: EnumUserKycStatusFilter<"User"> | $Enums.UserKycStatus
    kycId?: IntNullableFilter<"User"> | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFilter<"User"> | $Enums.BankVerificationStatus
    bankDetailsId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    inrDepositEnabled?: BoolFilter<"User"> | boolean
    cryptoDepositEnabled?: BoolFilter<"User"> | boolean
    inrWithdrawEnabled?: BoolFilter<"User"> | boolean
    cryptoWithdrawEnabled?: BoolFilter<"User"> | boolean
    tradeEnabled?: BoolFilter<"User"> | boolean
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: IntNullableFilter<"User"> | number | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    updatedBy?: IntNullableFilter<"User"> | number | null
  }

  export type UserCreateWithoutFiatPaymentsRelInput = {
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserKycRel?: UserKycCreateNestedOneWithoutUserRelInput
    BankDetailRel?: UserBankDetailsCreateNestedOneWithoutUserRelInput
    UserBankDetailsRel?: UserBankDetailsCreateNestedManyWithoutUserRelInput
    UserAccountRel?: UserAccountCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFACreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFiatPaymentsRelInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    kycId?: number | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    bankDetailsId?: number | null
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedCreateNestedManyWithoutUserRelInput
    UserAccountRel?: UserAccountUncheckedCreateNestedOneWithoutUserRelInput
    TwoFARel?: TwoFAUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFiatPaymentsRelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFiatPaymentsRelInput, UserUncheckedCreateWithoutFiatPaymentsRelInput>
  }

  export type UserBankDetailsCreateWithoutFiatPaymentsRelInput = {
    bankDetailsType?: $Enums.BankDetailsType
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    userRel?: UserCreateNestedOneWithoutUserBankDetailsRelInput
    UserBankRel?: FiatPaymentsCreateNestedManyWithoutUserBankRelInput
    UserRel?: UserCreateNestedManyWithoutBankDetailRelInput
  }

  export type UserBankDetailsUncheckedCreateWithoutFiatPaymentsRelInput = {
    id?: number
    bankDetailsType?: $Enums.BankDetailsType
    userId?: number | null
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    UserBankRel?: FiatPaymentsUncheckedCreateNestedManyWithoutUserBankRelInput
    UserRel?: UserUncheckedCreateNestedManyWithoutBankDetailRelInput
  }

  export type UserBankDetailsCreateOrConnectWithoutFiatPaymentsRelInput = {
    where: UserBankDetailsWhereUniqueInput
    create: XOR<UserBankDetailsCreateWithoutFiatPaymentsRelInput, UserBankDetailsUncheckedCreateWithoutFiatPaymentsRelInput>
  }

  export type UserBankDetailsCreateWithoutUserBankRelInput = {
    bankDetailsType?: $Enums.BankDetailsType
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    userRel?: UserCreateNestedOneWithoutUserBankDetailsRelInput
    FiatPaymentsRel?: FiatPaymentsCreateNestedManyWithoutSystemBankRelInput
    UserRel?: UserCreateNestedManyWithoutBankDetailRelInput
  }

  export type UserBankDetailsUncheckedCreateWithoutUserBankRelInput = {
    id?: number
    bankDetailsType?: $Enums.BankDetailsType
    userId?: number | null
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
    FiatPaymentsRel?: FiatPaymentsUncheckedCreateNestedManyWithoutSystemBankRelInput
    UserRel?: UserUncheckedCreateNestedManyWithoutBankDetailRelInput
  }

  export type UserBankDetailsCreateOrConnectWithoutUserBankRelInput = {
    where: UserBankDetailsWhereUniqueInput
    create: XOR<UserBankDetailsCreateWithoutUserBankRelInput, UserBankDetailsUncheckedCreateWithoutUserBankRelInput>
  }

  export type BankFeedCreateWithoutFiatPaymentInput = {
    serialNumber: number
    amount: string
    fee: string
    bankName: string
    bankRefId: string
    processStatus: $Enums.ProcessStatus
    userRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BankFeedUncheckedCreateWithoutFiatPaymentInput = {
    id?: number
    serialNumber: number
    amount: string
    fee: string
    bankName: string
    bankRefId: string
    processStatus: $Enums.ProcessStatus
    userRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type BankFeedCreateOrConnectWithoutFiatPaymentInput = {
    where: BankFeedWhereUniqueInput
    create: XOR<BankFeedCreateWithoutFiatPaymentInput, BankFeedUncheckedCreateWithoutFiatPaymentInput>
  }

  export type UserUpsertWithoutFiatPaymentsRelInput = {
    update: XOR<UserUpdateWithoutFiatPaymentsRelInput, UserUncheckedUpdateWithoutFiatPaymentsRelInput>
    create: XOR<UserCreateWithoutFiatPaymentsRelInput, UserUncheckedCreateWithoutFiatPaymentsRelInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFiatPaymentsRelInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFiatPaymentsRelInput, UserUncheckedUpdateWithoutFiatPaymentsRelInput>
  }

  export type UserUpdateWithoutFiatPaymentsRelInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserKycRel?: UserKycUpdateOneWithoutUserRelNestedInput
    BankDetailRel?: UserBankDetailsUpdateOneWithoutUserRelNestedInput
    UserBankDetailsRel?: UserBankDetailsUpdateManyWithoutUserRelNestedInput
    UserAccountRel?: UserAccountUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFiatPaymentsRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    kycId?: NullableIntFieldUpdateOperationsInput | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    bankDetailsId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedUpdateManyWithoutUserRelNestedInput
    UserAccountRel?: UserAccountUncheckedUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserBankDetailsUpsertWithoutFiatPaymentsRelInput = {
    update: XOR<UserBankDetailsUpdateWithoutFiatPaymentsRelInput, UserBankDetailsUncheckedUpdateWithoutFiatPaymentsRelInput>
    create: XOR<UserBankDetailsCreateWithoutFiatPaymentsRelInput, UserBankDetailsUncheckedCreateWithoutFiatPaymentsRelInput>
    where?: UserBankDetailsWhereInput
  }

  export type UserBankDetailsUpdateToOneWithWhereWithoutFiatPaymentsRelInput = {
    where?: UserBankDetailsWhereInput
    data: XOR<UserBankDetailsUpdateWithoutFiatPaymentsRelInput, UserBankDetailsUncheckedUpdateWithoutFiatPaymentsRelInput>
  }

  export type UserBankDetailsUpdateWithoutFiatPaymentsRelInput = {
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    userRel?: UserUpdateOneWithoutUserBankDetailsRelNestedInput
    UserBankRel?: FiatPaymentsUpdateManyWithoutUserBankRelNestedInput
    UserRel?: UserUpdateManyWithoutBankDetailRelNestedInput
  }

  export type UserBankDetailsUncheckedUpdateWithoutFiatPaymentsRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankRel?: FiatPaymentsUncheckedUpdateManyWithoutUserBankRelNestedInput
    UserRel?: UserUncheckedUpdateManyWithoutBankDetailRelNestedInput
  }

  export type UserBankDetailsUpsertWithoutUserBankRelInput = {
    update: XOR<UserBankDetailsUpdateWithoutUserBankRelInput, UserBankDetailsUncheckedUpdateWithoutUserBankRelInput>
    create: XOR<UserBankDetailsCreateWithoutUserBankRelInput, UserBankDetailsUncheckedCreateWithoutUserBankRelInput>
    where?: UserBankDetailsWhereInput
  }

  export type UserBankDetailsUpdateToOneWithWhereWithoutUserBankRelInput = {
    where?: UserBankDetailsWhereInput
    data: XOR<UserBankDetailsUpdateWithoutUserBankRelInput, UserBankDetailsUncheckedUpdateWithoutUserBankRelInput>
  }

  export type UserBankDetailsUpdateWithoutUserBankRelInput = {
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    userRel?: UserUpdateOneWithoutUserBankDetailsRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutSystemBankRelNestedInput
    UserRel?: UserUpdateManyWithoutBankDetailRelNestedInput
  }

  export type UserBankDetailsUncheckedUpdateWithoutUserBankRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutSystemBankRelNestedInput
    UserRel?: UserUncheckedUpdateManyWithoutBankDetailRelNestedInput
  }

  export type BankFeedUpsertWithoutFiatPaymentInput = {
    update: XOR<BankFeedUpdateWithoutFiatPaymentInput, BankFeedUncheckedUpdateWithoutFiatPaymentInput>
    create: XOR<BankFeedCreateWithoutFiatPaymentInput, BankFeedUncheckedCreateWithoutFiatPaymentInput>
    where?: BankFeedWhereInput
  }

  export type BankFeedUpdateToOneWithWhereWithoutFiatPaymentInput = {
    where?: BankFeedWhereInput
    data: XOR<BankFeedUpdateWithoutFiatPaymentInput, BankFeedUncheckedUpdateWithoutFiatPaymentInput>
  }

  export type BankFeedUpdateWithoutFiatPaymentInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    amount?: StringFieldUpdateOperationsInput | string
    fee?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankRefId?: StringFieldUpdateOperationsInput | string
    processStatus?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type BankFeedUncheckedUpdateWithoutFiatPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    amount?: StringFieldUpdateOperationsInput | string
    fee?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankRefId?: StringFieldUpdateOperationsInput | string
    processStatus?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoWalletCreateWithoutCryptoDepositInput = {
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    account?: UserAccountCreateNestedOneWithoutCryptoWalletRelInput
    parentWallet: ParentWalletCreateNestedOneWithoutChildCryptoWalletInput
  }

  export type CryptoWalletUncheckedCreateWithoutCryptoDepositInput = {
    id?: number
    accountId?: number | null
    parentWalletId: number
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoWalletCreateOrConnectWithoutCryptoDepositInput = {
    where: CryptoWalletWhereUniqueInput
    create: XOR<CryptoWalletCreateWithoutCryptoDepositInput, CryptoWalletUncheckedCreateWithoutCryptoDepositInput>
  }

  export type InrConversionHistoryCreateWithoutCryptoDepositInput = {
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    account: UserAccountCreateNestedOneWithoutInrConvRelInput
  }

  export type InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput = {
    id?: number
    accountId: number
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrConversionHistoryCreateOrConnectWithoutCryptoDepositInput = {
    where: InrConversionHistoryWhereUniqueInput
    create: XOR<InrConversionHistoryCreateWithoutCryptoDepositInput, InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput>
  }

  export type InrConversionHistoryCreateManyCryptoDepositInputEnvelope = {
    data: InrConversionHistoryCreateManyCryptoDepositInput | InrConversionHistoryCreateManyCryptoDepositInput[]
    skipDuplicates?: boolean
  }

  export type CryptoWalletUpsertWithoutCryptoDepositInput = {
    update: XOR<CryptoWalletUpdateWithoutCryptoDepositInput, CryptoWalletUncheckedUpdateWithoutCryptoDepositInput>
    create: XOR<CryptoWalletCreateWithoutCryptoDepositInput, CryptoWalletUncheckedCreateWithoutCryptoDepositInput>
    where?: CryptoWalletWhereInput
  }

  export type CryptoWalletUpdateToOneWithWhereWithoutCryptoDepositInput = {
    where?: CryptoWalletWhereInput
    data: XOR<CryptoWalletUpdateWithoutCryptoDepositInput, CryptoWalletUncheckedUpdateWithoutCryptoDepositInput>
  }

  export type CryptoWalletUpdateWithoutCryptoDepositInput = {
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    account?: UserAccountUpdateOneWithoutCryptoWalletRelNestedInput
    parentWallet?: ParentWalletUpdateOneRequiredWithoutChildCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateWithoutCryptoDepositInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    parentWalletId?: IntFieldUpdateOperationsInput | number
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrConversionHistoryUpsertWithWhereUniqueWithoutCryptoDepositInput = {
    where: InrConversionHistoryWhereUniqueInput
    update: XOR<InrConversionHistoryUpdateWithoutCryptoDepositInput, InrConversionHistoryUncheckedUpdateWithoutCryptoDepositInput>
    create: XOR<InrConversionHistoryCreateWithoutCryptoDepositInput, InrConversionHistoryUncheckedCreateWithoutCryptoDepositInput>
  }

  export type InrConversionHistoryUpdateWithWhereUniqueWithoutCryptoDepositInput = {
    where: InrConversionHistoryWhereUniqueInput
    data: XOR<InrConversionHistoryUpdateWithoutCryptoDepositInput, InrConversionHistoryUncheckedUpdateWithoutCryptoDepositInput>
  }

  export type InrConversionHistoryUpdateManyWithWhereWithoutCryptoDepositInput = {
    where: InrConversionHistoryScalarWhereInput
    data: XOR<InrConversionHistoryUpdateManyMutationInput, InrConversionHistoryUncheckedUpdateManyWithoutCryptoDepositInput>
  }

  export type CryptoDepositCreateWithoutInrConvHistRelInput = {
    accountId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee?: string | null
    effectiveChange?: string | null
    runningBalance?: string | null
    externalAddress?: string | null
    effectiveChangeUsd?: string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: string | null
    explorerLink?: string | null
    inputs?: CryptoDepositCreateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositCreateoutputsInput | InputJsonValue[]
    sequenceId?: string | null
    type?: string | null
    conversionRate?: string | null
    isConverted?: boolean | null
    conversionTimestamp?: Date | string | null
    inrCreditStatus?: $Enums.InrCreditStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    cryptoWallet?: CryptoWalletCreateNestedOneWithoutCryptoDepositInput
  }

  export type CryptoDepositUncheckedCreateWithoutInrConvHistRelInput = {
    id?: number
    accountId: number
    cryptoWalletId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee?: string | null
    effectiveChange?: string | null
    runningBalance?: string | null
    externalAddress?: string | null
    effectiveChangeUsd?: string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: string | null
    explorerLink?: string | null
    inputs?: CryptoDepositCreateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositCreateoutputsInput | InputJsonValue[]
    sequenceId?: string | null
    type?: string | null
    conversionRate?: string | null
    isConverted?: boolean | null
    conversionTimestamp?: Date | string | null
    inrCreditStatus?: $Enums.InrCreditStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoDepositCreateOrConnectWithoutInrConvHistRelInput = {
    where: CryptoDepositWhereUniqueInput
    create: XOR<CryptoDepositCreateWithoutInrConvHistRelInput, CryptoDepositUncheckedCreateWithoutInrConvHistRelInput>
  }

  export type UserAccountCreateWithoutInrConvRelInput = {
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel: UserCreateNestedOneWithoutUserAccountRelInput
    InrLedgerRel?: InrLedgerCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUncheckedCreateWithoutInrConvRelInput = {
    id?: number
    userId: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    InrLedgerRel?: InrLedgerUncheckedCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerUncheckedCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerUncheckedCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletUncheckedCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletUncheckedCreateNestedManyWithoutAccountInput
  }

  export type UserAccountCreateOrConnectWithoutInrConvRelInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutInrConvRelInput, UserAccountUncheckedCreateWithoutInrConvRelInput>
  }

  export type CryptoDepositUpsertWithoutInrConvHistRelInput = {
    update: XOR<CryptoDepositUpdateWithoutInrConvHistRelInput, CryptoDepositUncheckedUpdateWithoutInrConvHistRelInput>
    create: XOR<CryptoDepositCreateWithoutInrConvHistRelInput, CryptoDepositUncheckedCreateWithoutInrConvHistRelInput>
    where?: CryptoDepositWhereInput
  }

  export type CryptoDepositUpdateToOneWithWhereWithoutInrConvHistRelInput = {
    where?: CryptoDepositWhereInput
    data: XOR<CryptoDepositUpdateWithoutInrConvHistRelInput, CryptoDepositUncheckedUpdateWithoutInrConvHistRelInput>
  }

  export type CryptoDepositUpdateWithoutInrConvHistRelInput = {
    accountId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    cryptoWallet?: CryptoWalletUpdateOneWithoutCryptoDepositNestedInput
  }

  export type CryptoDepositUncheckedUpdateWithoutInrConvHistRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    cryptoWalletId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserAccountUpsertWithoutInrConvRelInput = {
    update: XOR<UserAccountUpdateWithoutInrConvRelInput, UserAccountUncheckedUpdateWithoutInrConvRelInput>
    create: XOR<UserAccountCreateWithoutInrConvRelInput, UserAccountUncheckedCreateWithoutInrConvRelInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutInrConvRelInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutInrConvRelInput, UserAccountUncheckedUpdateWithoutInrConvRelInput>
  }

  export type UserAccountUpdateWithoutInrConvRelInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUpdateOneRequiredWithoutUserAccountRelNestedInput
    InrLedgerRel?: InrLedgerUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutInrConvRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    InrLedgerRel?: InrLedgerUncheckedUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUncheckedUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUncheckedUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUncheckedUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type FiatPaymentsCreateWithoutBankFeedRelInput = {
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    user?: UserCreateNestedOneWithoutFiatPaymentsRelInput
    systemBankRel?: UserBankDetailsCreateNestedOneWithoutFiatPaymentsRelInput
    userBankRel?: UserBankDetailsCreateNestedOneWithoutUserBankRelInput
  }

  export type FiatPaymentsUncheckedCreateWithoutBankFeedRelInput = {
    id?: number
    userId: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemBankId: number
    userBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type FiatPaymentsCreateOrConnectWithoutBankFeedRelInput = {
    where: FiatPaymentsWhereUniqueInput
    create: XOR<FiatPaymentsCreateWithoutBankFeedRelInput, FiatPaymentsUncheckedCreateWithoutBankFeedRelInput>
  }

  export type FiatPaymentsUpsertWithoutBankFeedRelInput = {
    update: XOR<FiatPaymentsUpdateWithoutBankFeedRelInput, FiatPaymentsUncheckedUpdateWithoutBankFeedRelInput>
    create: XOR<FiatPaymentsCreateWithoutBankFeedRelInput, FiatPaymentsUncheckedCreateWithoutBankFeedRelInput>
    where?: FiatPaymentsWhereInput
  }

  export type FiatPaymentsUpdateToOneWithWhereWithoutBankFeedRelInput = {
    where?: FiatPaymentsWhereInput
    data: XOR<FiatPaymentsUpdateWithoutBankFeedRelInput, FiatPaymentsUncheckedUpdateWithoutBankFeedRelInput>
  }

  export type FiatPaymentsUpdateWithoutBankFeedRelInput = {
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutFiatPaymentsRelNestedInput
    systemBankRel?: UserBankDetailsUpdateOneWithoutFiatPaymentsRelNestedInput
    userBankRel?: UserBankDetailsUpdateOneWithoutUserBankRelNestedInput
  }

  export type FiatPaymentsUncheckedUpdateWithoutBankFeedRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemBankId?: IntFieldUpdateOperationsInput | number
    userBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserAccountCreateWithoutInrLedgerRelInput = {
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel: UserCreateNestedOneWithoutUserAccountRelInput
    CryptoLedgerRel?: CryptoLedgerCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUncheckedCreateWithoutInrLedgerRelInput = {
    id?: number
    userId: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    CryptoLedgerRel?: CryptoLedgerUncheckedCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerUncheckedCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletUncheckedCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletUncheckedCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type UserAccountCreateOrConnectWithoutInrLedgerRelInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutInrLedgerRelInput, UserAccountUncheckedCreateWithoutInrLedgerRelInput>
  }

  export type UserAccountUpsertWithoutInrLedgerRelInput = {
    update: XOR<UserAccountUpdateWithoutInrLedgerRelInput, UserAccountUncheckedUpdateWithoutInrLedgerRelInput>
    create: XOR<UserAccountCreateWithoutInrLedgerRelInput, UserAccountUncheckedCreateWithoutInrLedgerRelInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutInrLedgerRelInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutInrLedgerRelInput, UserAccountUncheckedUpdateWithoutInrLedgerRelInput>
  }

  export type UserAccountUpdateWithoutInrLedgerRelInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUpdateOneRequiredWithoutUserAccountRelNestedInput
    CryptoLedgerRel?: CryptoLedgerUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutInrLedgerRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    CryptoLedgerRel?: CryptoLedgerUncheckedUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUncheckedUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUncheckedUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUncheckedUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountCreateWithoutCryptoLedgerRelInput = {
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel: UserCreateNestedOneWithoutUserAccountRelInput
    InrLedgerRel?: InrLedgerCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUncheckedCreateWithoutCryptoLedgerRelInput = {
    id?: number
    userId: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    InrLedgerRel?: InrLedgerUncheckedCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerUncheckedCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletUncheckedCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletUncheckedCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type UserAccountCreateOrConnectWithoutCryptoLedgerRelInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutCryptoLedgerRelInput, UserAccountUncheckedCreateWithoutCryptoLedgerRelInput>
  }

  export type UserAccountUpsertWithoutCryptoLedgerRelInput = {
    update: XOR<UserAccountUpdateWithoutCryptoLedgerRelInput, UserAccountUncheckedUpdateWithoutCryptoLedgerRelInput>
    create: XOR<UserAccountCreateWithoutCryptoLedgerRelInput, UserAccountUncheckedCreateWithoutCryptoLedgerRelInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutCryptoLedgerRelInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutCryptoLedgerRelInput, UserAccountUncheckedUpdateWithoutCryptoLedgerRelInput>
  }

  export type UserAccountUpdateWithoutCryptoLedgerRelInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUpdateOneRequiredWithoutUserAccountRelNestedInput
    InrLedgerRel?: InrLedgerUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutCryptoLedgerRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    InrLedgerRel?: InrLedgerUncheckedUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUncheckedUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUncheckedUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUncheckedUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountCreateWithoutTradeLedgerRelInput = {
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel: UserCreateNestedOneWithoutUserAccountRelInput
    InrLedgerRel?: InrLedgerCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUncheckedCreateWithoutTradeLedgerRelInput = {
    id?: number
    userId: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    InrLedgerRel?: InrLedgerUncheckedCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerUncheckedCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletUncheckedCreateNestedOneWithoutAccountInput
    CryptoWalletRel?: CryptoWalletUncheckedCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type UserAccountCreateOrConnectWithoutTradeLedgerRelInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutTradeLedgerRelInput, UserAccountUncheckedCreateWithoutTradeLedgerRelInput>
  }

  export type UserAccountUpsertWithoutTradeLedgerRelInput = {
    update: XOR<UserAccountUpdateWithoutTradeLedgerRelInput, UserAccountUncheckedUpdateWithoutTradeLedgerRelInput>
    create: XOR<UserAccountCreateWithoutTradeLedgerRelInput, UserAccountUncheckedCreateWithoutTradeLedgerRelInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutTradeLedgerRelInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutTradeLedgerRelInput, UserAccountUncheckedUpdateWithoutTradeLedgerRelInput>
  }

  export type UserAccountUpdateWithoutTradeLedgerRelInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUpdateOneRequiredWithoutUserAccountRelNestedInput
    InrLedgerRel?: InrLedgerUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutTradeLedgerRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    InrLedgerRel?: InrLedgerUncheckedUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUncheckedUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUncheckedUpdateOneWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUncheckedUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountCreateWithoutInrWalletRelInput = {
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel: UserCreateNestedOneWithoutUserAccountRelInput
    InrLedgerRel?: InrLedgerCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerCreateNestedManyWithoutAccountInput
    CryptoWalletRel?: CryptoWalletCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUncheckedCreateWithoutInrWalletRelInput = {
    id?: number
    userId: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    InrLedgerRel?: InrLedgerUncheckedCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerUncheckedCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerUncheckedCreateNestedManyWithoutAccountInput
    CryptoWalletRel?: CryptoWalletUncheckedCreateNestedManyWithoutAccountInput
    InrConvRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type UserAccountCreateOrConnectWithoutInrWalletRelInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutInrWalletRelInput, UserAccountUncheckedCreateWithoutInrWalletRelInput>
  }

  export type UserAccountUpsertWithoutInrWalletRelInput = {
    update: XOR<UserAccountUpdateWithoutInrWalletRelInput, UserAccountUncheckedUpdateWithoutInrWalletRelInput>
    create: XOR<UserAccountCreateWithoutInrWalletRelInput, UserAccountUncheckedCreateWithoutInrWalletRelInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutInrWalletRelInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutInrWalletRelInput, UserAccountUncheckedUpdateWithoutInrWalletRelInput>
  }

  export type UserAccountUpdateWithoutInrWalletRelInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUpdateOneRequiredWithoutUserAccountRelNestedInput
    InrLedgerRel?: InrLedgerUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUpdateManyWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutInrWalletRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    InrLedgerRel?: InrLedgerUncheckedUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUncheckedUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUncheckedUpdateManyWithoutAccountNestedInput
    CryptoWalletRel?: CryptoWalletUncheckedUpdateManyWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CryptoWalletCreateWithoutParentWalletInput = {
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    account?: UserAccountCreateNestedOneWithoutCryptoWalletRelInput
    cryptoDeposit?: CryptoDepositCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletUncheckedCreateWithoutParentWalletInput = {
    id?: number
    accountId?: number | null
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    cryptoDeposit?: CryptoDepositUncheckedCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletCreateOrConnectWithoutParentWalletInput = {
    where: CryptoWalletWhereUniqueInput
    create: XOR<CryptoWalletCreateWithoutParentWalletInput, CryptoWalletUncheckedCreateWithoutParentWalletInput>
  }

  export type CryptoWalletCreateManyParentWalletInputEnvelope = {
    data: CryptoWalletCreateManyParentWalletInput | CryptoWalletCreateManyParentWalletInput[]
    skipDuplicates?: boolean
  }

  export type StableCoinCreateWithoutParentWalletInput = {
    token: string
    parentChain: string
    tokenIconUrl?: string | null
  }

  export type StableCoinUncheckedCreateWithoutParentWalletInput = {
    id?: number
    token: string
    parentChain: string
    tokenIconUrl?: string | null
  }

  export type StableCoinCreateOrConnectWithoutParentWalletInput = {
    where: StableCoinWhereUniqueInput
    create: XOR<StableCoinCreateWithoutParentWalletInput, StableCoinUncheckedCreateWithoutParentWalletInput>
  }

  export type StableCoinCreateManyParentWalletInputEnvelope = {
    data: StableCoinCreateManyParentWalletInput | StableCoinCreateManyParentWalletInput[]
    skipDuplicates?: boolean
  }

  export type CryptoWalletUpsertWithWhereUniqueWithoutParentWalletInput = {
    where: CryptoWalletWhereUniqueInput
    update: XOR<CryptoWalletUpdateWithoutParentWalletInput, CryptoWalletUncheckedUpdateWithoutParentWalletInput>
    create: XOR<CryptoWalletCreateWithoutParentWalletInput, CryptoWalletUncheckedCreateWithoutParentWalletInput>
  }

  export type CryptoWalletUpdateWithWhereUniqueWithoutParentWalletInput = {
    where: CryptoWalletWhereUniqueInput
    data: XOR<CryptoWalletUpdateWithoutParentWalletInput, CryptoWalletUncheckedUpdateWithoutParentWalletInput>
  }

  export type CryptoWalletUpdateManyWithWhereWithoutParentWalletInput = {
    where: CryptoWalletScalarWhereInput
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyWithoutParentWalletInput>
  }

  export type StableCoinUpsertWithWhereUniqueWithoutParentWalletInput = {
    where: StableCoinWhereUniqueInput
    update: XOR<StableCoinUpdateWithoutParentWalletInput, StableCoinUncheckedUpdateWithoutParentWalletInput>
    create: XOR<StableCoinCreateWithoutParentWalletInput, StableCoinUncheckedCreateWithoutParentWalletInput>
  }

  export type StableCoinUpdateWithWhereUniqueWithoutParentWalletInput = {
    where: StableCoinWhereUniqueInput
    data: XOR<StableCoinUpdateWithoutParentWalletInput, StableCoinUncheckedUpdateWithoutParentWalletInput>
  }

  export type StableCoinUpdateManyWithWhereWithoutParentWalletInput = {
    where: StableCoinScalarWhereInput
    data: XOR<StableCoinUpdateManyMutationInput, StableCoinUncheckedUpdateManyWithoutParentWalletInput>
  }

  export type StableCoinScalarWhereInput = {
    AND?: StableCoinScalarWhereInput | StableCoinScalarWhereInput[]
    OR?: StableCoinScalarWhereInput[]
    NOT?: StableCoinScalarWhereInput | StableCoinScalarWhereInput[]
    id?: IntFilter<"StableCoin"> | number
    parentWalletId?: IntFilter<"StableCoin"> | number
    token?: StringFilter<"StableCoin"> | string
    parentChain?: StringFilter<"StableCoin"> | string
    tokenIconUrl?: StringNullableFilter<"StableCoin"> | string | null
  }

  export type ParentWalletCreateWithoutParentWalletInput = {
    walletId: number
    walletAddress: string
    chain: string
    coin: string
    parentChain: string
    type: string
    subType: $Enums.ParentWalletType
    lastUsedIndex: number
    displayName?: string | null
    toBeDisplayed?: boolean
    parentChainIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childCryptoWallet?: CryptoWalletCreateNestedManyWithoutParentWalletInput
  }

  export type ParentWalletUncheckedCreateWithoutParentWalletInput = {
    id?: number
    walletId: number
    walletAddress: string
    chain: string
    coin: string
    parentChain: string
    type: string
    subType: $Enums.ParentWalletType
    lastUsedIndex: number
    displayName?: string | null
    toBeDisplayed?: boolean
    parentChainIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childCryptoWallet?: CryptoWalletUncheckedCreateNestedManyWithoutParentWalletInput
  }

  export type ParentWalletCreateOrConnectWithoutParentWalletInput = {
    where: ParentWalletWhereUniqueInput
    create: XOR<ParentWalletCreateWithoutParentWalletInput, ParentWalletUncheckedCreateWithoutParentWalletInput>
  }

  export type ParentWalletUpsertWithoutParentWalletInput = {
    update: XOR<ParentWalletUpdateWithoutParentWalletInput, ParentWalletUncheckedUpdateWithoutParentWalletInput>
    create: XOR<ParentWalletCreateWithoutParentWalletInput, ParentWalletUncheckedCreateWithoutParentWalletInput>
    where?: ParentWalletWhereInput
  }

  export type ParentWalletUpdateToOneWithWhereWithoutParentWalletInput = {
    where?: ParentWalletWhereInput
    data: XOR<ParentWalletUpdateWithoutParentWalletInput, ParentWalletUncheckedUpdateWithoutParentWalletInput>
  }

  export type ParentWalletUpdateWithoutParentWalletInput = {
    walletId?: IntFieldUpdateOperationsInput | number
    walletAddress?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: EnumParentWalletTypeFieldUpdateOperationsInput | $Enums.ParentWalletType
    lastUsedIndex?: IntFieldUpdateOperationsInput | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    toBeDisplayed?: BoolFieldUpdateOperationsInput | boolean
    parentChainIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childCryptoWallet?: CryptoWalletUpdateManyWithoutParentWalletNestedInput
  }

  export type ParentWalletUncheckedUpdateWithoutParentWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    walletAddress?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: EnumParentWalletTypeFieldUpdateOperationsInput | $Enums.ParentWalletType
    lastUsedIndex?: IntFieldUpdateOperationsInput | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    toBeDisplayed?: BoolFieldUpdateOperationsInput | boolean
    parentChainIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childCryptoWallet?: CryptoWalletUncheckedUpdateManyWithoutParentWalletNestedInput
  }

  export type UserAccountCreateWithoutCryptoWalletRelInput = {
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    UserRel: UserCreateNestedOneWithoutUserAccountRelInput
    InrLedgerRel?: InrLedgerCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletCreateNestedOneWithoutAccountInput
    InrConvRel?: InrConversionHistoryCreateNestedManyWithoutAccountInput
  }

  export type UserAccountUncheckedCreateWithoutCryptoWalletRelInput = {
    id?: number
    userId: number
    parentAccount?: number | null
    accountType?: $Enums.UserAccountType
    isActive?: boolean
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
    InrLedgerRel?: InrLedgerUncheckedCreateNestedManyWithoutAccountInput
    CryptoLedgerRel?: CryptoLedgerUncheckedCreateNestedManyWithoutAccountInput
    TradeLedgerRel?: TradeLedgerUncheckedCreateNestedManyWithoutAccountInput
    InrWalletRel?: InrWalletUncheckedCreateNestedOneWithoutAccountInput
    InrConvRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type UserAccountCreateOrConnectWithoutCryptoWalletRelInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutCryptoWalletRelInput, UserAccountUncheckedCreateWithoutCryptoWalletRelInput>
  }

  export type ParentWalletCreateWithoutChildCryptoWalletInput = {
    walletId: number
    walletAddress: string
    chain: string
    coin: string
    parentChain: string
    type: string
    subType: $Enums.ParentWalletType
    lastUsedIndex: number
    displayName?: string | null
    toBeDisplayed?: boolean
    parentChainIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentWallet?: StableCoinCreateNestedManyWithoutParentWalletInput
  }

  export type ParentWalletUncheckedCreateWithoutChildCryptoWalletInput = {
    id?: number
    walletId: number
    walletAddress: string
    chain: string
    coin: string
    parentChain: string
    type: string
    subType: $Enums.ParentWalletType
    lastUsedIndex: number
    displayName?: string | null
    toBeDisplayed?: boolean
    parentChainIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentWallet?: StableCoinUncheckedCreateNestedManyWithoutParentWalletInput
  }

  export type ParentWalletCreateOrConnectWithoutChildCryptoWalletInput = {
    where: ParentWalletWhereUniqueInput
    create: XOR<ParentWalletCreateWithoutChildCryptoWalletInput, ParentWalletUncheckedCreateWithoutChildCryptoWalletInput>
  }

  export type CryptoDepositCreateWithoutCryptoWalletInput = {
    accountId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee?: string | null
    effectiveChange?: string | null
    runningBalance?: string | null
    externalAddress?: string | null
    effectiveChangeUsd?: string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: string | null
    explorerLink?: string | null
    inputs?: CryptoDepositCreateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositCreateoutputsInput | InputJsonValue[]
    sequenceId?: string | null
    type?: string | null
    conversionRate?: string | null
    isConverted?: boolean | null
    conversionTimestamp?: Date | string | null
    inrCreditStatus?: $Enums.InrCreditStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    inrConvHistRel?: InrConversionHistoryCreateNestedManyWithoutCryptoDepositInput
  }

  export type CryptoDepositUncheckedCreateWithoutCryptoWalletInput = {
    id?: number
    accountId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee?: string | null
    effectiveChange?: string | null
    runningBalance?: string | null
    externalAddress?: string | null
    effectiveChangeUsd?: string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: string | null
    explorerLink?: string | null
    inputs?: CryptoDepositCreateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositCreateoutputsInput | InputJsonValue[]
    sequenceId?: string | null
    type?: string | null
    conversionRate?: string | null
    isConverted?: boolean | null
    conversionTimestamp?: Date | string | null
    inrCreditStatus?: $Enums.InrCreditStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
    inrConvHistRel?: InrConversionHistoryUncheckedCreateNestedManyWithoutCryptoDepositInput
  }

  export type CryptoDepositCreateOrConnectWithoutCryptoWalletInput = {
    where: CryptoDepositWhereUniqueInput
    create: XOR<CryptoDepositCreateWithoutCryptoWalletInput, CryptoDepositUncheckedCreateWithoutCryptoWalletInput>
  }

  export type CryptoDepositCreateManyCryptoWalletInputEnvelope = {
    data: CryptoDepositCreateManyCryptoWalletInput | CryptoDepositCreateManyCryptoWalletInput[]
    skipDuplicates?: boolean
  }

  export type UserAccountUpsertWithoutCryptoWalletRelInput = {
    update: XOR<UserAccountUpdateWithoutCryptoWalletRelInput, UserAccountUncheckedUpdateWithoutCryptoWalletRelInput>
    create: XOR<UserAccountCreateWithoutCryptoWalletRelInput, UserAccountUncheckedCreateWithoutCryptoWalletRelInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutCryptoWalletRelInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutCryptoWalletRelInput, UserAccountUncheckedUpdateWithoutCryptoWalletRelInput>
  }

  export type UserAccountUpdateWithoutCryptoWalletRelInput = {
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserRel?: UserUpdateOneRequiredWithoutUserAccountRelNestedInput
    InrLedgerRel?: InrLedgerUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUpdateOneWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutCryptoWalletRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentAccount?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: EnumUserAccountTypeFieldUpdateOperationsInput | $Enums.UserAccountType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    InrLedgerRel?: InrLedgerUncheckedUpdateManyWithoutAccountNestedInput
    CryptoLedgerRel?: CryptoLedgerUncheckedUpdateManyWithoutAccountNestedInput
    TradeLedgerRel?: TradeLedgerUncheckedUpdateManyWithoutAccountNestedInput
    InrWalletRel?: InrWalletUncheckedUpdateOneWithoutAccountNestedInput
    InrConvRel?: InrConversionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ParentWalletUpsertWithoutChildCryptoWalletInput = {
    update: XOR<ParentWalletUpdateWithoutChildCryptoWalletInput, ParentWalletUncheckedUpdateWithoutChildCryptoWalletInput>
    create: XOR<ParentWalletCreateWithoutChildCryptoWalletInput, ParentWalletUncheckedCreateWithoutChildCryptoWalletInput>
    where?: ParentWalletWhereInput
  }

  export type ParentWalletUpdateToOneWithWhereWithoutChildCryptoWalletInput = {
    where?: ParentWalletWhereInput
    data: XOR<ParentWalletUpdateWithoutChildCryptoWalletInput, ParentWalletUncheckedUpdateWithoutChildCryptoWalletInput>
  }

  export type ParentWalletUpdateWithoutChildCryptoWalletInput = {
    walletId?: IntFieldUpdateOperationsInput | number
    walletAddress?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: EnumParentWalletTypeFieldUpdateOperationsInput | $Enums.ParentWalletType
    lastUsedIndex?: IntFieldUpdateOperationsInput | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    toBeDisplayed?: BoolFieldUpdateOperationsInput | boolean
    parentChainIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentWallet?: StableCoinUpdateManyWithoutParentWalletNestedInput
  }

  export type ParentWalletUncheckedUpdateWithoutChildCryptoWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletId?: IntFieldUpdateOperationsInput | number
    walletAddress?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: EnumParentWalletTypeFieldUpdateOperationsInput | $Enums.ParentWalletType
    lastUsedIndex?: IntFieldUpdateOperationsInput | number
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    toBeDisplayed?: BoolFieldUpdateOperationsInput | boolean
    parentChainIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentWallet?: StableCoinUncheckedUpdateManyWithoutParentWalletNestedInput
  }

  export type CryptoDepositUpsertWithWhereUniqueWithoutCryptoWalletInput = {
    where: CryptoDepositWhereUniqueInput
    update: XOR<CryptoDepositUpdateWithoutCryptoWalletInput, CryptoDepositUncheckedUpdateWithoutCryptoWalletInput>
    create: XOR<CryptoDepositCreateWithoutCryptoWalletInput, CryptoDepositUncheckedCreateWithoutCryptoWalletInput>
  }

  export type CryptoDepositUpdateWithWhereUniqueWithoutCryptoWalletInput = {
    where: CryptoDepositWhereUniqueInput
    data: XOR<CryptoDepositUpdateWithoutCryptoWalletInput, CryptoDepositUncheckedUpdateWithoutCryptoWalletInput>
  }

  export type CryptoDepositUpdateManyWithWhereWithoutCryptoWalletInput = {
    where: CryptoDepositScalarWhereInput
    data: XOR<CryptoDepositUpdateManyMutationInput, CryptoDepositUncheckedUpdateManyWithoutCryptoWalletInput>
  }

  export type CryptoDepositScalarWhereInput = {
    AND?: CryptoDepositScalarWhereInput | CryptoDepositScalarWhereInput[]
    OR?: CryptoDepositScalarWhereInput[]
    NOT?: CryptoDepositScalarWhereInput | CryptoDepositScalarWhereInput[]
    id?: IntFilter<"CryptoDeposit"> | number
    accountId?: IntFilter<"CryptoDeposit"> | number
    cryptoWalletId?: IntFilter<"CryptoDeposit"> | number
    liminalTxnRefId?: StringFilter<"CryptoDeposit"> | string
    coin?: StringFilter<"CryptoDeposit"> | string
    walletId?: IntFilter<"CryptoDeposit"> | number
    timestamp?: StringFilter<"CryptoDeposit"> | string
    fee?: StringNullableFilter<"CryptoDeposit"> | string | null
    effectiveChange?: StringNullableFilter<"CryptoDeposit"> | string | null
    runningBalance?: StringNullableFilter<"CryptoDeposit"> | string | null
    externalAddress?: StringNullableFilter<"CryptoDeposit"> | string | null
    effectiveChangeUsd?: StringNullableFilter<"CryptoDeposit"> | string | null
    wallet?: JsonNullableFilter<"CryptoDeposit">
    tokenContractAddress?: StringNullableFilter<"CryptoDeposit"> | string | null
    explorerLink?: StringNullableFilter<"CryptoDeposit"> | string | null
    inputs?: JsonNullableListFilter<"CryptoDeposit">
    outputs?: JsonNullableListFilter<"CryptoDeposit">
    sequenceId?: StringNullableFilter<"CryptoDeposit"> | string | null
    type?: StringNullableFilter<"CryptoDeposit"> | string | null
    conversionRate?: StringNullableFilter<"CryptoDeposit"> | string | null
    isConverted?: BoolNullableFilter<"CryptoDeposit"> | boolean | null
    conversionTimestamp?: DateTimeNullableFilter<"CryptoDeposit"> | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFilter<"CryptoDeposit"> | $Enums.InrCreditStatus
    createdAt?: DateTimeFilter<"CryptoDeposit"> | Date | string
    createdBy?: IntFilter<"CryptoDeposit"> | number
    updatedAt?: DateTimeFilter<"CryptoDeposit"> | Date | string
    updatedBy?: IntFilter<"CryptoDeposit"> | number
  }

  export type InrLedgerCreateManyAccountInput = {
    id?: number
    change: number
    operation: $Enums.InrOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoLedgerCreateManyAccountInput = {
    id?: number
    coin: string
    change: number
    operation: $Enums.CryptoOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type TradeLedgerCreateManyAccountInput = {
    id?: number
    change: string
    tradeId: string
    positionType: $Enums.PositionType
    operation: $Enums.TradeOperation
    timestamp: Date | string
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoWalletCreateManyAccountInput = {
    id?: number
    parentWalletId: number
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrConversionHistoryCreateManyAccountInput = {
    id?: number
    cryptoDepositId?: number | null
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrLedgerUpdateWithoutAccountInput = {
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumInrOperationFieldUpdateOperationsInput | $Enums.InrOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrLedgerUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumInrOperationFieldUpdateOperationsInput | $Enums.InrOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrLedgerUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumInrOperationFieldUpdateOperationsInput | $Enums.InrOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoLedgerUpdateWithoutAccountInput = {
    coin?: StringFieldUpdateOperationsInput | string
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumCryptoOperationFieldUpdateOperationsInput | $Enums.CryptoOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoLedgerUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    coin?: StringFieldUpdateOperationsInput | string
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumCryptoOperationFieldUpdateOperationsInput | $Enums.CryptoOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoLedgerUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    coin?: StringFieldUpdateOperationsInput | string
    change?: FloatFieldUpdateOperationsInput | number
    operation?: EnumCryptoOperationFieldUpdateOperationsInput | $Enums.CryptoOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type TradeLedgerUpdateWithoutAccountInput = {
    change?: StringFieldUpdateOperationsInput | string
    tradeId?: StringFieldUpdateOperationsInput | string
    positionType?: EnumPositionTypeFieldUpdateOperationsInput | $Enums.PositionType
    operation?: EnumTradeOperationFieldUpdateOperationsInput | $Enums.TradeOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type TradeLedgerUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    change?: StringFieldUpdateOperationsInput | string
    tradeId?: StringFieldUpdateOperationsInput | string
    positionType?: EnumPositionTypeFieldUpdateOperationsInput | $Enums.PositionType
    operation?: EnumTradeOperationFieldUpdateOperationsInput | $Enums.TradeOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type TradeLedgerUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    change?: StringFieldUpdateOperationsInput | string
    tradeId?: StringFieldUpdateOperationsInput | string
    positionType?: EnumPositionTypeFieldUpdateOperationsInput | $Enums.PositionType
    operation?: EnumTradeOperationFieldUpdateOperationsInput | $Enums.TradeOperation
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoWalletUpdateWithoutAccountInput = {
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    parentWallet?: ParentWalletUpdateOneRequiredWithoutChildCryptoWalletNestedInput
    cryptoDeposit?: CryptoDepositUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentWalletId?: IntFieldUpdateOperationsInput | number
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    cryptoDeposit?: CryptoDepositUncheckedUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentWalletId?: IntFieldUpdateOperationsInput | number
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrConversionHistoryUpdateWithoutAccountInput = {
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    cryptoDeposit?: CryptoDepositUpdateOneWithoutInrConvHistRelNestedInput
  }

  export type InrConversionHistoryUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    cryptoDepositId?: NullableIntFieldUpdateOperationsInput | number | null
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrConversionHistoryUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    cryptoDepositId?: NullableIntFieldUpdateOperationsInput | number | null
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserBankDetailsCreateManyUserRelInput = {
    id?: number
    bankDetailsType?: $Enums.BankDetailsType
    bankAccountNumber?: string | null
    bankName?: string | null
    accountHolderName?: string | null
    ifsc?: string | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type FiatPaymentsCreateManyUserInput = {
    id?: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemBankId: number
    userBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type TwoFACreateManyUserInput = {
    id?: number
    email: string
    phone?: string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    status?: $Enums.TwoFAStatus
    reason: $Enums.Reason
    expiryTime: number
    mobileVerifiedAtleastOnce: boolean
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type UserBankDetailsUpdateWithoutUserRelInput = {
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankRel?: FiatPaymentsUpdateManyWithoutUserBankRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutSystemBankRelNestedInput
    UserRel?: UserUpdateManyWithoutBankDetailRelNestedInput
  }

  export type UserBankDetailsUncheckedUpdateWithoutUserRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankRel?: FiatPaymentsUncheckedUpdateManyWithoutUserBankRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutSystemBankRelNestedInput
    UserRel?: UserUncheckedUpdateManyWithoutBankDetailRelNestedInput
  }

  export type UserBankDetailsUncheckedUpdateManyWithoutUserRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    bankDetailsType?: EnumBankDetailsTypeFieldUpdateOperationsInput | $Enums.BankDetailsType
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc?: NullableStringFieldUpdateOperationsInput | string | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FiatPaymentsUpdateWithoutUserInput = {
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    systemBankRel?: UserBankDetailsUpdateOneWithoutFiatPaymentsRelNestedInput
    userBankRel?: UserBankDetailsUpdateOneWithoutUserBankRelNestedInput
    BankFeedRel?: BankFeedUpdateOneWithoutFiatPaymentNestedInput
  }

  export type FiatPaymentsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemBankId?: IntFieldUpdateOperationsInput | number
    userBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    BankFeedRel?: BankFeedUncheckedUpdateOneWithoutFiatPaymentNestedInput
  }

  export type FiatPaymentsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemBankId?: IntFieldUpdateOperationsInput | number
    userBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type TwoFAUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTwoFAStatusFieldUpdateOperationsInput | $Enums.TwoFAStatus
    reason?: EnumReasonFieldUpdateOperationsInput | $Enums.Reason
    expiryTime?: IntFieldUpdateOperationsInput | number
    mobileVerifiedAtleastOnce?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TwoFAUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTwoFAStatusFieldUpdateOperationsInput | $Enums.TwoFAStatus
    reason?: EnumReasonFieldUpdateOperationsInput | $Enums.Reason
    expiryTime?: IntFieldUpdateOperationsInput | number
    mobileVerifiedAtleastOnce?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TwoFAUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTwoFAStatusFieldUpdateOperationsInput | $Enums.TwoFAStatus
    reason?: EnumReasonFieldUpdateOperationsInput | $Enums.Reason
    expiryTime?: IntFieldUpdateOperationsInput | number
    mobileVerifiedAtleastOnce?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FiatPaymentsCreateManyUserBankRelInput = {
    id?: number
    userId: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    systemBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type FiatPaymentsCreateManySystemBankRelInput = {
    id?: number
    userId: number
    paymentType: $Enums.PaymentType
    paymentStatus?: $Enums.PaymentStatus
    userBankId: number
    systemAccountNumber: string
    userAccountNumber: string
    amount: number
    fee: number
    amountCredited?: number | null
    amountDebited?: number | null
    bankProofUrl?: string | null
    receiptNumber?: string | null
    userRemarks?: string | null
    adminRemarks?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserCreateManyBankDetailRelInput = {
    id?: number
    userType?: $Enums.UserType
    signupType?: $Enums.SignUpType | null
    role?: $Enums.Role
    email: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneCountryCode?: string
    initVector?: string | null
    password?: string | null
    passwordUpdatedAt?: Date | string | null
    kycStatus?: $Enums.UserKycStatus
    kycId?: number | null
    bankVerificationStatus?: $Enums.BankVerificationStatus
    isActive?: boolean
    inrDepositEnabled?: boolean
    cryptoDepositEnabled?: boolean
    inrWithdrawEnabled?: boolean
    cryptoWithdrawEnabled?: boolean
    tradeEnabled?: boolean
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    lastLogin?: Date | string | null
    createdAt?: Date | string
    createdBy?: number | null
    updatedAt?: Date | string
    updatedBy?: number | null
  }

  export type FiatPaymentsUpdateWithoutUserBankRelInput = {
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutFiatPaymentsRelNestedInput
    systemBankRel?: UserBankDetailsUpdateOneWithoutFiatPaymentsRelNestedInput
    BankFeedRel?: BankFeedUpdateOneWithoutFiatPaymentNestedInput
  }

  export type FiatPaymentsUncheckedUpdateWithoutUserBankRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    BankFeedRel?: BankFeedUncheckedUpdateOneWithoutFiatPaymentNestedInput
  }

  export type FiatPaymentsUncheckedUpdateManyWithoutUserBankRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type FiatPaymentsUpdateWithoutSystemBankRelInput = {
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutFiatPaymentsRelNestedInput
    userBankRel?: UserBankDetailsUpdateOneWithoutUserBankRelNestedInput
    BankFeedRel?: BankFeedUpdateOneWithoutFiatPaymentNestedInput
  }

  export type FiatPaymentsUncheckedUpdateWithoutSystemBankRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    userBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    BankFeedRel?: BankFeedUncheckedUpdateOneWithoutFiatPaymentNestedInput
  }

  export type FiatPaymentsUncheckedUpdateManyWithoutSystemBankRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    userBankId?: IntFieldUpdateOperationsInput | number
    systemAccountNumber?: StringFieldUpdateOperationsInput | string
    userAccountNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDebited?: NullableFloatFieldUpdateOperationsInput | number | null
    bankProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    userRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    adminRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutBankDetailRelInput = {
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserKycRel?: UserKycUpdateOneWithoutUserRelNestedInput
    UserBankDetailsRel?: UserBankDetailsUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBankDetailRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    kycId?: NullableIntFieldUpdateOperationsInput | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    UserBankDetailsRel?: UserBankDetailsUncheckedUpdateManyWithoutUserRelNestedInput
    FiatPaymentsRel?: FiatPaymentsUncheckedUpdateManyWithoutUserNestedInput
    UserAccountRel?: UserAccountUncheckedUpdateOneWithoutUserRelNestedInput
    TwoFARel?: TwoFAUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBankDetailRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    signupType?: NullableEnumSignUpTypeFieldUpdateOperationsInput | $Enums.SignUpType | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneCountryCode?: StringFieldUpdateOperationsInput | string
    initVector?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kycStatus?: EnumUserKycStatusFieldUpdateOperationsInput | $Enums.UserKycStatus
    kycId?: NullableIntFieldUpdateOperationsInput | number | null
    bankVerificationStatus?: EnumBankVerificationStatusFieldUpdateOperationsInput | $Enums.BankVerificationStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inrDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoDepositEnabled?: BoolFieldUpdateOperationsInput | boolean
    inrWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoWithdrawEnabled?: BoolFieldUpdateOperationsInput | boolean
    tradeEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InrConversionHistoryCreateManyCryptoDepositInput = {
    id?: number
    accountId: number
    baseToken: string
    baseTokenQuantity: number
    inrValue: number
    inrValAfterDeduction: number
    gst?: number | null
    txnFee?: number | null
    tds?: number | null
    coinConversionRate?: number | null
    receivingAddress?: string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type InrConversionHistoryUpdateWithoutCryptoDepositInput = {
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    account?: UserAccountUpdateOneRequiredWithoutInrConvRelNestedInput
  }

  export type InrConversionHistoryUncheckedUpdateWithoutCryptoDepositInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type InrConversionHistoryUncheckedUpdateManyWithoutCryptoDepositInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    baseTokenQuantity?: FloatFieldUpdateOperationsInput | number
    inrValue?: FloatFieldUpdateOperationsInput | number
    inrValAfterDeduction?: FloatFieldUpdateOperationsInput | number
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    txnFee?: NullableFloatFieldUpdateOperationsInput | number | null
    tds?: NullableFloatFieldUpdateOperationsInput | number | null
    coinConversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    receivingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type CryptoWalletCreateManyParentWalletInput = {
    id?: number
    accountId?: number | null
    liminalRefId: string
    liminalParentId: number
    liminalCoin: string
    liminalChain: string
    publicAddress: string
    balance?: number
    lastConversion?: Date | string | null
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type StableCoinCreateManyParentWalletInput = {
    id?: number
    token: string
    parentChain: string
    tokenIconUrl?: string | null
  }

  export type CryptoWalletUpdateWithoutParentWalletInput = {
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    account?: UserAccountUpdateOneWithoutCryptoWalletRelNestedInput
    cryptoDeposit?: CryptoDepositUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateWithoutParentWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    cryptoDeposit?: CryptoDepositUncheckedUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateManyWithoutParentWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    liminalRefId?: StringFieldUpdateOperationsInput | string
    liminalParentId?: IntFieldUpdateOperationsInput | number
    liminalCoin?: StringFieldUpdateOperationsInput | string
    liminalChain?: StringFieldUpdateOperationsInput | string
    publicAddress?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    lastConversion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type StableCoinUpdateWithoutParentWalletInput = {
    token?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    tokenIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StableCoinUncheckedUpdateWithoutParentWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    tokenIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StableCoinUncheckedUpdateManyWithoutParentWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    parentChain?: StringFieldUpdateOperationsInput | string
    tokenIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CryptoDepositCreateManyCryptoWalletInput = {
    id?: number
    accountId: number
    liminalTxnRefId: string
    coin: string
    walletId: number
    timestamp: string
    fee?: string | null
    effectiveChange?: string | null
    runningBalance?: string | null
    externalAddress?: string | null
    effectiveChangeUsd?: string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: string | null
    explorerLink?: string | null
    inputs?: CryptoDepositCreateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositCreateoutputsInput | InputJsonValue[]
    sequenceId?: string | null
    type?: string | null
    conversionRate?: string | null
    isConverted?: boolean | null
    conversionTimestamp?: Date | string | null
    inrCreditStatus?: $Enums.InrCreditStatus
    createdAt?: Date | string
    createdBy: number
    updatedAt?: Date | string
    updatedBy: number
  }

  export type CryptoDepositUpdateWithoutCryptoWalletInput = {
    accountId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    inrConvHistRel?: InrConversionHistoryUpdateManyWithoutCryptoDepositNestedInput
  }

  export type CryptoDepositUncheckedUpdateWithoutCryptoWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    inrConvHistRel?: InrConversionHistoryUncheckedUpdateManyWithoutCryptoDepositNestedInput
  }

  export type CryptoDepositUncheckedUpdateManyWithoutCryptoWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    liminalTxnRefId?: StringFieldUpdateOperationsInput | string
    coin?: StringFieldUpdateOperationsInput | string
    walletId?: IntFieldUpdateOperationsInput | number
    timestamp?: StringFieldUpdateOperationsInput | string
    fee?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChange?: NullableStringFieldUpdateOperationsInput | string | null
    runningBalance?: NullableStringFieldUpdateOperationsInput | string | null
    externalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveChangeUsd?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableJsonNullValueInput | InputJsonValue
    tokenContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    explorerLink?: NullableStringFieldUpdateOperationsInput | string | null
    inputs?: CryptoDepositUpdateinputsInput | InputJsonValue[]
    outputs?: CryptoDepositUpdateoutputsInput | InputJsonValue[]
    sequenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    conversionRate?: NullableStringFieldUpdateOperationsInput | string | null
    isConverted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inrCreditStatus?: EnumInrCreditStatusFieldUpdateOperationsInput | $Enums.InrCreditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserAccountCountOutputTypeDefaultArgs instead
     */
    export type UserAccountCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBankDetailsCountOutputTypeDefaultArgs instead
     */
    export type UserBankDetailsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserBankDetailsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoDepositCountOutputTypeDefaultArgs instead
     */
    export type CryptoDepositCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CryptoDepositCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentWalletCountOutputTypeDefaultArgs instead
     */
    export type ParentWalletCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ParentWalletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoWalletCountOutputTypeDefaultArgs instead
     */
    export type CryptoWalletCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CryptoWalletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAccountDefaultArgs instead
     */
    export type UserAccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepositWithdrawLimitsDefaultArgs instead
     */
    export type DepositWithdrawLimitsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DepositWithdrawLimitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TwoFADefaultArgs instead
     */
    export type TwoFAArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TwoFADefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserKycDefaultArgs instead
     */
    export type UserKycArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserKycDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncryptedUserDataDefaultArgs instead
     */
    export type EncryptedUserDataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = EncryptedUserDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBankDetailsDefaultArgs instead
     */
    export type UserBankDetailsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserBankDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FiatPaymentsDefaultArgs instead
     */
    export type FiatPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = FiatPaymentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoDepositDefaultArgs instead
     */
    export type CryptoDepositArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CryptoDepositDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InrConversionHistoryDefaultArgs instead
     */
    export type InrConversionHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = InrConversionHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankFeedDefaultArgs instead
     */
    export type BankFeedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BankFeedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InrLedgerDefaultArgs instead
     */
    export type InrLedgerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = InrLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoLedgerDefaultArgs instead
     */
    export type CryptoLedgerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CryptoLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TradeLedgerDefaultArgs instead
     */
    export type TradeLedgerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TradeLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigForDashboardDefaultArgs instead
     */
    export type SystemConfigForDashboardArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SystemConfigForDashboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigChangeLogDefaultArgs instead
     */
    export type SystemConfigChangeLogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SystemConfigChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InrWalletDefaultArgs instead
     */
    export type InrWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = InrWalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentWalletDefaultArgs instead
     */
    export type ParentWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ParentWalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StableCoinDefaultArgs instead
     */
    export type StableCoinArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StableCoinDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoWalletDefaultArgs instead
     */
    export type CryptoWalletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CryptoWalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerpetualContractsDefaultArgs instead
     */
    export type PerpetualContractsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PerpetualContractsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KlineHistoricalDataDefaultArgs instead
     */
    export type KlineHistoricalDataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = KlineHistoricalDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserOrderHistoryDefaultArgs instead
     */
    export type UserOrderHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserOrderHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTradeHistoryDefaultArgs instead
     */
    export type UserTradeHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserTradeHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserPositionHistoryDefaultArgs instead
     */
    export type UserPositionHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserPositionHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BinanceOrderHistoryDefaultArgs instead
     */
    export type BinanceOrderHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BinanceOrderHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BinanceTradeHistoryDefaultArgs instead
     */
    export type BinanceTradeHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BinanceTradeHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoinwiseTradeRecoincilliationDefaultArgs instead
     */
    export type CoinwiseTradeRecoincilliationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CoinwiseTradeRecoincilliationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoinwisePositionRecoincilliationDefaultArgs instead
     */
    export type CoinwisePositionRecoincilliationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CoinwisePositionRecoincilliationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoicesDefaultArgs instead
     */
    export type InvoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = InvoicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportsDefaultArgs instead
     */
    export type ReportsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ReportsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}